export default function(vm)
{
    const ext_env = vm.get_system_environment();
    const extref = (sym) => ext_env.lookup(sym);
    const N = vm.nil();
    const V = vm.void();
    const I = vm.ignore();
    const T = vm.t();
    const F = vm.f();
    const _variable = (s) => vm.sym(s);
    const _function = (s) => vm.fsym(s);
    const _keyword = (s) => vm.kwd(s);
    const _class = (s) => vm.csym(s);
    const str = (x) => vm.str(x);
    const num = (x) => vm.num(x);
    const C = (a,b) => vm.cons(a, b);

    const dcons = () => vm.cons(V,V);
    const dfex = () => new vm.Fexpr(I, I, I, ext_env);
    const dfun = () => vm.wrap(dfex());
    const denv = (parent) => vm.make_environment(parent);
    const dobj = (cls) => vm.make_instance(cls);
    const dcls = (name, superclass) => vm.make_standard_class(name, superclass);

    const fcons = (cons, car, cdr) => { cons.set_car(car); cons.set_cdr(cdr); return cons; };
    const ffex = (f, p, ep, b, e) => { f.param_tree=p; f.env_param=ep; f.body_form=b; f.def_env=e; return f; };
    const ffun = (f, op) => { f.wrapped_operator = op; return f; }
    const fenv = (e, ...bindings) => {
        for (let i = 0; i < bindings.length; i = i + 2) {
            const name = bindings[i];
            const value = bindings[i + 1];
            e.put(name, value);
        }
        return e;
    };
    const fobj = (obj, ...slots) => {
        for (let i = 0; i < slots.length; i = i + 2) {
            const name = slots[i];
            const value = slots[i + 1];
            obj.set_slot_value(name, value);
        }
        return obj;
    };
    const fcls = (cls, ...methods) => {
        for (let i = 0; i < methods.length; i = i + 2) {
            const name = methods[i];
            const method = methods[i + 1];
            cls.add_method(name, method);
        }
        return cls;
    }
    const objects = [];

    function push(expr) { objects[objects.length] = expr; }
    function toporef(i) { return objects[i]; }
push(denv(ext_env));
push(dcons());
push(dcons());
push(dcons());
push(dcons());
push(dcons());
push(dfun());
push(dfun());
push(dfun());
push(dfun());
push(dfun());
push(dcons());
push(dcons());
push(dcons());
push(dcons());
push(dcons());
push(dcons());
push(dobj(extref(_class("dynamic"))));
push(dobj(extref(_class("dynamic"))));
push(dcons());
push(dcons());
push(dfex());
push(dfex());
push(dcons());
push(dcons());
push(dfun());
push(dfun());
fenv(toporef(0),_function("list"),ffun(dfun(),ffex(dfex(),_variable("arguments"),I,_variable("arguments"),toporef(0))),_function("vau"),ffex(dfex(),C(_variable("parameter-tree"),C(_variable("environment-parameter"),_variable("forms"))),_variable("env"),C(_variable("%eval"),C(C(_variable("list"),C(_function("%vau"),C(_variable("parameter-tree"),C(_variable("environment-parameter"),C(C(_variable("%list*"),C(_function("%progn"),C(_variable("forms"),N))),N))))),C(_variable("env"),N))),toporef(0)),_function("lispx::make-macro"),ffun(dfun(),ffex(dfex(),C(_variable("expander"),N),I,C(_variable("%vau"),C(_variable("operand"),C(_variable("env"),C(toporef(1),N)))),toporef(0))),_function("macro"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("parameter-tree"),_variable("forms")),I,C(_variable("list"),C(_function("lispx::make-macro"),C(C(_variable("%list*"),C(_function("vau"),C(_variable("parameter-tree"),C(I,C(_variable("forms"),N))))),N))),toporef(0)))),_function("defmacro"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("parameter-tree"),_variable("forms"))),I,C(extref(_function("%progn")),C(C(_variable("list"),C(_function("%def"),C(C(_variable("%function-symbol"),C(_variable("name"),N)),C(C(_variable("%list*"),C(_function("macro"),C(_variable("parameter-tree"),C(_variable("forms"),N)))),N)))),N)),toporef(0)))),_function("defexpr"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("parameter-tree"),C(_variable("environment-parameter"),_variable("forms")))),I,C(extref(_function("%progn")),C(str("Define a fexpr with the given NAME, PARAMETER-TREE,\nENVIRONMENT-PARAMETER, and FORMS."),C(C(_variable("list"),C(_function("%def"),C(C(_variable("%function-symbol"),C(_variable("name"),N)),C(C(_variable("%list*"),C(_function("vau"),C(_variable("parameter-tree"),C(_variable("environment-parameter"),C(_variable("forms"),N))))),N)))),N))),toporef(0)))),_function("def"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("definiend-tree"),C(_variable("value"),_variable("docstring?"))),I,C(extref(_function("%progn")),C(str("Match the DEFINIEND-TREE against the VALUE and place resulting\nbindings into the current environment.  The optional DOCSTRING? is\ncurrently ignored."),C(C(_variable("list"),C(_function("%def"),C(_variable("definiend-tree"),C(_variable("value"),N)))),N))),toporef(0)))),_function("defconstant"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("value"),_variable("docstring?"))),I,C(extref(_function("%progn")),C(str("Define a constant with the given NAME and VALUE.  This is mostly\nfor documentation purposes, as constants are still mutable.  The\noptional DOCSTRING? is currently ignored."),C(C(_variable("list"),C(_function("def"),C(_variable("name"),C(_variable("value"),N)))),N))),toporef(0)))),_function("lambda"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("parameter-tree"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Create an anonymous function with the given PARAMETER-TREE and FORMS."),C(C(_variable("list"),C(_function("%wrap"),C(C(_variable("%list*"),C(_function("vau"),C(_variable("parameter-tree"),C(I,C(_variable("forms"),N))))),N))),N))),toporef(0)))),_function("defun"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("parameter-tree"),_variable("forms"))),I,C(extref(_function("%progn")),C(str("Define a function with the given NAME, PARAMETER-TREE, and FORMS."),C(C(_variable("list"),C(_function("def"),C(C(_variable("%function-symbol"),C(_variable("name"),N)),C(C(_variable("%list*"),C(_function("lambda"),C(_variable("parameter-tree"),C(_variable("forms"),N)))),N)))),N))),toporef(0)))),_function("progn"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),_variable("forms"),I,C(extref(_function("%progn")),C(str("Sequentially evaluate FORMS, returning the value of the last one,\nor void if there are no forms."),C(C(_variable("list*"),C(_function("%progn"),C(_variable("forms"),N))),N))),toporef(0)))),_function("if"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("test"),C(_variable("consequent"),C(_variable("alternative"),N))),I,C(extref(_function("%progn")),C(str("Evaluate the TEST which must yield a boolean.  Then evaluate either\nthe CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded\ntrue or false."),C(C(_variable("list"),C(_function("%if"),C(_variable("test"),C(_variable("consequent"),C(_variable("alternative"),N))))),N))),toporef(0)))),_function("catch"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("tag"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Establish a catch tag and evaluate FORMS as an implicit `progn'\ninside it.  The forms may use `throw' to nonlocally exit from the\ntag.  Usually, `block' should be preferred."),C(C(_variable("list"),C(_function("%catch"),C(_variable("tag"),C(C(_variable("list*"),C(_function("lambda"),C(N,C(_variable("forms"),N)))),N)))),N))),toporef(0)))),_function("throw"),ffun(dfun(),ffex(dfex(),C(_variable("tag"),_variable("result?")),I,C(extref(_function("%progn")),C(str("Abort to a nesting catch tag established by `catch' and pass the\noptional RESULT? (defaults to void) to it."),C(C(_variable("%throw"),C(_variable("tag"),C(C(_variable("optional"),C(_variable("result?"),N)),N))),N))),toporef(0))),_function("loop"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),_variable("forms"),I,C(extref(_function("%progn")),C(str("Evaluate the FORMS in an infinite loop."),C(C(_variable("list"),C(_function("%loop"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),N))),N))),toporef(0)))),_function("eq"),ffun(dfun(),ffex(dfex(),C(_variable("a"),C(_variable("b"),N)),I,C(extref(_function("%progn")),C(str("Return true if the values A and B are pointer-identical, false otherwise."),C(C(_variable("%eq"),C(_variable("a"),C(_variable("b"),N))),N))),toporef(0))),_function("class-of"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Return the class of the OBJECT."),C(C(_variable("%class-of"),C(_variable("object"),N)),N))),toporef(0))),_function("typep"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("class"),N)),I,C(extref(_function("%progn")),C(str("Return true if the OBJECT is an instance of the CLASS, false otherwise."),C(C(_variable("%typep"),C(_variable("object"),C(_variable("class"),N))),N))),toporef(0))),_function("intern"),ffun(dfun(),ffex(dfex(),C(_variable("string"),N),I,C(extref(_function("%progn")),C(str("Get or create the unique symbol with STRING as name."),C(C(_variable("%intern"),C(_variable("string"),N)),N))),toporef(0))),_function("symbol-name"),ffun(dfun(),ffex(dfex(),C(_variable("symbol"),N),I,C(extref(_function("%progn")),C(str("Return the name of the SYMBOL as a string."),C(C(_variable("%symbol-name"),C(_variable("symbol"),N)),N))),toporef(0))),_function("variable-symbol"),ffun(dfun(),ffex(dfex(),C(_variable("symbol"),N),I,C(extref(_function("%progn")),C(str("Return the symbol with the same name as SYMBOL, but in the variable namespace."),C(C(_variable("%variable-symbol"),C(_variable("symbol"),N)),N))),toporef(0))),_function("function-symbol"),ffun(dfun(),ffex(dfex(),C(_variable("symbol"),N),I,C(extref(_function("%progn")),C(str("Return the symbol with the same name as SYMBOL, but in the function namespace."),C(C(_variable("%function-symbol"),C(_variable("symbol"),N)),N))),toporef(0))),_function("class-symbol"),ffun(dfun(),ffex(dfex(),C(_variable("symbol"),N),I,C(extref(_function("%progn")),C(str("Return the symbol with the same name as SYMBOL, but in the class namespace."),C(C(_variable("%class-symbol"),C(_variable("symbol"),N)),N))),toporef(0))),_function("keyword-symbol"),ffun(dfun(),ffex(dfex(),C(_variable("symbol"),N),I,C(extref(_function("%progn")),C(str("Return the symbol with the same name as SYMBOL, but in the keyword namespace."),C(C(_variable("%keyword-symbol"),C(_variable("symbol"),N)),N))),toporef(0))),_function("cons"),ffun(dfun(),ffex(dfex(),C(_variable("car"),C(_variable("cdr"),N)),I,C(extref(_function("%progn")),C(str("Create a cons with the given CAR and CDR."),C(C(_variable("%cons"),C(_variable("car"),C(_variable("cdr"),N))),N))),toporef(0))),_function("car"),ffun(dfun(),ffex(dfex(),C(_variable("cons"),N),I,C(extref(_function("%progn")),C(str("Return the contents of the address part of the register."),C(C(_variable("%car"),C(_variable("cons"),N)),N))),toporef(0))),_function("cdr"),ffun(dfun(),ffex(dfex(),C(_variable("cons"),N),I,C(extref(_function("%progn")),C(str("Return the contents of the decrement part of the register."),C(C(_variable("%cdr"),C(_variable("cons"),N)),N))),toporef(0))),_function("list*"),ffun(dfun(),ffex(dfex(),_variable("arguments"),I,C(extref(_function("%progn")),C(str("Create a list from the ARGUMENTS so that the last argument becomes\nthe `cdr' of the list."),C(C(_variable("apply"),C(_function("%list*"),C(_variable("arguments"),N))),N))),toporef(0))),_function("reverse"),ffun(dfun(),ffex(dfex(),C(_variable("list"),N),I,C(extref(_function("%progn")),C(str("Reverse the LIST."),C(C(_variable("%reverse"),C(_variable("list"),N)),N))),toporef(0))),_function("wrap"),ffun(dfun(),ffex(dfex(),C(_variable("operator"),N),I,C(extref(_function("%progn")),C(str("Create a new function that wraps around an underlying OPERATOR, and\ninduces argument evaluation around it."),C(C(_variable("%wrap"),C(_variable("operator"),N)),N))),toporef(0))),_function("unwrap"),ffun(dfun(),ffex(dfex(),C(_variable("function"),N),I,C(extref(_function("%progn")),C(str("Return the underlying operator of a FUNCTION."),C(C(_variable("%unwrap"),C(_variable("function"),N)),N))),toporef(0))),_function("eval"),ffun(dfun(),ffex(dfex(),C(_variable("form"),C(_variable("environment"),N)),I,C(extref(_function("%progn")),C(str("Evaluate the FORM in the ENVIRONMENT, returning its result."),C(C(_variable("%eval"),C(_variable("form"),C(_variable("environment"),N))),N))),toporef(0))),_function("make-environment"),ffun(dfun(),ffex(dfex(),_variable("parent-environment?"),I,C(extref(_function("%progn")),C(str("Create a new environment with an optional PARENT-ENVIRONMENT? in\nwhich bindings are looked up if they are not found."),C(C(_variable("apply"),C(_function("%make-environment"),C(_variable("parent-environment?"),N))),N))),toporef(0))),_function("boundp"),ffun(dfun(),ffex(dfex(),C(_variable("symbol"),C(_variable("environment"),N)),I,C(extref(_function("%progn")),C(str("Return true if the SYMBOL is bound in the ENVIRONMENT, false otherwise."),C(C(_variable("%boundp"),C(_variable("symbol"),C(_variable("environment"),N))),N))),toporef(0))),_function("panic"),ffun(dfun(),ffex(dfex(),C(_variable("error"),N),I,C(extref(_function("%progn")),C(str("Mostly for internal use.  Signal the ERROR in such a way that it is\nhard to handle and will usually escape the VM as a host language\nexception.  In particular, signal handlers will not be invoked.\nHowever, intervening `unwind-protect' cleanup expressions and `progv'\nexpressions are still triggered, so Lisp invariants are maintained."),C(C(_variable("%panic"),C(_variable("error"),N)),N))),toporef(0))),_function("invoke-debugger"),ffun(dfun(),ffex(dfex(),C(_variable("condition"),N),I,C(extref(_function("%progn")),C(str("Invoke the debugger, which as a default just prints a stack trace\nand panics, thereby throwing an exception to JS.  When running in the\nREPL, this function gets replaced with a different one that runs a\nnested debug loop."),C(C(_variable("take-subcont"),C(_variable("+root-prompt+"),C(_variable("k"),C(C(_variable("push-delim-subcont"),C(_variable("+root-prompt+"),C(_variable("k"),C(C(_variable("%print-stacktrace"),C(_variable("k"),N)),C(C(_variable("panic"),C(_variable("condition"),N)),N))))),N)))),N))),toporef(0))),_function("let"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("bindings"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Establish BINDINGS parallelly during the evaluation of FORMS, so\nthat no binding can refer to the other ones.\n$(syntax binding (definiend-tree value))"),C(C(_variable("list*"),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("mapcar"),C(_function("car"),C(_variable("bindings"),N))),C(_variable("forms"),N)))),C(C(_variable("mapcar"),C(_function("cadr"),C(_variable("bindings"),N))),N))),N))),toporef(0)))),_function("let*"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("bindings"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Establish BINDINGS serially during the evaluation of FORMS, so that\nevery binding can refer to previous ones.\n$(syntax binding (definiend-tree value))"),C(C(_variable("if"),C(C(_variable("null"),C(_variable("bindings"),N)),C(C(_variable("list*"),C(_function("let"),C(N,C(_variable("forms"),N)))),C(C(_variable("list"),C(_function("let"),C(C(_variable("list"),C(C(_variable("car"),C(_variable("bindings"),N)),N)),C(C(_variable("list*"),C(_function("let*"),C(C(_variable("cdr"),C(_variable("bindings"),N)),C(_variable("forms"),N)))),N)))),N)))),N))),toporef(0)))),_function("lispx::letrec"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("bindings"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Utility to establish BINDINGS recursively during the evaluation of\nFORMS.  Used by `labels'."),C(C(_variable("if"),C(C(_variable("null"),C(_variable("bindings"),N)),C(C(_variable("list*"),C(_function("let"),C(N,C(_variable("forms"),N)))),C(C(_variable("list*"),C(_function("let"),C(N,C(C(_variable("list"),C(_function("def"),C(C(_variable("mapcar"),C(_function("car"),C(_variable("bindings"),N))),C(C(_variable("list*"),C(_function("list"),C(C(_variable("mapcar"),C(_function("cadr"),C(_variable("bindings"),N))),N))),N)))),C(_variable("forms"),N))))),N)))),N))),toporef(0)))),_function("lispx::make-function-binding"),ffun(dfun(),ffex(dfex(),C(C(_variable("name"),C(_variable("parameter-tree"),_variable("forms"))),N),I,C(extref(_function("%progn")),C(str("Utility to turn a function binding as it appears in `flet' and\n`labels' into a binding for `let' or `lispx::letrec'."),C(C(_variable("list"),C(C(_variable("function-symbol"),C(_variable("name"),N)),C(C(_variable("list*"),C(_function("lambda"),C(_variable("parameter-tree"),C(_variable("forms"),N)))),N))),N))),toporef(0))),_function("flet"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("function-bindings"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,\nso that no function can refer to the other ones.\n$(syntax function-binding (name parameter-tree . forms))"),C(C(_variable("list*"),C(_function("let"),C(C(_variable("mapcar"),C(_function("lispx::make-function-binding"),C(_variable("function-bindings"),N))),C(_variable("forms"),N)))),N))),toporef(0)))),_function("labels"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("function-bindings"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,\nso that every function can refer to the other ones.\n$(syntax function-binding (name parameter-tree . forms))"),C(C(_variable("list*"),C(_function("lispx::letrec"),C(C(_variable("mapcar"),C(_function("lispx::make-function-binding"),C(_variable("function-bindings"),N))),C(_variable("forms"),N)))),N))),toporef(0)))),_function("quote"),ffex(dfex(),C(_variable("operand"),N),I,C(extref(_function("%progn")),C(str("Return the unevaluated OPERAND."),C(_variable("operand"),N))),toporef(0)),_function("the-environment"),ffex(dfex(),N,_variable("environment"),C(extref(_function("%progn")),C(str("Return the current environment."),C(_variable("environment"),N))),toporef(0)),_function("apply"),ffun(dfun(),ffex(dfex(),C(_variable("function"),C(_variable("arguments"),N)),I,C(extref(_function("%progn")),C(str("Call the FUNCTION with a dynamically-supplied list of ARGUMENTS."),C(C(_variable("eval"),C(C(_variable("cons"),C(C(_variable("unwrap"),C(_variable("function"),N)),C(_variable("arguments"),N))),C(C(_variable("%make-environment"),N),N))),N))),toporef(0))),_function("when"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("test"),_variable("forms")),I,C(extref(_function("%progn")),C(str("If TEST yields true, evaluate the FORMS as an implicit `progn'.\nOtherwise, return void."),C(C(_variable("list"),C(_function("if"),C(_variable("test"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(V,N))))),N))),toporef(0)))),_function("unless"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("test"),_variable("forms")),I,C(extref(_function("%progn")),C(str("If TEST yields false, evaluate the FORMS as an implicit `progn'.\nOtherwise, return void."),C(C(_variable("list"),C(_function("if"),C(_variable("test"),C(V,C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),N))))),N))),toporef(0)))),_function("cond"),ffex(dfex(),_variable("clauses"),_variable("env"),C(extref(_function("%progn")),C(str("Multi-armed conditional.\nGo through the CLAUSES in order.  Evaluate the TEST.  If it yields\ntrue, evaluate the FORMS as an implicit `progn'.  If it yields false,\ngo to the next clause, or return void if there are no more clauses.\n$(syntax clause (test . forms))"),C(C(_variable("unless"),C(C(_variable("null"),C(_variable("clauses"),N)),C(C(_variable("let"),C(C(C(C(C(_variable("test"),_variable("forms")),_variable("rest-clauses")),C(_variable("clauses"),N)),N),C(C(_variable("if"),C(C(_variable("eval"),C(_variable("test"),C(_variable("env"),N))),C(C(_variable("eval"),C(C(_variable("cons"),C(_function("progn"),C(_variable("forms"),N))),C(_variable("env"),N))),C(C(_variable("eval"),C(C(_variable("cons"),C(_function("cond"),C(_variable("rest-clauses"),N))),C(_variable("env"),N))),N)))),N))),N))),N))),toporef(0)),_function("not"),ffun(dfun(),ffex(dfex(),C(_variable("boolean"),N),I,C(extref(_function("%progn")),C(str("Invert the BOOLEAN."),C(C(_variable("if"),C(_variable("boolean"),C(F,C(T,N)))),N))),toporef(0))),_function("and"),ffex(dfex(),_variable("operands"),_variable("env"),C(extref(_function("%progn")),C(str("Return true if all OPERANDS evaluate to true, false otherwise.  If\nan operand evaluates to false, later operands are not evaluated.  If\nthere are no operands, return false."),C(C(_variable("cond"),C(C(C(_variable("null"),C(_variable("operands"),N)),C(T,N)),C(C(C(_variable("null"),C(C(_variable("cdr"),C(_variable("operands"),N)),N)),C(C(_variable("the"),C(_variable("boolean"),C(C(_variable("eval"),C(C(_variable("car"),C(_variable("operands"),N)),C(_variable("env"),N))),N))),N)),C(C(C(_variable("eval"),C(C(_variable("car"),C(_variable("operands"),N)),C(_variable("env"),N))),C(C(_variable("eval"),C(C(_variable("cons"),C(_function("and"),C(C(_variable("cdr"),C(_variable("operands"),N)),N))),C(_variable("env"),N))),N)),C(C(T,C(F,N)),N))))),N))),toporef(0)),_function("or"),ffex(dfex(),_variable("operands"),_variable("env"),C(extref(_function("%progn")),C(str("Return true if one of the OPERANDS evaluates to true, false\notherwise.  If an operand evaluates to true, later operands are not\nevaluated.  If there are no operands, return true."),C(C(_variable("cond"),C(C(C(_variable("null"),C(_variable("operands"),N)),C(F,N)),C(C(C(_variable("null"),C(C(_variable("cdr"),C(_variable("operands"),N)),N)),C(C(_variable("the"),C(_variable("boolean"),C(C(_variable("eval"),C(C(_variable("car"),C(_variable("operands"),N)),C(_variable("env"),N))),N))),N)),C(C(C(_variable("eval"),C(C(_variable("car"),C(_variable("operands"),N)),C(_variable("env"),N))),C(T,N)),C(C(T,C(C(_variable("eval"),C(C(_variable("cons"),C(_function("or"),C(C(_variable("cdr"),C(_variable("operands"),N)),N))),C(_variable("env"),N))),N)),N))))),N))),toporef(0)),_function("while"),ffex(dfex(),C(_variable("test-form"),_variable("forms")),_variable("env"),C(extref(_function("%progn")),C(str("Evaluate FORMS while TEST-FORM evaluates to true."),C(C(_variable("let"),C(C(C(_variable("forms"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),N)),N),C(C(_variable("block"),C(_variable("exit"),C(C(_variable("loop"),C(C(_variable("if"),C(C(_variable("eval"),C(_variable("test-form"),C(_variable("env"),N))),C(C(_variable("eval"),C(_variable("forms"),C(_variable("env"),N))),C(C(_variable("return-from"),C(_variable("exit"),N)),N)))),N)),N))),N))),N))),toporef(0)),_function("until"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("test-form"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Evaluate FORMS until TEST-FORM evaluates to true."),C(C(_variable("list*"),C(_function("while"),C(C(_variable("list"),C(_function("not"),C(_variable("test-form"),N))),C(_variable("forms"),N)))),N))),toporef(0)))),_function("dotimes"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(C(_variable("var"),C(_variable("count-form"),_variable("result-form?"))),_variable("body-forms")),I,C(extref(_function("%progn")),C(str("Cf. Common Lisp's DOTIMES."),C(C(_variable("flet"),C(C(C(_variable("_dotimes_"),C(C(_variable("n"),C(_function("body"),C(_function("result"),N))),C(C(_variable("let"),C(C(C(_function("i"),C(C(_variable("box"),C(num("0"),N)),N)),N),C(C(_variable("while"),C(C(_variable("<"),C(C(_variable("i"),N),C(_variable("n"),N))),C(C(_variable("body"),C(C(_variable("i"),N),N)),C(C(_variable("i"),C(C(_variable("+"),C(C(_variable("i"),N),C(num("1"),N))),N)),N)))),C(C(_variable("result"),C(C(_variable("i"),N),N)),N)))),N))),N),C(C(_variable("list"),C(_function("_dotimes_"),C(_variable("count-form"),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list"),C(_variable("var"),N)),C(_variable("body-forms"),N)))),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list"),C(_variable("var"),N)),C(_variable("result-form?"),N)))),N))))),N))),N))),toporef(0)))),_function("loop-let"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("initializers"),_variable("forms"))),I,C(extref(_function("%progn")),C(str("Labelled recursive loop, analogous to Scheme's named `let'.\nLexically bind a function named NAME with one PARAMETER for every\nINITIALIZER and the FORMS as body.  Then immediately apply the\nfunction to a list containing one VALUE for every INITIALIZER and\nreturn the result.  The function is bound per `labels' so it can\nrecursively refer to itself.\n$(syntax initializer (parameter value))"),C(C(_variable("list"),C(_function("labels"),C(C(_variable("list"),C(C(_variable("list*"),C(_variable("name"),C(C(_variable("mapcar"),C(_function("car"),C(_variable("initializers"),N))),C(_variable("forms"),N)))),N)),C(C(_variable("list*"),C(_variable("name"),C(C(_variable("mapcar"),C(_function("cadr"),C(_variable("initializers"),N))),N))),N)))),N))),toporef(0)))),_function("block"),ffex(dfex(),C(_variable("block-name"),_variable("forms")),_variable("env"),C(extref(_function("%progn")),C(str("Establish a block named BLOCK-NAME and evaluate the FORMS as an\nimplicit `progn' inside it.  The forms may use `return-from' to\nnonlocally exit from the block.\nNote that unlike in Common Lisp, there is no separate namespace for\nblock names; a block is named in the normal variable namespace."),C(C(_variable("let"),C(C(C(_variable("tag"),C(C(_variable("list"),C(V,N)),N)),N),C(C(_variable("flet"),C(C(C(_variable("escape"),C(C(_variable("value"),N),C(C(_variable("throw"),C(_variable("tag"),C(_variable("value"),N))),N))),N),C(C(_variable("catch"),C(_variable("tag"),C(C(_variable("eval"),C(C(_variable("list"),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list"),C(_variable("block-name"),N)),C(_variable("forms"),N)))),C(_function("escape"),N))),C(_variable("env"),N))),N))),N))),N))),N))),toporef(0)),_function("return-from"),ffun(dfun(),ffex(dfex(),C(_function("block-name"),_variable("value?")),I,C(extref(_function("%progn")),C(str("Abort evaluation and return the optional VALUE? (which defaults to\nvoid) from the block named BLOCK-NAME.  It is an error to return from\na block whose dynamic extent has ended.\n$(fn (block-name . value?))"),C(C(_variable("block-name"),C(C(_variable("optional"),C(_variable("value?"),N)),N)),N))),toporef(0))),_function("unwind-protect"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("protected-form"),_variable("cleanup-forms")),I,C(extref(_function("%progn")),C(str("Evaluate the PROTECTED-FORM and return its result.  Regardless of\nwhether the protected form returns normally, or via a nonlocal exit or\npanic, the CLEANUP-FORMS are evaluated after the protected form."),C(C(_variable("list"),C(_function("%unwind-protect"),C(_variable("protected-form"),C(C(_variable("list*"),C(_function("progn"),C(_variable("cleanup-forms"),N))),N)))),N))),toporef(0)))),_function("prog1"),ffex(dfex(),C(_variable("form"),_variable("forms")),_variable("env"),C(extref(_function("%progn")),C(str("Evaluate FORM and any additional FORMS, and return the result of FORM."),C(C(_variable("let"),C(C(C(_variable("result"),C(C(_variable("eval"),C(_variable("form"),C(_variable("env"),N))),N)),N),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(_variable("env"),N))),C(_variable("result"),N)))),N))),toporef(0)),_function("lispx::make-typecase-with-default-function"),ffun(dfun(),ffex(dfex(),C(_function("default"),N),I,C(extref(_function("%progn")),C(str("Metaprogramming utility used to create `typecase' and `etypecase'.\nIf no matching clause is found, the DEFAULT function is called with\nthe key."),C(C(_variable("vau"),C(toporef(2),C(_variable("env"),toporef(3)))),N))),toporef(0))),_function("typecase"),ffex(dfex(),toporef(2),_variable("env"),C(extref(_function("%progn")),toporef(3)),fenv(denv(toporef(0)),_function("default"),ffun(dfun(),ffex(dfex(),C(I,N),I,C(extref(_function("%progn")),C(V,N)),toporef(0))))),_function("etypecase"),ffex(dfex(),toporef(2),_variable("env"),C(extref(_function("%progn")),toporef(3)),fenv(denv(toporef(0)),_function("default"),ffun(dfun(),ffex(dfex(),C(_variable("key"),N),I,C(extref(_function("%progn")),C(C(_variable("error"),C(C(_variable("make-type-error"),C(_variable("key"),C(_class("object"),N))),N)),N)),toporef(0))))),_function("set"),ffex(dfex(),C(_variable("environment"),C(_variable("definiend-tree"),C(_variable("value"),N))),_variable("dynamic-environment"),C(extref(_function("%progn")),C(str("Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,\ncreating or updating existing bindings.  Unlike Common Lisp (or\nScheme), we have no `setq' (or `set!') that allows updating arbitrary\nbindings -- you always need to know the environment a binding is in to\nchange it.  Therefore, we usually use boxes (see below) instead of\nmutating bindings directly."),C(C(_variable("eval"),C(C(_variable("list"),C(_function("def"),C(_variable("definiend-tree"),C(C(_variable("list"),C(C(_variable("unwrap"),C(_function("eval"),N)),C(_variable("value"),C(_variable("dynamic-environment"),N)))),N)))),C(C(_variable("eval"),C(_variable("environment"),C(_variable("dynamic-environment"),N))),N))),N))),toporef(0)),_function("box"),ffun(dfun(),ffex(dfex(),_variable("initial-value?"),I,C(extref(_function("%progn")),C(str("Create a new box with the optional INITIAL-VALUE?.  A box is a\nfunction that encapsulates a mutable value.  Calling the box without\narguments returns the value.  Calling the box with an argument sets\nthe value."),C(C(_variable("def"),C(_variable("value"),C(C(_variable("optional"),C(_variable("initial-value?"),N)),N))),C(C(_variable("def"),C(_variable("env"),C(C(_variable("the-environment"),N),N))),C(C(_variable("lambda"),C(_variable("new-value?"),C(C(_variable("if-option"),C(C(_variable("new-value"),C(_variable("new-value?"),N)),C(C(_variable("set"),C(_variable("env"),C(_variable("value"),C(_variable("new-value"),N)))),C(_variable("value"),N)))),N))),N))))),toporef(0))),_function("assert"),ffun(dfun(),ffex(dfex(),C(_variable("boolean"),N),I,C(extref(_function("%progn")),C(str("Signal an error if the BOOLEAN is false.  Otherwise return void."),C(C(_variable("unless"),C(_variable("boolean"),C(C(_variable("error"),C(C(_variable("make-instance"),C(_class("assertion-error"),N)),N)),N))),N))),toporef(0))),_function("compose"),ffun(dfun(),ffex(dfex(),C(_function("f"),C(_function("g"),N)),I,C(extref(_function("%progn")),C(str("Compose two functions, creating a new function equivalent to (G (F ...))."),C(C(_variable("lambda"),C(_variable("args"),C(C(_variable("g"),C(C(_variable("apply"),C(_function("f"),C(_variable("args"),N))),N)),N))),N))),toporef(0))),_function("identity"),ffun(dfun(),ffex(dfex(),C(_variable("x"),N),I,C(extref(_function("%progn")),C(str("Identity function."),C(_variable("x"),N))),toporef(0))),_function("null"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Return true if the OBJECT is nil, false otherwise."),C(C(_variable("eq"),C(_variable("object"),C(N,N))),N))),toporef(0))),_function("consp"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Return true if the OBJECT is a cons, false otherwise."),C(C(_variable("typep"),C(_variable("object"),C(_class("cons"),N))),N))),toporef(0))),_function("caar"),ffun(dfun(),ffex(dfex(),C(_variable("cons"),N),I,C(extref(_function("%progn")),C(str("Return the `car' of the `car' of the CONS."),C(C(_variable("car"),C(C(_variable("car"),C(_variable("cons"),N)),N)),N))),toporef(0))),_function("cadr"),ffun(dfun(),ffex(dfex(),C(_variable("cons"),N),I,C(extref(_function("%progn")),C(str("Return the `car' of the `cdr' of the CONS."),C(C(_variable("car"),C(C(_variable("cdr"),C(_variable("cons"),N)),N)),N))),toporef(0))),_function("cdar"),ffun(dfun(),ffex(dfex(),C(_variable("cons"),N),I,C(extref(_function("%progn")),C(str("Return the `cdr' of the `car' of the CONS."),C(C(_variable("cdr"),C(C(_variable("car"),C(_variable("cons"),N)),N)),N))),toporef(0))),_function("cddr"),ffun(dfun(),ffex(dfex(),C(_variable("cons"),N),I,C(extref(_function("%progn")),C(str("Return the `cdr' of the `cdr' of the CONS."),C(C(_variable("cdr"),C(C(_variable("cdr"),C(_variable("cons"),N)),N)),N))),toporef(0))),_function("append"),ffun(dfun(),ffex(dfex(),C(_variable("list1"),C(_variable("list2"),N)),I,C(extref(_function("%progn")),C(str("Append two lists.  The first one must be proper and is copied.  The\nsecond one is not copied (and doesn't even have to be a list). It\nbecomes the `cdr' of the final cons of the first list, or is returned\ndirectly if the first list is empty."),C(C(_variable("%append"),C(_variable("list1"),C(_variable("list2"),N))),N))),toporef(0))),_function("nth"),ffun(dfun(),ffex(dfex(),C(_variable("n"),C(_variable("list"),N)),I,C(extref(_function("%progn")),C(str("Return element number N of LIST, where the `car' is element zero."),C(C(_variable("%nth"),C(_variable("n"),C(_variable("list"),N))),N))),toporef(0))),_function("nthcdr"),ffun(dfun(),ffex(dfex(),C(_variable("n"),C(_variable("list"),N)),I,C(extref(_function("%progn")),C(str("Returns the tail of LIST that would be obtained by calling `cdr' N\ntimes in succession."),C(C(_variable("%nthcdr"),C(_variable("n"),C(_variable("list"),N))),N))),toporef(0))),_function("mapcar"),ffun(dfun(),ffex(dfex(),C(_function("function"),C(_variable("list"),N)),I,C(extref(_function("%progn")),C(str("Create a new list by applying the FUNCTION to every element of the LIST."),C(C(_variable("if"),C(C(_variable("null"),C(_variable("list"),N)),C(N,C(C(_variable("cons"),C(C(_variable("function"),C(C(_variable("car"),C(_variable("list"),N)),N)),C(C(_variable("mapcar"),C(_function("function"),C(C(_variable("cdr"),C(_variable("list"),N)),N))),N))),N)))),N))),toporef(0))),_function("mapc"),ffun(dfun(),ffex(dfex(),C(_function("function"),C(_variable("list"),N)),I,C(extref(_function("%progn")),C(str("Apply the FUNCTION to every element of the LIST for effect.  Return the list."),C(C(_variable("unless"),C(C(_variable("null"),C(_variable("list"),N)),C(C(_variable("function"),C(C(_variable("car"),C(_variable("list"),N)),N)),C(C(_variable("mapc"),C(_function("function"),C(C(_variable("cdr"),C(_variable("list"),N)),N))),N)))),C(_variable("list"),N)))),toporef(0))),_function("mapcan"),ffun(dfun(),ffex(dfex(),C(_function("function"),C(_variable("list"),N)),I,C(extref(_function("%progn")),C(str("Apply the FUNCTION, which must return a list, to every element of the\nLIST, and append the results.  (Note: this currently uses `append',\nbut might be changed to use `nconc' in the future, like Common Lisp.)"),C(C(_variable("if"),C(C(_variable("null"),C(_variable("list"),N)),C(N,C(C(_variable("append"),C(C(_variable("function"),C(C(_variable("car"),C(_variable("list"),N)),N)),C(C(_variable("mapcan"),C(_function("function"),C(C(_variable("cdr"),C(_variable("list"),N)),N))),N))),N)))),N))),toporef(0))),_function("dolist"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(C(_variable("var"),C(_variable("list-form"),_variable("result-form?"))),_variable("body-forms")),I,C(extref(_function("%progn")),C(str("Cf. Common Lisp's DOLIST."),C(C(_variable("labels"),C(C(C(_variable("_dolist_"),C(C(_variable("list"),C(_function("body"),C(_function("result"),N))),C(C(_variable("if"),C(C(_variable("null"),C(_variable("list"),N)),C(C(_variable("result"),C(_variable("list"),N)),C(C(_variable("progn"),C(C(_variable("body"),C(C(_variable("car"),C(_variable("list"),N)),N)),C(C(_variable("_dolist_"),C(C(_variable("cdr"),C(_variable("list"),N)),C(_function("body"),C(_function("result"),N)))),N))),N)))),N))),N),C(C(_variable("list"),C(_function("_dolist_"),C(_variable("list-form"),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list"),C(_variable("var"),N)),C(_variable("body-forms"),N)))),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list"),C(_variable("var"),N)),C(_variable("result-form?"),N)))),N))))),N))),N))),toporef(0)))),_function("reduce"),ffun(dfun(),ffex(dfex(),C(_function("function"),C(_variable("list"),C(_keyword("initial-value"),C(_variable("initial-value"),N)))),I,C(extref(_function("%progn")),C(str("Use the binary FUNCTION to combine the elements of the LIST.  The\nINITIAL-VALUE is logically placed before the list."),C(C(_variable("if"),C(C(_variable("null"),C(_variable("list"),N)),C(_variable("initial-value"),C(C(_variable("reduce"),C(_function("function"),C(C(_variable("cdr"),C(_variable("list"),N)),C(_keyword("initial-value"),C(C(_variable("function"),C(_variable("initial-value"),C(C(_variable("car"),C(_variable("list"),N)),N))),N))))),N)))),N))),toporef(0))),_function("member"),ffun(dfun(),ffex(dfex(),C(_variable("item"),C(_variable("list"),_variable("keywords"))),I,C(extref(_function("%progn")),C(str("Search for ITEM in the LIST according to the TEST predicate\n(defaults to `eq').  Return the tail of the list starting with\nITEM if found, nil otherwise.  The KEY function is applied to\neach list element before comparison (defaults to `identity').\n$(fn (item list &key test key))"),C(C(_variable("let"),C(C(C(_function("test"),C(C(_variable("optional"),C(C(_variable("get?"),C(_variable("keywords"),C(_keyword("test"),N))),C(_function("eq"),N))),N)),C(C(_function("key"),C(C(_variable("optional"),C(C(_variable("get?"),C(_variable("keywords"),C(_keyword("key"),N))),C(_function("identity"),N))),N)),N)),C(C(_variable("loop-let"),C(_variable("-member-"),C(C(C(_variable("items"),C(_variable("list"),N)),N),C(C(_variable("if"),C(C(_variable("null"),C(_variable("items"),N)),C(N,C(C(_variable("if"),C(C(_variable("test"),C(_variable("item"),C(C(_variable("key"),C(C(_variable("car"),C(_variable("items"),N)),N)),N))),C(_variable("items"),C(C(_variable("-member-"),C(C(_variable("cdr"),C(_variable("items"),N)),N)),N)))),N)))),N)))),N))),N))),toporef(0))),_function("remove-if"),ffun(dfun(),ffex(dfex(),C(_function("test"),C(_variable("list"),N)),I,C(extref(_function("%progn")),C(str("Return a new list from which the elements that satisfy the TEST\nhave been removed."),C(C(_variable("if"),C(C(_variable("null"),C(_variable("list"),N)),C(N,C(C(_variable("if"),C(C(_variable("test"),C(C(_variable("car"),C(_variable("list"),N)),N)),C(C(_variable("remove-if"),C(_function("test"),C(C(_variable("cdr"),C(_variable("list"),N)),N))),C(C(_variable("cons"),C(C(_variable("car"),C(_variable("list"),N)),C(C(_variable("remove-if"),C(_function("test"),C(C(_variable("cdr"),C(_variable("list"),N)),N))),N))),N)))),N)))),N))),toporef(0))),_function("get?"),ffun(dfun(),ffex(dfex(),C(_variable("plist"),C(_variable("indicator"),N)),I,C(extref(_function("%progn")),C(str("Search for the INDICATOR keyword in the property list PLIST (a list\nof alternating keywords and values) and return the found value as an\noption."),C(C(_variable("if"),C(C(_variable("null"),C(_variable("plist"),N)),C(N,C(C(_variable("let"),C(C(C(C(_variable("i"),C(_variable("v"),_variable("plist"))),C(_variable("plist"),N)),N),C(C(_variable("if"),C(C(_variable("eq"),C(_variable("i"),C(_variable("indicator"),N))),C(C(_variable("some"),C(_variable("v"),N)),C(C(_variable("get?"),C(_variable("plist"),C(_variable("indicator"),N))),N)))),N))),N)))),N))),toporef(0))),_function("lispx::make-relational-operator"),ffun(dfun(),ffex(dfex(),C(_function("binary-operator"),N),I,C(extref(_function("%progn")),C(str("Utility to create an n-ary relational operator from a BINARY-OPERATOR."),C(C(_variable("labels"),C(C(C(_variable("operator"),C(toporef(4),toporef(5))),N),C(_function("operator"),N))),N))),toporef(0))),_function("="),toporef(6),_function("<"),toporef(7),_function(">"),toporef(8),_function("<="),toporef(9),_function(">="),toporef(10),_function("/="),ffun(dfun(),ffex(dfex(),C(_variable("arg"),_variable("args")),I,C(extref(_function("%progn")),C(str("Return true if no two ARGUMENTS are the same, false otherwise.\n$(fn arguments)"),C(C(_variable("if"),C(C(_variable("null"),C(_variable("args"),N)),C(T,C(C(_variable("if"),C(C(_variable("consp"),C(C(_variable("member"),C(_variable("arg"),C(_variable("args"),C(_keyword("test"),C(_function("="),N))))),N)),C(F,C(C(_variable("apply"),C(_function("/="),C(_variable("args"),N))),N)))),N)))),N))),toporef(0))),_function("lispx::make-thetic-operator"),ffun(dfun(),ffex(dfex(),C(_function("binary-operator"),C(_variable("initial-value"),N)),I,C(extref(_function("%progn")),C(str("Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE."),C(C(_variable("lambda"),C(_variable("args"),toporef(11))),N))),toporef(0))),_function("+"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(11)),fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%+")),_variable("initial-value"),num("0")))),_function("*"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(11)),fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%*")),_variable("initial-value"),num("1")))),_function("lispx::make-lytic-operator"),ffun(dfun(),ffex(dfex(),C(_function("binary-operator"),C(_variable("initial-value"),N)),I,C(extref(_function("%progn")),C(str("Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE."),C(C(_variable("lambda"),C(toporef(12),toporef(13))),N))),toporef(0))),_function("-"),ffun(dfun(),ffex(dfex(),toporef(12),I,C(extref(_function("%progn")),toporef(13)),fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%-")),_variable("initial-value"),num("0")))),_function("/"),ffun(dfun(),ffex(dfex(),toporef(12),I,C(extref(_function("%progn")),toporef(13)),fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%/")),_variable("initial-value"),num("1")))),_function("find-class"),ffun(dfun(),ffex(dfex(),C(_variable("name"),C(_variable("environment"),N)),I,C(extref(_function("%progn")),C(str("Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT."),C(C(_variable("eval"),C(C(_variable("class-symbol"),C(_variable("name"),N)),C(_variable("environment"),N))),N))),toporef(0))),_function("class-name"),ffun(dfun(),ffex(dfex(),C(_variable("class"),N),I,C(extref(_function("%progn")),C(str("Return the name symbol of the CLASS."),C(C(_variable("%class-name"),C(_variable("class"),N)),N))),toporef(0))),_function("subclassp"),ffun(dfun(),ffex(dfex(),C(_variable("class"),C(_variable("superclass"),N)),I,C(extref(_function("%progn")),C(str("Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.\nA class is considered a subclass of itself."),C(C(_variable("%subclassp"),C(_variable("class"),C(_variable("superclass"),N))),N))),toporef(0))),_function("defclass"),ffex(dfex(),C(_variable("name"),C(_variable("superclass?"),C(_variable("slot-specs"),_variable("properties")))),_variable("env"),C(extref(_function("%progn")),C(str("Define a new `standard-class' with the given NAME, optional\nSUPERCLASS?, and SLOT-SPECS.  The superclass defaults to\n`standard-object'.  The SLOT-SPECS and PROPERTIES are currently\nignored.\n$(syntax slot-spec symbol)\n$(syntax property (:documentation docstring))"),C(C(_variable("dolist"),C(C(_variable("slot-spec"),C(_variable("slot-specs"),N)),C(C(_variable("the"),C(_variable("symbol"),C(_variable("slot-spec"),N))),N))),C(C(_variable("let"),C(C(C(_variable("class-name"),C(C(_variable("class-symbol"),C(_variable("name"),N)),N)),C(C(_variable("superclass"),C(C(_variable("find-class"),C(C(_variable("optional"),C(_variable("superclass?"),C(C(_variable("quote"),C(_variable("standard-object"),N)),N))),C(_variable("env"),N))),N)),N)),C(C(_variable("if"),C(C(_variable("boundp"),C(_variable("class-name"),C(_variable("env"),N))),C(C(_variable("%reinitialize-standard-class"),C(C(_variable("eval"),C(_variable("class-name"),C(_variable("env"),N))),C(_variable("superclass"),N))),C(C(_variable("eval"),C(C(_variable("list"),C(_function("def"),C(_variable("class-name"),C(C(_variable("%make-standard-class"),C(_variable("name"),C(_variable("superclass"),N))),N)))),C(_variable("env"),N))),N)))),N))),N)))),toporef(0)),_function("defgeneric"),ffex(dfex(),C(_variable("name"),C(C(_variable("receiver"),_variable("parameters")),_variable("properties"))),_variable("env"),C(extref(_function("%progn")),C(str("Define a new generic function with the given NAME.  The RECEIVER,\nPARAMETERS, and PROPERTIES are currently ignored.\n$(syntax property (:documentation docstring))"),C(C(_variable("flet"),C(C(C(_variable("generic"),C(_variable("args"),toporef(14))),N),C(C(_variable("eval"),C(C(_variable("list"),C(_function("def"),C(C(_variable("function-symbol"),C(_variable("name"),N)),C(_function("generic"),N)))),C(_variable("env"),N))),N))),N))),toporef(0)),_function("defmethod"),ffex(dfex(),C(_variable("name"),C(C(C(_variable("receiver"),C(_variable("class-name"),N)),_variable("parameters")),_variable("forms"))),_variable("env"),C(extref(_function("%progn")),C(str("Add a new method to the generic function named by NAME specialized\nfor the class named by CLASS-NAME."),C(C(_variable("let"),C(C(C(_function("method"),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list*"),C(_variable("receiver"),C(_variable("parameters"),N))),C(_variable("forms"),N)))),C(_variable("env"),N))),N)),N),C(C(_variable("%add-method"),C(C(_variable("find-class"),C(_variable("class-name"),C(_variable("env"),N))),C(_variable("name"),C(_function("method"),N)))),N))),N))),toporef(0)),_function("make-instance"),ffun(dfun(),ffex(dfex(),C(_variable("class"),_variable("slot-inits")),I,C(extref(_function("%progn")),C(str("Create a new instance of CLASS (that must be a `standard-class').\nThe SLOT-INITS must be of even length, and alternately contain slot\nnames (symbols, typically keywords) and values."),C(C(_variable("apply"),C(_function("%make-instance"),C(C(_variable("cons"),C(_variable("class"),C(_variable("slot-inits"),N))),N))),N))),toporef(0))),_function("slot-value"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("slot-name"),N)),I,C(extref(_function("%progn")),C(str("Return the value of the slot named SLOT-NAME of the OBJECT."),C(C(_variable("%slot-value"),C(_variable("object"),C(_variable("slot-name"),N))),N))),toporef(0))),_function("set-slot-value"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("slot-name"),C(_variable("value"),N))),I,C(extref(_function("%progn")),C(str("Set the value of the slot named SLOT-NAME of the OBJECT to VALUE."),C(C(_variable("%set-slot-value"),C(_variable("object"),C(_variable("slot-name"),C(_variable("value"),N)))),N))),toporef(0))),_function("slot-bound-p"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("slot-name"),N)),I,C(extref(_function("%progn")),C(str("Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise."),C(C(_variable("%slot-bound-p"),C(_variable("object"),C(_variable("slot-name"),N))),N))),toporef(0))),_function("make-type-error"),ffun(dfun(),ffex(dfex(),C(_variable("datum"),C(_variable("expected-type"),N)),I,C(extref(_function("%progn")),C(str("Create a `type-error' with the given DATUM and EXPECTED-TYPE."),C(C(_variable("make-instance"),C(_class("type-error"),C(_keyword("datum"),C(_variable("datum"),C(_keyword("expected-type"),C(_variable("expected-type"),N)))))),N))),toporef(0))),_function("assert-type"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("class"),N)),I,C(extref(_function("%progn")),C(str("Signal a `type-error' if the OBJECT is not an instance of the CLASS."),C(C(_variable("if"),C(C(_variable("typep"),C(_variable("object"),C(_variable("class"),N))),C(_variable("object"),C(C(_variable("error"),C(C(_variable("make-type-error"),C(_variable("object"),C(C(_variable("class-name"),C(_variable("class"),N)),N))),N)),N)))),N))),toporef(0))),_function("the"),ffex(dfex(),C(_variable("class-name"),C(_variable("object"),N)),_variable("env"),C(extref(_function("%progn")),C(str("Shorthand for `assert-type'.  Signal a `type-error' if the OBJECT\nis not an instance of the class named by CLASS-NAME."),C(C(_variable("assert-type"),C(C(_variable("eval"),C(_variable("object"),C(_variable("env"),N))),C(C(_variable("find-class"),C(_variable("class-name"),C(_variable("env"),N))),N))),N))),toporef(0)),_function("length"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(14)),fenv(denv(toporef(0)),_variable("name"),_variable("length"),_variable("receiver"),_variable("sequence"),_variable("parameters"),N,_variable("properties"),C(C(_keyword("documentation"),C(str("Return the number of elements in a sequence."),N)),N),_variable("env"),toporef(0)))),_function("elt"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(14)),fenv(denv(toporef(0)),_variable("name"),_variable("elt"),_variable("receiver"),_variable("sequence"),_variable("parameters"),C(_variable("index"),N),_variable("properties"),C(C(_keyword("documentation"),C(str("Return the sequence element at the specified index."),N)),N),_variable("env"),toporef(0)))),_function("subseq"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(14)),fenv(denv(toporef(0)),_variable("name"),_variable("subseq"),_variable("receiver"),_variable("sequence"),_variable("parameters"),C(_variable("start"),_variable("end?")),_variable("properties"),C(C(_keyword("documentation"),C(str("Create a sequence that is a copy of the subsequence\nof the SEQUENCE bounded by START and optional END?.  If END?  is not\nsupplied or void, the subsequence stretches until the end of the\nlist."),N)),N),_variable("env"),toporef(0)))),_function("some"),ffun(dfun(),ffex(dfex(),C(_variable("value"),N),I,C(extref(_function("%progn")),C(str("Create a one-element list from the VALUE."),C(C(_variable("list"),C(_variable("value"),N)),N))),toporef(0))),_function("if-option"),ffex(dfex(),C(C(_variable("name"),C(_variable("option?"),N)),C(_variable("then"),C(_variable("else"),N))),_variable("env"),C(extref(_function("%progn")),C(str("Destructure the OPTION?.  If it's non-nil, evaluate the THEN form\nwith the NAME bound to the contents of the option.  If it's nil,\nevaluate the ELSE form."),C(C(_variable("let"),C(C(C(_variable("o?"),C(C(_variable("eval"),C(_variable("option?"),C(_variable("env"),N))),N)),N),C(C(_variable("if"),C(C(_variable("null"),C(_variable("o?"),N)),C(C(_variable("eval"),C(_variable("else"),C(_variable("env"),N))),C(C(_variable("eval"),C(C(_variable("list"),C(C(_variable("list"),C(_function("vau"),C(C(_variable("list"),C(_variable("name"),N)),C(I,C(_variable("then"),N))))),C(C(_variable("car"),C(_variable("o?"),N)),N))),C(_variable("env"),N))),N)))),N))),N))),toporef(0)),_function("when-option"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(C(_variable("name"),C(_variable("option?"),N)),_variable("forms")),I,C(extref(_function("%progn")),C(str("Destructure the OPTION?.  If it's non-nil, evaluate the FORMS with\nthe NAME bound to the contents of the option.  If it's nil, return nil."),C(C(_variable("list"),C(_function("if-option"),C(C(_variable("list"),C(_variable("name"),C(_variable("option?"),N))),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(N,N))))),N))),toporef(0)))),_function("unless-option"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("option?"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Destructure the OPTION?.  If it's nil, evaluate the FORMS.  If it's\nnon-nil, return nil."),C(C(_variable("list"),C(_function("if-option"),C(C(_variable("list"),C(I,C(_variable("option?"),N))),C(N,C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),N))))),N))),toporef(0)))),_function("optional"),ffex(dfex(),C(_variable("option?"),_variable("default?")),_variable("env"),C(extref(_function("%progn")),C(str("Return the contents of the OPTION?, or the DEFAULT? if the option\nis nil.  The default itself defaults to void.  The DEFAULT? is\nevaluated lazily, only when the OPTION? is nil."),C(C(_variable("if-option"),C(C(_variable("value"),C(C(_variable("eval"),C(_variable("option?"),C(_variable("env"),N))),N)),C(_variable("value"),C(C(_variable("if-option"),C(C(_variable("default"),C(_variable("default?"),N)),C(C(_variable("eval"),C(_variable("default"),C(_variable("env"),N))),C(V,N)))),N)))),N))),toporef(0)),_function("optionals"),ffex(dfex(),C(_variable("list"),_variable("defaults")),_variable("env"),C(extref(_function("%progn")),C(str("Similar to `optional', but provides DEFAULTS for any number of\nelements of LIST.  This is useful for implementing functions that take\nmultiple optional arguments.  Each default is evaluated lazily, only\nwhen needed."),C(C(_variable("loop-let"),C(_variable("-optionals-"),C(C(C(_variable("list"),C(C(_variable("eval"),C(_variable("list"),C(_variable("env"),N))),N)),C(C(_variable("defaults"),C(_variable("defaults"),N)),N)),C(C(_variable("if"),C(C(_variable("null"),C(_variable("list"),N)),C(C(_variable("if"),C(C(_variable("null"),C(_variable("defaults"),N)),C(N,C(C(_variable("cons"),C(C(_variable("eval"),C(C(_variable("car"),C(_variable("defaults"),N)),C(_variable("env"),N))),C(C(_variable("-optionals-"),C(N,C(C(_variable("cdr"),C(_variable("defaults"),N)),N))),N))),N)))),C(C(_variable("if"),C(C(_variable("null"),C(_variable("defaults"),N)),C(C(_variable("cons"),C(C(_variable("car"),C(_variable("list"),N)),C(C(_variable("-optionals-"),C(C(_variable("cdr"),C(_variable("list"),N)),C(N,N))),N))),C(C(_variable("cons"),C(C(_variable("car"),C(_variable("list"),N)),C(C(_variable("-optionals-"),C(C(_variable("cdr"),C(_variable("list"),N)),C(C(_variable("cdr"),C(_variable("defaults"),N)),N))),N))),N)))),N)))),N)))),N))),toporef(0)),_function("get-option"),ffun(dfun(),ffex(dfex(),C(_variable("option?"),N),I,C(extref(_function("%progn")),C(str("Returns the contents of the OPTION? or signals an error if it is nil."),C(C(_variable("optional"),C(_variable("option?"),C(C(_variable("simple-error"),C(str("Option is nil"),N)),N))),N))),toporef(0))),_function("defdynamic"),ffex(dfex(),C(_variable("name"),_variable("value-and-docstring?")),_variable("env"),C(extref(_function("%progn")),C(str("Define a new or update an existing dynamic variable with the given\nNAME and optional default VALUE. The optional DOCSTRING is currently\nignored.\n$(fn (name &optional value docstring))"),C(C(_variable("def"),C(_variable("value"),C(C(_variable("eval"),C(C(_variable("optional"),C(_variable("value-and-docstring?"),N)),C(_variable("env"),N))),N))),C(C(_variable("if"),C(C(_variable("boundp"),C(_variable("name"),C(_variable("env"),N))),C(C(_variable("set-dynamic"),C(C(_variable("eval"),C(_variable("name"),C(_variable("env"),N))),C(_variable("value"),N))),C(C(_variable("eval"),C(C(_variable("list"),C(_function("def"),C(_variable("name"),C(C(_variable("make-instance"),C(_class("dynamic"),C(_keyword("value"),C(_variable("value"),N)))),N)))),C(_variable("env"),N))),N)))),N)))),toporef(0)),_function("dynamic"),ffun(dfun(),ffex(dfex(),C(_variable("dynamic-variable"),N),I,C(extref(_function("%progn")),C(str("Return the current value of the DYNAMIC-VARIABLE."),C(C(_variable("slot-value"),C(_variable("dynamic-variable"),C(C(_variable("quote"),C(_variable("value"),N)),N))),N))),toporef(0))),_function("set-dynamic"),ffun(dfun(),ffex(dfex(),C(_variable("dynamic-variable"),C(_variable("value"),N)),I,C(extref(_function("%progn")),C(str("Set the current value of the DYNAMIC-VARIABLE."),C(C(_variable("set-slot-value"),C(_variable("dynamic-variable"),C(C(_variable("quote"),C(_variable("value"),N)),C(_variable("value"),N)))),N))),toporef(0))),_function("dynamic-let"),ffex(dfex(),C(_variable("bindings"),_variable("forms")),_variable("env"),C(extref(_function("%progn")),C(str("Evaluate the FORMS with the dynamic variables specified by BINDINGS\ntemporarily bound to new values.  Bindings are established parallely\nas per `let'.\n$(syntax binding (dynamic-variable value))"),C(C(_variable("let"),C(C(C(_variable("dynamics"),C(C(_variable("mapcar"),C(C(_variable("lambda"),C(C(C(_variable("name"),C(I,N)),N),C(C(_variable("eval"),C(_variable("name"),C(_variable("env"),N))),N))),C(_variable("bindings"),N))),N)),C(C(_variable("values"),C(C(_variable("mapcar"),C(C(_variable("lambda"),C(C(C(I,C(_variable("value"),N)),N),C(C(_variable("eval"),C(_variable("value"),C(_variable("env"),N))),N))),C(_variable("bindings"),N))),N)),C(C(_variable("thunk"),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("lambda"),C(N,C(_variable("forms"),N)))),C(_variable("env"),N))),N)),N))),C(C(_variable("%progv"),C(_variable("dynamics"),C(_variable("values"),C(_variable("thunk"),N)))),N))),N))),toporef(0)),_function("dynamic-let*"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("bindings"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Evaluate the FORMS with the dynamic variables specified by BINDINGS\ntemporarily bound to new values.  Bindings are established serially as\nper `let*'."),C(C(_variable("if"),C(C(_variable("null"),C(_variable("bindings"),N)),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(C(_variable("list"),C(_function("dynamic-let"),C(C(_variable("list"),C(C(_variable("car"),C(_variable("bindings"),N)),N)),C(C(_variable("list*"),C(_function("dynamic-let*"),C(C(_variable("cdr"),C(_variable("bindings"),N)),C(_variable("forms"),N)))),N)))),N)))),N))),toporef(0)))),_function("progv"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("dynamic-variables"),C(_variable("values"),_variable("forms"))),I,C(extref(_function("%progn")),C(str("Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily\nbound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have\nthe same length."),C(C(_variable("list"),C(_function("%progv"),C(_variable("dynamic-variables"),C(_variable("values"),C(C(_variable("list*"),C(_function("lambda"),C(N,C(_variable("forms"),N)))),N))))),N))),toporef(0)))),_function("push-prompt"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("prompt"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Push the PROMPT and evaluate the FORMS inside the prompt.  This\ndelimits the continuation."),C(C(_variable("list"),C(_function("%push-prompt"),C(_variable("prompt"),C(C(_variable("list*"),C(_function("lambda"),C(N,C(_variable("forms"),N)))),N)))),N))),toporef(0)))),_function("take-subcont"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("prompt"),C(_variable("name"),_variable("forms"))),I,C(extref(_function("%progn")),C(str("Abort outwards to the PROMPT.  When the prompt is reached, evaluate\nthe FORMS with NAME bound to the captured continuation (which does not\ninclude the prompt)."),C(C(_variable("list"),C(_function("%take-subcont"),C(_variable("prompt"),C(C(_variable("list*"),C(_function("lambda"),C(C(_variable("list"),C(_variable("name"),N)),C(_variable("forms"),N)))),N)))),N))),toporef(0)))),_function("push-delim-subcont"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("prompt"),C(_variable("continuation"),_variable("forms"))),I,C(extref(_function("%progn")),C(str("Push the PROMPT and compose the previously captured CONTINUATION\ninside it.  The FORMS are then evaluated inside the new continuation."),C(C(_variable("list"),C(_function("%push-delim-subcont"),C(_variable("prompt"),C(_variable("continuation"),C(C(_variable("list*"),C(_function("lambda"),C(N,C(_variable("forms"),N)))),N))))),N))),toporef(0)))),_function("push-subcont-barrier"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),_variable("forms"),I,C(extref(_function("%progn")),C(str("Push a continuation barrier that prevents the FORMS from capturing\nany continuations to the outside."),C(C(_variable("list"),C(_function("%push-subcont-barrier"),C(C(_variable("list*"),C(_function("lambda"),C(N,C(_variable("forms"),N)))),N))),N))),toporef(0)))),_variable("+default-prompt+"),_variable("default-prompt"),_function("coroutine"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),_variable("forms"),I,C(extref(_function("%progn")),C(str("Evaluate the FORMS in a context in which `yield' can be used to pause\nexecution."),C(C(_variable("list*"),C(_function("push-prompt"),C(C(_variable("quote"),C(_variable("+default-prompt+"),N)),C(_variable("forms"),N)))),N))),toporef(0)))),_function("yield"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Pause the current coroutine.  In the place where the enclosing\n`coroutine' (or `resume') was called, evaluate the FORMS with NAME\nbound to the paused coroutine.  `resume' can later be used to restart\nexecution inside the coroutine."),C(C(_variable("list*"),C(_function("take-subcont"),C(C(_variable("quote"),C(_variable("+default-prompt+"),N)),C(_variable("name"),C(_variable("forms"),N))))),N))),toporef(0)))),_function("resume"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("k"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Resume the paused coroutine K and evaluate FORMS in the place where\n`yield' was called in the coroutine."),C(C(_variable("list*"),C(_function("push-delim-subcont"),C(C(_variable("quote"),C(_variable("+default-prompt+"),N)),C(_variable("k"),C(_variable("forms"),N))))),N))),toporef(0)))),_class("handler-frame"),fcls(dcls(_variable("handler-frame"),extref(_class("standard-object")))),_class("condition-handler"),fcls(dcls(_variable("condition-handler"),extref(_class("standard-object"))),_variable("lispx::handler-applicable-p"),ffun(dfun(),ffex(dfex(),C(_variable("handler"),C(_variable("condition"),C(N,N))),I,C(extref(_function("%progn")),C(str("A condition handler is applicable if the condition is an instance\nof its condition class."),C(C(_variable("typep"),C(_variable("condition"),C(C(_variable("slot-value"),C(_variable("handler"),C(C(_variable("quote"),C(_variable("condition-class"),N)),N))),N))),N))),toporef(0)))),_class("restart-handler"),fcls(dcls(_variable("restart-handler"),extref(_class("standard-object"))),_variable("lispx::handler-applicable-p"),ffun(dfun(),ffex(dfex(),C(_variable("handler"),C(_variable("restart-name"),C(_variable("condition?"),N))),I,C(extref(_function("%progn")),C(str("A restart handler is applicable to a restart name and optional condition..."),C(C(_variable("and"),C(C(_variable("eq"),C(_variable("restart-name"),C(C(_variable("slot-value"),C(_variable("handler"),C(C(_variable("quote"),C(_variable("restart-name"),N)),N))),N))),C(C(_variable("lispx::restart-handler-applicable-to-condition-p"),C(_variable("handler"),C(_variable("condition?"),N))),N))),N))),toporef(0)))),_variable("*condition-handler-frame?*"),toporef(17),_variable("*restart-handler-frame?*"),toporef(18),_function("lispx::make-handler-bind-operator"),ffun(dfun(),ffex(dfex(),C(_function("handler-spec-parser"),C(_variable("handler-frame-dynamic"),N)),I,C(extref(_function("%progn")),C(str("Metaprogramming utility to create `handler-bind' and `restart-bind'.\nIt is parameterized by a function that parses the handler\nspecifications of the `handler-bind' and `restart-bind' forms and\nproduces handlers from them, as well as the dynamic variable holding\nthe handler chain (the variable itself as a first class object, not\nits value, so it can be used with `progv')."),C(C(_variable("vau"),C(toporef(15),C(_variable("env"),toporef(16)))),N))),toporef(0))),_function("handler-bind"),toporef(21),_function("restart-bind"),toporef(22),_function("lispx::make-handler-case-operator"),ffun(dfun(),ffex(dfex(),C(_function("handler-bind-operator"),N),I,C(extref(_function("%progn")),C(str("Metaprogramming utility to create `handler-case' / `restart-case'\nfrom `handler-bind' / `restart-bind'.  The `*-case' operators unwind\nthe stack before a handler is called.  We do this with an outer exit\nand an inner trampoline, both wrapped around the original `*-bind'\noperator.  The original form's handler functions are replaced with\nfunctions that use the trampoline.  If a condition is signalled / a\nrestart is invoked during the evaluation of the body forms, they\nunwind the stack by jumping into the trampoline, and call the original\nhandler function there.  If no condition is signalled / no restart is\ninvoked, we return from the outer exit, ignoring the trampoline."),C(C(_variable("vau"),C(toporef(19),C(_variable("env"),toporef(20)))),N))),toporef(0))),_function("handler-case"),ffex(dfex(),toporef(19),_variable("env"),C(extref(_function("%progn")),toporef(20)),fenv(denv(toporef(0)),_function("handler-bind-operator"),toporef(21))),_function("restart-case"),ffex(dfex(),toporef(19),_variable("env"),C(extref(_function("%progn")),toporef(20)),fenv(denv(toporef(0)),_function("handler-bind-operator"),toporef(22))),_function("_signal_"),toporef(25),_function("lispx::call-condition-handler"),ffun(dfun(),ffex(dfex(),C(_variable("handler"),C(_variable("handler-frame"),C(_variable("condition"),N))),I,C(extref(_function("%progn")),C(str("Call a condition HANDLER's handler function with the given\nCONDITION.  During the call, the condition handler chain gets swapped\nto that chain that was active at the time the handler was established.\nThis is the so-called \"condition firewall\".  The chain gets passed\nin as the value of HANDLER-FRAME."),C(C(_variable("dynamic-let"),C(C(C(_variable("*condition-handler-frame?*"),C(C(_variable("slot-value"),C(_variable("handler-frame"),C(C(_variable("quote"),C(_variable("parent-frame?"),N)),N))),N)),N),C(C(_variable("lispx::apply-handler-function"),C(_variable("handler"),C(C(_variable("list"),C(_variable("condition"),N)),N))),N))),N))),toporef(0))),_function("lispx::apply-handler-function"),ffun(dfun(),ffex(dfex(),C(_variable("handler"),C(_variable("arguments"),N)),I,C(extref(_function("%progn")),C(str("Utility to call a condition or restart HANDLER's handler function\nwith a list of ARGUMENTS."),C(C(_variable("apply"),C(C(_variable("slot-value"),C(_variable("handler"),C(C(_variable("quote"),C(_variable("handler-function"),N)),N))),C(_variable("arguments"),N))),N))),toporef(0))),_function("_error_"),toporef(26),_function("lispx::make-signal-with-restarts-operator"),ffun(dfun(),ffex(dfex(),C(_function("signal-operator"),N),I,C(extref(_function("%progn")),C(str("Metaprogramming utility to create the `signal' / `error' operators\nthat take restart handler-specs from the `_signal_' / `_error_' ones\nthat don't."),C(C(_variable("vau"),C(toporef(23),C(_variable("env"),toporef(24)))),N))),toporef(0))),_function("signal"),ffex(dfex(),toporef(23),_variable("env"),C(extref(_function("%progn")),toporef(24)),fenv(denv(toporef(0)),_function("signal-operator"),toporef(25))),_function("error"),ffex(dfex(),toporef(23),_variable("env"),C(extref(_function("%progn")),toporef(24)),fenv(denv(toporef(0)),_function("signal-operator"),toporef(26))),_function("invoke-restart"),ffun(dfun(),ffex(dfex(),C(_variable("restart-designator"),_variable("arguments")),I,C(extref(_function("%progn")),C(str("Invoke the restart designated by RESTART-DESIGNATOR, which can be a\nsymbol or a `restart-handler', with the given ARGUMENTS.  Signal an\nerror if the restart is not found."),C(C(_variable("lispx::invoke-restart-with-arguments-producing-function"),C(_variable("restart-designator"),C(C(_variable("lambda"),C(C(I,N),C(_variable("arguments"),N))),N))),N))),toporef(0))),_function("invoke-restart-interactively"),ffun(dfun(),ffex(dfex(),C(_variable("restart-designator"),N),I,C(extref(_function("%progn")),C(str("Invoke the restart designated by RESTART-DESIGNATOR, which can be a\nsymbol or a `restart-handler', by prompting the user for arguments via\nthe restart's optional interactive function.  Signal an error if the\nrestart is not found."),C(C(_variable("lispx::invoke-restart-with-arguments-producing-function"),C(_variable("restart-designator"),C(C(_variable("lambda"),C(C(_variable("restart-handler"),N),C(C(_variable("when-option"),C(C(_function("i-f"),C(C(_variable("slot-value"),C(_variable("restart-handler"),C(C(_variable("quote"),C(_variable("interactive-function?"),N)),N))),N)),C(C(_variable("i-f"),N),N))),N))),N))),N))),toporef(0))),_function("lispx::invoke-restart-with-arguments-producing-function"),ffun(dfun(),ffex(dfex(),C(_variable("restart-designator"),C(_function("function"),N)),I,C(extref(_function("%progn")),C(str("Utility to invoke the restart designated by RESTART-DESIGNATOR,\nwhich can be a symbol or a `restart-handler', with an arguments list\nproduced by FUNCTION (which receives a `restart-handler' as argument)."),C(C(_variable("etypecase"),C(_variable("restart-designator"),C(C(_variable("symbol"),C(C(_variable("if-option"),C(C(_variable("restart-handler"),C(C(_variable("find-restart?"),C(_variable("restart-designator"),N)),N)),C(C(_variable("lispx::apply-handler-function"),C(_variable("restart-handler"),C(C(_variable("function"),C(_variable("restart-handler"),N)),N))),C(C(_variable("error"),C(C(_variable("make-restart-error"),C(_variable("restart-designator"),N)),N)),N)))),N)),C(C(_variable("restart-handler"),C(C(_variable("lispx::apply-handler-function"),C(_variable("restart-designator"),C(C(_variable("function"),C(_variable("restart-designator"),N)),N))),N)),N)))),N))),toporef(0))),_function("lispx::find-handler?"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("handler-frame?"),C(_variable("payload?"),N))),I,C(extref(_function("%progn")),C(str("Utility to find both condition handlers and restart handlers.\nThe OBJECT can be either a condition or a restart name.  The\nHANDLER-FRAME? is the handler frame where the search should start\n(always the innermost handler frame at the start of the search).\n\nReturn an option of the found handler and the frame establishing it as\na two-element list.  The frame is needed so that we can access its\nparent in the implementation of the condition firewall (see\n`lispx::call-condition-handler').\n\nThe PAYLOAD? parameter can be used to pass in an optional condition if\nwe are looking for a restart handler (see `find-restart?').  If we are\nlooking for a condition handler, it is always nil."),C(C(_variable("when-option"),C(C(_variable("handler-frame"),C(_variable("handler-frame?"),N)),C(C(_variable("block"),C(_variable("found"),C(C(_variable("dolist"),C(C(_variable("handler"),C(C(_variable("slot-value"),C(_variable("handler-frame"),C(C(_variable("quote"),C(_variable("handlers"),N)),N))),N)),C(C(_variable("when"),C(C(_variable("lispx::handler-applicable-p"),C(_variable("handler"),C(_variable("object"),C(_variable("payload?"),N)))),C(C(_variable("return-from"),C(_variable("found"),C(C(_variable("some"),C(C(_variable("list"),C(_variable("handler"),C(_variable("handler-frame"),N))),N)),N))),N))),N))),C(C(_variable("lispx::find-handler?"),C(_variable("object"),C(C(_variable("slot-value"),C(_variable("handler-frame"),C(C(_variable("quote"),C(_variable("parent-frame?"),N)),N))),C(_variable("payload?"),N)))),N)))),N))),N))),toporef(0))),_function("find-restart?"),ffun(dfun(),ffex(dfex(),C(_variable("name"),_variable("condition?")),I,C(extref(_function("%progn")),C(str("Find a restart handler by NAME, optionally limited to restarts\nassociated with a particular CONDITION?."),C(C(_variable("when-option"),C(C(C(_variable("handler"),C(I,N)),C(C(_variable("lispx::find-handler?"),C(_variable("name"),C(C(_variable("dynamic"),C(_variable("*restart-handler-frame?*"),N)),C(_variable("condition?"),N)))),N)),C(C(_variable("some"),C(_variable("handler"),N)),N))),N))),toporef(0))),_function("lispx::handler-applicable-p"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(14)),fenv(denv(toporef(0)),_variable("name"),_variable("lispx::handler-applicable-p"),_variable("receiver"),_variable("handler"),_variable("parameters"),C(_variable("object"),C(_variable("payload?"),N)),_variable("properties"),C(C(_keyword("documentation"),C(str("Return true if a condition or restart HANDLER is\napplicable, false otherwise.  The OBJECT can be a condition or a\nrestart name.  The PAYLOAD? is only used for restart handlers, and\nalways nil for condition handlers."),N)),N),_variable("env"),toporef(0)))),_function("lispx::restart-handler-applicable-to-condition-p"),ffun(dfun(),ffex(dfex(),C(_variable("handler"),C(_variable("condition?"),N)),I,C(extref(_function("%progn")),C(str("A restart handler is applicable to an optional condition..."),C(C(_variable("if-option"),C(C(_variable("condition"),C(_variable("condition?"),N)),C(C(_variable("let"),C(C(C(_variable("a-cs"),C(C(_variable("slot-value"),C(_variable("handler"),C(C(_variable("quote"),C(_variable("associated-conditions"),N)),N))),N)),N),C(C(_variable("if"),C(C(_variable("null"),C(_variable("a-cs"),N)),C(T,C(C(_variable("consp"),C(C(_variable("member"),C(_variable("condition"),C(_variable("a-cs"),N))),N)),N)))),N))),C(T,N)))),N))),toporef(0))),_function("compute-restarts"),ffun(dfun(),ffex(dfex(),_variable("condition?"),I,C(extref(_function("%progn")),C(str("Return the list of currently active restarts, with most recently\nestablished ones first, optionally limited to those that are\nexplicitly associated with the supplied CONDITION? or not associated\nwith any condition."),C(C(_variable("loop-let"),C(_variable("-compute-restarts-"),C(C(C(_variable("restarts"),C(C(_variable("quote"),C(N,N)),N)),C(C(_variable("handler-frame?"),C(C(_variable("dynamic"),C(_variable("*restart-handler-frame?*"),N)),N)),N)),C(C(_variable("if-option"),C(C(_variable("handler-frame"),C(_variable("handler-frame?"),N)),C(C(_variable("-compute-restarts-"),C(C(_variable("append"),C(_variable("restarts"),C(C(_variable("remove-if"),C(C(_variable("lambda"),C(C(_variable("restart"),N),C(C(_variable("not"),C(C(_variable("lispx::restart-handler-applicable-to-condition-p"),C(_variable("restart"),C(_variable("condition?"),N))),N)),N))),C(C(_variable("slot-value"),C(_variable("handler-frame"),C(C(_variable("quote"),C(_variable("handlers"),N)),N))),N))),N))),C(C(_variable("slot-value"),C(_variable("handler-frame"),C(C(_variable("quote"),C(_variable("parent-frame?"),N)),N))),N))),C(_variable("restarts"),N)))),N)))),N))),toporef(0))),_class("restart-error"),fcls(dcls(_variable("restart-error"),extref(_class("error")))),_function("make-restart-error"),ffun(dfun(),ffex(dfex(),C(_variable("restart-name"),N),I,C(extref(_function("%progn")),C(str("Create a new `restart-error' for the given RESTART-NAME."),C(C(_variable("make-instance"),C(_class("restart-error"),C(_keyword("restart-name"),C(_variable("restart-name"),N)))),N))),toporef(0))),_class("simple-error"),fcls(dcls(_variable("simple-error"),extref(_class("error")))),_function("make-simple-error"),ffun(dfun(),ffex(dfex(),C(_variable("message"),N),I,C(extref(_function("%progn")),C(str("Create a new simple error with a MESSAGE."),C(C(_variable("make-instance"),C(_class("simple-error"),C(_keyword("message"),C(_variable("message"),N)))),N))),toporef(0))),_function("simple-error"),ffun(dfun(),ffex(dfex(),C(_variable("message"),N),I,C(extref(_function("%progn")),C(str("Signal a simple error with a MESSAGE."),C(C(_variable("error"),C(C(_variable("make-simple-error"),C(_variable("message"),N)),N)),N))),toporef(0))),_function("make-string-input-stream"),ffun(dfun(),ffex(dfex(),C(_variable("string"),N),I,C(extref(_function("%progn")),C(str("Create a string input stream that reads from STRING."),C(C(_variable("%make-string-input-stream"),C(_variable("string"),N)),N))),toporef(0))),_function("with-standard-input-from-string"),ffex(dfex(),C(_variable("string"),_variable("forms")),_variable("env"),C(extref(_function("%progn")),C(str("Evaluate FORMS with `*standard-input*' coming from STRING."),C(C(_variable("let"),C(C(C(_variable("s"),C(C(_variable("eval"),C(_variable("string"),C(_variable("env"),N))),N)),N),C(C(_variable("dynamic-let"),C(C(C(_variable("*standard-input*"),C(C(_variable("make-string-input-stream"),C(_variable("s"),N)),N)),N),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(_variable("env"),N))),N))),N))),N))),toporef(0)),_function("make-string-output-stream"),ffun(dfun(),ffex(dfex(),N,I,C(extref(_function("%progn")),C(str("Construct an empty string output stream."),C(C(_variable("%make-string-output-stream"),N),N))),toporef(0))),_function("get-output-stream-string"),ffun(dfun(),ffex(dfex(),C(_variable("stream"),N),I,C(extref(_function("%progn")),C(str("Return the contents of the string output STREAM."),C(C(_variable("%get-output-stream-string"),C(_variable("stream"),N)),N))),toporef(0))),_function("with-standard-output-to-string"),ffex(dfex(),_variable("forms"),_variable("env"),C(extref(_function("%progn")),C(str("Evaluate FORMS with `*standard-output*' being collected in a string."),C(C(_variable("dynamic-let"),C(C(C(_variable("*standard-output*"),C(C(_variable("make-string-output-stream"),N),N)),N),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(_variable("env"),N))),C(C(_variable("get-output-stream-string"),C(C(_variable("dynamic"),C(_variable("*standard-output*"),N)),N)),N)))),N))),toporef(0)),_function("fresh-line"),ffun(dfun(),ffex(dfex(),_variable("stream?"),I,C(extref(_function("%progn")),C(str("Ensure that the following output appears on a new line by itself.\nThe optional STREAM? defaults to `*standard-output*'."),C(C(_variable("%fresh-line"),C(C(_variable("optional"),C(_variable("stream?"),C(C(_variable("dynamic"),C(_variable("*standard-output*"),N)),N))),N)),N))),toporef(0))),_function("force-output"),ffun(dfun(),ffex(dfex(),_variable("stream?"),I,C(extref(_function("%progn")),C(str("Initiate the emptying of any internal buffers but don't wait for them to finish.\nThe optional STREAM? defaults to `*standard-output*'."),C(C(_variable("%force-output"),C(C(_variable("optional"),C(_variable("stream?"),C(C(_variable("dynamic"),C(_variable("*standard-output*"),N)),N))),N)),N))),toporef(0))),_function("read"),ffun(dfun(),ffex(dfex(),_variable("arguments"),I,C(extref(_function("%progn")),C(str("Reads an object from the STREAM (which defaults to\n`*standard-input*').  If EOF is reached, and `eof-error-p' is true\n(the default), `end-of-file' is signalled. If it is false, `eof-value'\nis returned (it defaults to void).\n$(fn (&optional stream eof-error-p eof-value))"),C(C(_variable("apply"),C(_function("stream-read"),C(C(_variable("optionals"),C(_variable("arguments"),C(C(_variable("dynamic"),C(_variable("*standard-input*"),N)),C(T,C(V,N))))),N))),N))),toporef(0))),_function("stream-read"),ffun(dfun(),ffex(dfex(),_variable("args"),I,C(extref(_function("%progn")),toporef(14)),fenv(denv(toporef(0)),_variable("name"),_variable("stream-read"),_variable("receiver"),_variable("stream"),_variable("parameters"),C(_variable("eof-error-p"),C(_variable("eof-value"),N)),_variable("properties"),C(C(_keyword("documentation"),C(str("Underlying, generic implementation of `read'.\nEvery stream class can provide a specialized method."),N)),N),_variable("env"),toporef(0)))),_function("write"),ffun(dfun(),ffex(dfex(),C(_variable("object"),_variable("keywords")),I,C(extref(_function("%progn")),C(str("Write OBJECT to STREAM (defaults to `*standard-output*').  Main\nprinter entry point.\n$(fn (object &key stream))"),C(C(_variable("%write"),C(_variable("object"),C(C(_variable("optional"),C(C(_variable("get?"),C(_variable("keywords"),C(_keyword("stream"),N))),C(C(_variable("dynamic"),C(_variable("*standard-output*"),N)),N))),N))),N))),toporef(0))),_function("write-to-string"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Create a string consisting of the printed representation of object."),C(C(_variable("with-standard-output-to-string"),C(C(_variable("write"),C(_variable("object"),N)),N)),N))),toporef(0))),_function("print1"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Print OBJECT readably on the current line.  May or may not force\nthe output."),C(C(_variable("dynamic-let"),C(C(C(_variable("*print-escape*"),C(T,N)),N),C(C(_variable("write"),C(_variable("object"),N)),N))),N))),toporef(0))),_function("uprint1"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Print OBJECT unreadably on the current line.  May or may not force\nthe output."),C(C(_variable("dynamic-let"),C(C(C(_variable("*print-escape*"),C(F,N)),N),C(C(_variable("write"),C(_variable("object"),N)),N))),N))),toporef(0))),_function("print"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Print OBJECT readably on a fresh line and force the output."),C(C(_variable("fresh-line"),N),C(C(_variable("prog1"),C(C(_variable("print1"),C(_variable("object"),N)),C(C(_variable("force-output"),N),N))),N)))),toporef(0))),_function("uprint"),ffun(dfun(),ffex(dfex(),C(_variable("object"),N),I,C(extref(_function("%progn")),C(str("Print OBJECT unreadably on a fresh line and force the output."),C(C(_variable("fresh-line"),N),C(C(_variable("prog1"),C(C(_variable("uprint1"),C(_variable("object"),N)),C(C(_variable("force-output"),N),N))),N)))),toporef(0))),_function("js-eq"),ffun(dfun(),ffex(dfex(),C(_variable("a"),C(_variable("b"),N)),I,C(extref(_function("%progn")),C(str("Return true if the values A and B are equal per JavaScript's strict\nequality, false otherwise."),C(C(_variable("eq"),C(_variable("a"),C(_variable("b"),N))),N))),toporef(0))),_function("apply-js-function"),ffun(dfun(),ffex(dfex(),C(_variable("js-function"),C(_variable("arguments"),N)),I,C(extref(_function("%progn")),C(str("Call JS-FUNCTION with a list of ARGUMENTS."),C(C(_variable("apply"),C(C(_variable("to-lisp-function"),C(_variable("js-function"),N)),C(_variable("arguments"),N))),N))),toporef(0))),_function("call-js-function"),ffun(dfun(),ffex(dfex(),C(_variable("js-function"),_variable("arguments")),I,C(extref(_function("%progn")),C(str("Call JS-FUNCTION with the rest ARGUMENTS."),C(C(_variable("apply-js-function"),C(_variable("js-function"),C(_variable("arguments"),N))),N))),toporef(0))),_function("js-lambda"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("parameter-tree"),_variable("forms")),I,C(extref(_function("%progn")),C(str("Construct a lambda with the given PARAMETER-TREE and body FORMS\nthat's callable from JS."),C(C(_variable("list"),C(_function("to-js-function"),C(C(_variable("list"),C(_function("lambda"),C(_variable("parameter-tree"),C(C(_variable("list"),C(_function("push-subcont-barrier"),C(C(_variable("list*"),C(_function("push-prompt"),C(C(_variable("quote"),C(_variable("+root-prompt+"),N)),C(_variable("forms"),N)))),N))),N)))),N))),N))),toporef(0)))),_function("js-global"),ffun(dfun(),ffex(dfex(),C(_variable("name"),N),I,C(extref(_function("%progn")),C(str("Access a JS global by NAME (a string).  Return undefined if the\nglobal doesn't exist."),C(C(_variable("%js-global"),C(_variable("name"),N)),N))),toporef(0))),_function("js-set-global"),ffun(dfun(),ffex(dfex(),C(_variable("name"),C(_variable("value"),N)),I,C(extref(_function("%progn")),C(str("Update a JS global by NAME (a string)."),C(C(_variable("%js-set-global"),C(_variable("name"),C(_variable("value"),N))),N))),toporef(0))),_function("js-new"),ffun(dfun(),ffex(dfex(),C(_variable("constructor"),_variable("arguments")),I,C(extref(_function("%progn")),C(str("Call the JS CONSTRUCTOR function with ARGUMENTS."),C(C(_variable("apply"),C(_function("%js-new"),C(C(_variable("cons"),C(_variable("constructor"),C(_variable("arguments"),N))),N))),N))),toporef(0))),_function("js-get"),ffun(dfun(),ffex(dfex(),C(_variable("object"),C(_variable("name"),N)),I,C(extref(_function("%progn")),C(str("Access a property of a JS object by NAME (a string)."),C(C(_variable("%js-get"),C(_variable("object"),C(_variable("name"),N))),N))),toporef(0))),_function("to-lisp-boolean"),ffun(dfun(),ffex(dfex(),C(_variable("js-boolean"),N),I,C(extref(_function("%progn")),C(str("Convert the JS-BOOLEAN to a Lisp boolean."),C(C(_variable("%to-lisp-boolean"),C(_variable("js-boolean"),N)),N))),toporef(0))),_function("to-js-boolean"),ffun(dfun(),ffex(dfex(),C(_variable("lisp-boolean"),N),I,C(extref(_function("%progn")),C(str("Convert the LISP-BOOLEAN to a JS boolean."),C(C(_variable("%to-js-boolean"),C(_variable("lisp-boolean"),N)),N))),toporef(0))),_function("to-lisp-number"),ffun(dfun(),ffex(dfex(),C(_variable("js-number"),N),I,C(extref(_function("%progn")),C(str("Convert the JS-NUMBER to a Lisp number."),C(C(_variable("%to-lisp-number"),C(_variable("js-number"),N)),N))),toporef(0))),_function("to-js-number"),ffun(dfun(),ffex(dfex(),C(_variable("lisp-number"),N),I,C(extref(_function("%progn")),C(str("Convert the LISP-NUMBER to a JS number."),C(C(_variable("%to-js-number"),C(_variable("lisp-number"),N)),N))),toporef(0))),_function("to-lisp-string"),ffun(dfun(),ffex(dfex(),C(_variable("js-string"),N),I,C(extref(_function("%progn")),C(str("Convert the JS-STRING to a Lisp string."),C(C(_variable("%to-lisp-string"),C(_variable("js-string"),N)),N))),toporef(0))),_function("to-js-string"),ffun(dfun(),ffex(dfex(),C(_variable("lisp-string"),N),I,C(extref(_function("%progn")),C(str("Convert the LISP-STRING to a JS string."),C(C(_variable("%to-js-string"),C(_variable("lisp-string"),N)),N))),toporef(0))),_function("to-lisp-function"),ffun(dfun(),ffex(dfex(),C(_variable("js-function"),N),I,C(extref(_function("%progn")),C(str("Convert the JS-FUNCTION to a Lisp function."),C(C(_variable("%to-lisp-function"),C(_variable("js-function"),N)),N))),toporef(0))),_function("to-js-function"),ffun(dfun(),ffex(dfex(),C(_variable("lisp-operator"),N),I,C(extref(_function("%progn")),C(str("Convert the LISP-OPERATOR to a JS function."),C(C(_variable("%to-js-function"),C(_variable("lisp-operator"),N)),N))),toporef(0))),_function("list-to-js-array"),ffun(dfun(),ffex(dfex(),C(_variable("list"),N),I,C(extref(_function("%progn")),C(str("Turn a list into a JS array."),C(C(_variable("%list-to-js-array"),C(_variable("list"),N)),N))),toporef(0))),_function("js-array-to-list"),ffun(dfun(),ffex(dfex(),C(_variable("array"),N),I,C(extref(_function("%progn")),C(str("Turn a JS array into a list."),C(C(_variable("%js-array-to-list"),C(_variable("array"),N)),N))),toporef(0))),_function("js-array"),ffun(dfun(),ffex(dfex(),_variable("elements"),I,C(extref(_function("%progn")),C(str("Create a new JS array from the given elements."),C(C(_variable("list-to-js-array"),C(_variable("elements"),N)),N))),toporef(0))),_function("apply-js-method"),ffun(dfun(),ffex(dfex(),C(_variable("receiver"),C(_variable("name"),C(_variable("arguments"),N))),I,C(extref(_function("%progn")),C(str("Invoke a JS method by NAME (a string) on the RECEIVER object,\npassing along the list of ARGUMENTS."),C(C(_variable("%apply-js-method"),C(_variable("receiver"),C(_variable("name"),C(_variable("arguments"),N)))),N))),toporef(0))),_function("call-js-method"),ffun(dfun(),ffex(dfex(),C(_variable("receiver"),C(_variable("name"),_variable("arguments"))),I,C(extref(_function("%progn")),C(str("Invoke a JS method by NAME (a string) on the RECEIVER object,\npassing along the rest ARGUMENTS."),C(C(_variable("apply"),C(_function("apply-js-method"),C(C(_variable("list"),C(_variable("receiver"),C(_variable("name"),C(_variable("arguments"),N)))),N))),N))),toporef(0))),_function("js-method"),ffun(dfun(),ffex(dfex(),C(_variable("method-name"),N),I,C(extref(_function("%progn")),C(str("Create a function that when called will call the specified method."),C(C(_variable("lambda"),C(C(_variable("receiver"),_variable("arguments")),C(C(_variable("apply-js-method"),C(_variable("receiver"),C(_variable("method-name"),C(_variable("arguments"),N)))),N))),N))),toporef(0))),_function("define-js-method"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("method-name"),N)),I,C(extref(_function("%progn")),C(str("Define a new function with the given NAME (a symbol) that invokes a\nJS method named METHOD-NAME (a string).  The function takes one or\nmore arguments.  The first argument is the receiver of the method\ncall (\"this\"), the rest are the normal method arguments."),C(C(_variable("list"),C(_function("def"),C(C(_variable("function-symbol"),C(_variable("name"),N)),C(C(_variable("js-method"),C(_variable("method-name"),N)),N)))),N))),toporef(0)))),_function("js-undefined-option"),ffun(dfun(),ffex(dfex(),C(_variable("value"),N),I,C(extref(_function("%progn")),C(str("Turn a value that may be undefined into an option."),C(C(_variable("if"),C(C(_variable("eq"),C(_variable("value"),C(_variable("+js-undefined+"),N))),C(N,C(C(_variable("some"),C(_variable("value"),N)),N)))),N))),toporef(0))),_function("js-null-option"),ffun(dfun(),ffex(dfex(),C(_variable("value"),N),I,C(extref(_function("%progn")),C(str("Turn a value that may be null into an option."),C(C(_variable("if"),C(C(_variable("eq"),C(_variable("value"),C(_variable("+js-null+"),N))),C(N,C(C(_variable("some"),C(_variable("value"),N)),N)))),N))),toporef(0))),_function("await"),ffun(dfun(),ffex(dfex(),C(_variable("promise"),N),I,C(extref(_function("%progn")),C(str("Wait for the PROMISE to become fulfilled or rejected."),C(C(_variable("yield"),C(_variable("k"),C(C(_variable("call-js-method"),C(_variable("promise"),C(str("then"),C(C(_variable("js-lambda"),C(C(_variable("value"),N),C(C(_variable("resume"),C(_variable("k"),C(_variable("value"),N))),N))),C(C(_variable("js-lambda"),C(C(_variable("error"),N),C(C(_variable("resume"),C(_variable("k"),C(C(_variable("error"),C(_variable("error"),N)),N))),N))),N))))),N))),N))),toporef(0))),_function("sync"),ffun(dfun(),ffex(dfex(),C(_function("fun"),N),I,C(extref(_function("%progn")),C(str("Create a function that will await an underlying function."),C(C(_variable("lambda"),C(_variable("args"),C(C(_variable("await"),C(C(_variable("apply"),C(_function("fun"),C(_variable("args"),N))),N)),N))),N))),toporef(0))),_function("define-js-method/sync"),ffex(dfex(),_variable("operand"),_variable("env"),toporef(1),fenv(denv(toporef(0)),_variable("expander"),ffex(dfex(),C(_variable("name"),C(_variable("method-name"),N)),I,C(extref(_function("%progn")),C(str("Like `define-js-method', but awaits the method result."),C(C(_variable("list"),C(_function("def"),C(C(_variable("function-symbol"),C(_variable("name"),N)),C(C(_variable("sync"),C(C(_variable("js-method"),C(_variable("method-name"),N)),N)),N)))),N))),toporef(0)))),_function("sleep"),ffun(dfun(),ffex(dfex(),C(_variable("ms"),N),I,C(extref(_function("%progn")),C(str("Sleep for some milliseconds."),C(C(_variable("await"),C(C(_variable("%sleep"),C(_variable("ms"),N)),N)),N))),toporef(0))),_function("js-log"),ffun(dfun(),ffex(dfex(),_variable("arguments"),I,C(extref(_function("%progn")),C(str("Log the ARGUMENTS to the JS console."),C(C(_variable("apply"),C(_function("%js-log"),C(_variable("arguments"),N))),N))),toporef(0))));
fcons(toporef(1),_variable("%eval"),C(C(_variable("%eval"),C(C(_variable("%cons"),C(_variable("expander"),C(_variable("operand"),N))),C(C(_variable("%make-environment"),N),N))),C(_variable("env"),N)));
fcons(toporef(2),_variable("keyform"),_variable("clauses"));
fcons(toporef(3),C(_variable("let"),C(C(C(_variable("key"),C(C(_variable("eval"),C(_variable("keyform"),C(_variable("env"),N))),N)),N),C(C(_variable("loop-let"),C(_variable("-typecase-"),C(C(C(_variable("clauses"),C(_variable("clauses"),N)),N),C(C(_variable("if"),C(C(_variable("null"),C(_variable("clauses"),N)),C(C(_variable("default"),C(_variable("key"),N)),C(C(_variable("let"),C(C(C(C(C(_variable("class-name"),_variable("forms")),_variable("rest-clauses")),C(_variable("clauses"),N)),N),C(C(_variable("if"),C(C(_variable("typep"),C(_variable("key"),C(C(_variable("find-class"),C(_variable("class-name"),C(_variable("env"),N))),N))),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(_variable("env"),N))),C(C(_variable("-typecase-"),C(_variable("rest-clauses"),N)),N)))),N))),N)))),N)))),N))),N);
fcons(toporef(4),_variable("arg1"),C(_variable("arg2"),_variable("rest")));
fcons(toporef(5),C(_variable("if"),C(C(_variable("binary-operator"),C(_variable("arg1"),C(_variable("arg2"),N))),C(C(_variable("if"),C(C(_variable("null"),C(_variable("rest"),N)),C(T,C(C(_variable("apply"),C(_function("operator"),C(C(_variable("list*"),C(_variable("arg2"),C(_variable("rest"),N))),N))),N)))),C(F,N)))),N);
ffun(toporef(6),ffex(dfex(),toporef(4),I,C(extref(_function("%progn")),toporef(5)),fenv(denv(fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%=")))),_function("operator"),toporef(6))));
ffun(toporef(7),ffex(dfex(),toporef(4),I,C(extref(_function("%progn")),toporef(5)),fenv(denv(fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%<")))),_function("operator"),toporef(7))));
ffun(toporef(8),ffex(dfex(),toporef(4),I,C(extref(_function("%progn")),toporef(5)),fenv(denv(fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%>")))),_function("operator"),toporef(8))));
ffun(toporef(9),ffex(dfex(),toporef(4),I,C(extref(_function("%progn")),toporef(5)),fenv(denv(fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%<=")))),_function("operator"),toporef(9))));
ffun(toporef(10),ffex(dfex(),toporef(4),I,C(extref(_function("%progn")),toporef(5)),fenv(denv(fenv(denv(toporef(0)),_function("binary-operator"),extref(_function("%>=")))),_function("operator"),toporef(10))));
fcons(toporef(11),C(_variable("reduce"),C(_function("binary-operator"),C(_variable("args"),C(_keyword("initial-value"),C(_variable("initial-value"),N))))),N);
fcons(toporef(12),_variable("arg1"),_variable("rest"));
fcons(toporef(13),C(_variable("if"),C(C(_variable("null"),C(_variable("rest"),N)),C(C(_variable("binary-operator"),C(_variable("initial-value"),C(_variable("arg1"),N))),C(C(_variable("reduce"),C(_function("binary-operator"),C(_variable("rest"),C(_keyword("initial-value"),C(_variable("arg1"),N))))),N)))),N);
fcons(toporef(14),C(_variable("apply"),C(C(_variable("%find-method"),C(C(_variable("class-of"),C(C(_variable("car"),C(_variable("args"),N)),N)),C(_variable("name"),N))),C(_variable("args"),N))),N);
fcons(toporef(15),_variable("handler-specs"),_variable("forms"));
fcons(toporef(16),C(_variable("let"),C(C(C(_variable("handler-frame"),C(C(_variable("make-instance"),C(_class("handler-frame"),C(_keyword("handlers"),C(C(_variable("mapcar"),C(C(_variable("lambda"),C(C(_variable("spec"),N),C(C(_variable("handler-spec-parser"),C(_variable("spec"),C(_variable("env"),N))),N))),C(_variable("handler-specs"),N))),C(_keyword("parent-frame?"),C(C(_variable("dynamic"),C(_variable("handler-frame-dynamic"),N)),N)))))),N)),N),C(C(_variable("progv"),C(C(_variable("list"),C(_variable("handler-frame-dynamic"),N)),C(C(_variable("list"),C(C(_variable("some"),C(_variable("handler-frame"),N)),N)),C(C(_variable("eval"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),C(_variable("env"),N))),N)))),N))),N);
fobj(toporef(17),_variable("value"),N);
fobj(toporef(18),_variable("value"),N);
fcons(toporef(19),_variable("handler-specs"),_variable("forms"));
fcons(toporef(20),C(_variable("block"),C(_variable("exit"),C(C(C(_variable("block"),C(_variable("trampoline"),C(C(_variable("eval"),C(C(_variable("list"),C(_function("handler-bind-operator"),C(C(_variable("mapcar"),C(C(_variable("lambda"),C(C(C(_variable("name"),C(_variable("function-form"),_variable("properties"))),N),C(C(_variable("list*"),C(_variable("name"),C(C(_variable("lambda"),C(_variable("args"),C(C(_variable("return-from"),C(_variable("trampoline"),C(C(_variable("lambda"),C(N,C(C(_variable("apply"),C(C(_variable("eval"),C(_variable("function-form"),C(_variable("env"),N))),C(_variable("args"),N))),N))),N))),N))),C(_variable("properties"),N)))),N))),C(_variable("handler-specs"),N))),C(C(_variable("list"),C(_function("return-from"),C(_variable("exit"),C(C(_variable("list*"),C(_function("progn"),C(_variable("forms"),N))),N)))),N)))),C(_variable("env"),N))),N))),N),N))),N);
ffex(toporef(21),toporef(15),_variable("env"),C(extref(_function("%progn")),toporef(16)),fenv(denv(toporef(0)),_function("handler-spec-parser"),ffun(dfun(),ffex(dfex(),C(C(_variable("class-name"),C(_variable("function-form"),N)),C(_variable("env"),N)),I,C(extref(_function("%progn")),C(C(_variable("make-instance"),C(_class("condition-handler"),C(_keyword("condition-class"),C(C(_variable("the"),C(_variable("class"),C(C(_variable("find-class"),C(_variable("class-name"),C(_variable("env"),N))),N))),C(_keyword("handler-function"),C(C(_variable("the"),C(_variable("function"),C(C(_variable("eval"),C(_variable("function-form"),C(_variable("env"),N))),N))),N)))))),N)),toporef(0))),_variable("handler-frame-dynamic"),toporef(17)));
ffex(toporef(22),toporef(15),_variable("env"),C(extref(_function("%progn")),toporef(16)),fenv(denv(toporef(0)),_function("handler-spec-parser"),ffun(dfun(),ffex(dfex(),C(C(_variable("restart-name"),C(_variable("function-form"),_variable("properties"))),C(_variable("env"),N)),I,C(extref(_function("%progn")),C(C(_variable("make-instance"),C(_class("restart-handler"),C(_keyword("restart-name"),C(C(_variable("the"),C(_variable("symbol"),C(_variable("restart-name"),N))),C(_keyword("handler-function"),C(C(_variable("the"),C(_variable("function"),C(C(_variable("eval"),C(_variable("function-form"),C(_variable("env"),N))),N))),C(_keyword("interactive-function?"),C(C(_variable("when-option"),C(C(_variable("i-f-form"),C(C(_variable("get?"),C(_variable("properties"),C(_keyword("interactive-function"),N))),N)),C(C(_variable("some"),C(C(_variable("the"),C(_variable("function"),C(C(_variable("eval"),C(_variable("i-f-form"),C(_variable("env"),N))),N))),N)),N))),C(_keyword("associated-conditions"),C(C(_variable("when-option"),C(C(_variable("a-cs-form"),C(C(_variable("get?"),C(_variable("properties"),C(_keyword("associated-conditions"),N))),N)),C(C(_variable("the"),C(_variable("list"),C(C(_variable("eval"),C(_variable("a-cs-form"),C(_variable("env"),N))),N))),N))),N)))))))))),N)),toporef(0))),_variable("handler-frame-dynamic"),toporef(18)));
fcons(toporef(23),_variable("condition"),_variable("handler-specs"));
fcons(toporef(24),C(_variable("let"),C(C(C(_variable("c"),C(C(_variable("eval"),C(_variable("condition"),C(_variable("env"),N))),N)),N),C(C(_variable("flet"),C(C(C(_variable("append-associated-condition"),C(C(_variable("handler-spec"),N),C(C(_variable("append"),C(_variable("handler-spec"),C(C(_variable("list"),C(_keyword("associated-conditions"),C(C(_variable("list"),C(_function("list"),C(_variable("c"),N))),N))),N))),N))),N),C(C(_variable("eval"),C(C(_variable("list"),C(_function("restart-case"),C(C(_variable("mapcar"),C(_function("append-associated-condition"),C(_variable("handler-specs"),N))),C(C(_variable("list"),C(_function("signal-operator"),C(_variable("c"),N))),N)))),C(_variable("env"),N))),N))),N))),N);
ffun(toporef(25),ffex(dfex(),C(_variable("condition"),N),I,C(extref(_function("%progn")),C(str("Utility to signal the CONDITION.  If the signal is unhandled,\nreturn void.  See `signal'."),C(C(_variable("loop-let"),C(_variable("-signal-"),C(C(C(_variable("handler-frame?"),C(C(_variable("dynamic"),C(_variable("*condition-handler-frame?*"),N)),N)),N),C(C(_variable("if-option"),C(C(C(_variable("handler"),C(_variable("frame"),N)),C(C(_variable("lispx::find-handler?"),C(_variable("condition"),C(_variable("handler-frame?"),C(N,N)))),N)),C(C(_variable("progn"),C(C(_variable("lispx::call-condition-handler"),C(_variable("handler"),C(_variable("frame"),C(_variable("condition"),N)))),C(C(_variable("-signal-"),C(C(_variable("slot-value"),C(_variable("frame"),C(C(_variable("quote"),C(_variable("parent-frame?"),N)),N))),N)),N))),C(V,N)))),N)))),N))),toporef(0)));
ffun(toporef(26),ffex(dfex(),C(_variable("condition"),N),I,C(extref(_function("%progn")),C(str("Utility to signal the CONDITION.  If the condition is unhandled,\ninvoke the debugger.  Therefore never returns normally.  See `error'."),C(C(_variable("signal"),C(_variable("condition"),N)),C(C(_variable("invoke-debugger"),C(_variable("condition"),N)),N)))),toporef(0)));
return objects[0];

}
