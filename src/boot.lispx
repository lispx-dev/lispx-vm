;;; LispX Bootstrap

;; Copyright (c) 2021 Manuel J. Simoni

;;; Core Forms

(%%def #'list
  (%%wrap (%%vau arguments #ignore arguments))

  "Return the list of evaluated ARGUMENTS.

$(fn (arguments))
$(type function)")

(%%def #'vau
  (%%vau (parameter-tree environment-parameter . forms) env
    (%%eval (list #'%%vau parameter-tree environment-parameter
                  (%%list* #'%%progn forms))
            env))

  "Construct a fexpr with the given PARAMETER-TREE,
ENVIRONMENT-PARAMETER, and FORMS.

$(fn (parameter-tree environment-parameter . forms))
$(type fexpr)")

(%%def #'%make-macro
  (%%wrap
   (%%vau (expander) #ignore
     (%%vau form env
       (%%eval
        (%%eval (%%cons expander form) (%%make-environment))
        env))))

  "Create a macro from an EXPANDER operator.  A macro is an operator
that receives a form and produces an expression (by calling the
expander with the form as argument) that is then evaluated in place of
the form.

$(fn (expander))
$(type function)")

(%%def #'macro
  (%make-macro
   (%%vau (parameter-tree . forms) #ignore
     (list #'%make-macro
           (%%list* #'vau parameter-tree #ignore forms))))

  "Create an anonymous macro with the given PARAMETER-TREE and FORMS.

$(fn (parameter-tree . forms))
$(type macro)")

(%%def #'defmacro
  (macro (name parameter-tree . forms)
    (list #'%%def (%%function-symbol name)
          (%%list* #'macro parameter-tree forms)))

  "Define a macro with the given NAME, PARAMETER-TREE, and FORMS.

$(fn (name parameter-tree . forms))
$(type macro)")

(defmacro defexpr (name parameter-tree environment-parameter . forms)
  "Define a fexpr with the given NAME, PARAMETER-TREE,
ENVIRONMENT-PARAMETER, and FORMS."
  (list #'%%def (%%function-symbol name)
        (%%list* #'vau parameter-tree environment-parameter forms)))

(defmacro def (definiend-tree value . docstring?)
  "Match the DEFINIEND-TREE against the VALUE and place resulting
bindings into the current environment.  The optional DOCSTRING is
currently ignored."
  (list #'%%def definiend-tree value))

(defmacro defconstant (name value . docstring?)
  "Define a constant with the given NAME and VALUE.  This is mostly
for documentation purposes, as constants are still mutable.  The
optional DOCSTRING is currently ignored."
  (list #'def name value))

(defmacro lambda (parameter-tree . forms)
  "Create an anonymous function with the given PARAMETER-TREE and FORMS."
  (list #'%%wrap (%%list* #'vau parameter-tree #ignore forms)))

(defmacro defun (name parameter-tree . forms)
  "Define a function with the given NAME, PARAMETER-TREE, and FORMS."
  (list #'def (%%function-symbol name)
        (%%list* #'lambda parameter-tree forms)))

;;; Built-Ins

(defmacro progn forms
  "Sequentially evaluate FORMS, returning the value of the last one,
or void if there are no forms."
  (list* #'%%progn forms))

(defmacro if (test consequent alternative)
  "Evaluate the TEST which must yield a boolean.  Then evaluate either
the CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded
true or false."
  (list #'%%if test consequent alternative))

(defun eq (a b)
  "Return true if the values A and B are pointer-identical, false otherwise."
  (%%eq a b))

(defun class-of (object)
  "Return the class of the OBJECT."
  (%%class-of object))

(defun typep (object class)
  "Return true if the OBJECT is an instance of the CLASS, false otherwise."
  (%%typep object class))

(defun intern (string)
  "Get or create the unique symbol with STRING as name."
  (%%intern string))

(defun symbol-name (symbol)
  "Return the name of the SYMBOL as a string."
  (%%symbol-name symbol))

(defun variable-symbol (symbol)
  "Return the symbol with the same name as SYMBOL, but in the variable namespace."
  (%%variable-symbol symbol))

(defun function-symbol (symbol)
  "Return the symbol with the same name as SYMBOL, but in the function namespace."
  (%%function-symbol symbol))

(defun class-symbol (symbol)
  "Return the symbol with the same name as SYMBOL, but in the class namespace."
  (%%class-symbol symbol))

(defun keyword-symbol (symbol)
  "Return the symbol with the same name as SYMBOL, but in the keyword namespace."
  (%%keyword-symbol symbol))

(defun cons (car cdr)
  "Create a cons with the given CAR and CDR."
  (%%cons car cdr))

(defun car (cons)
  "Return the contents of the address part of the register."
  (%%car cons))

(defun cdr (cons)
  "Return the contents of the decrement part of the register."
  (%%cdr cons))

(defun list* arguments
  "Create a list from the ARGUMENTS so that the last argument becomes
the `cdr' of the list."
  (apply #'%%list* arguments))

(defun reverse (list)
  "Reverse the LIST."
  (%%reverse list))

(defun append (list1 list2)
  "Append two lists.  The first one must be proper and is copied.  The
second one is not copied (and doesn't even have to be a list). It
becomes the `cdr' of the final cons of the first list, or is returned
directly if the first list is empty."
  (%%append list1 list2))

(defun wrap (operator)
  "Create a new function that wraps around an underlying OPERATOR, and
induces argument evaluation around it."
  (%%wrap operator))

(defun unwrap (function)
  "Return the underlying operator of a FUNCTION."
  (%%unwrap function))

(defun eval (form environment)
  "Evaluate the FORM in the ENVIRONMENT, returning its result."
  (%%eval form environment))

(defun make-environment parent-environment?
  "Create a new environment with an optional PARENT-ENVIRONMENT in
which bindings are looked up if they are not found."
  (apply #'%%make-environment parent-environment?))

(defun boundp (symbol environment)
  "Return true if the SYMBOL is bound in the ENVIRONMENT, false otherwise."
  (%%boundp symbol environment))

(defun panic (error)
  "Signal the ERROR in such a way that it cannot be caught by
condition handlers or `unwind-protect'.  This unconditionally breaks
out of Lisp."
  (%%panic error))

;;; Lexical Bindings

(defmacro let (bindings . forms)
  "Establish BINDINGS parallelly during the evaluation of FORMS, so
that no binding can refer to the other ones.

$(syntax binding (definiend-tree value))"
  (list* (list* #'lambda (mapcar #'car bindings)
                forms)
         (mapcar #'cadr bindings)))

(defmacro let* (bindings . forms)
  "Establish BINDINGS serially during the evaluation of FORMS, so that
every binding can refer to previous ones.

$(syntax binding (definiend-tree value))"
  (if (null bindings)
      (list* #'let () forms) ; Always introduce a new scope.
      (list #'let (list (car bindings))
            (list* #'let* (cdr bindings) forms))))

(defmacro %letrec (bindings . forms)
  "Utility to establish BINDINGS recursively during the evaluation of
FORMS.  Used by `labels'."
  (if (null bindings)
      (list* #'let () forms) ; Always introduce a new scope.
      (list* #'let ()
             (list #'def
                   (mapcar #'car bindings)
                   (list* #'list (mapcar #'cadr bindings)))
             forms)))

(defun %function-binding ((name parameter-tree . forms))
  "Utility to turn a function binding as it appears in `flet' and
`labels' into a binding for `let' or `%letrec'."
  (list (function-symbol name) (list* #'lambda parameter-tree forms)))

(defmacro flet (function-bindings . forms)
  "Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,
so that no function can refer to the other ones.

$(syntax function-binding (name parameter-tree . forms))"
  (list* #'let (mapcar #'%function-binding function-bindings) forms))

(defmacro labels (function-bindings . forms)
  "Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,
so that every function can refer to the other ones.

$(syntax function-binding (name parameter-tree . forms))"
  (list* #'%letrec (mapcar #'%function-binding function-bindings) forms))

;;; Data and Control Flow

(defexpr quote (operand) #ignore
  "Return the unevaluated OPERAND."
  operand)

(defexpr the-environment () environment
  "Return the current environment."
  environment)

(defun apply (function arguments)
  "Call the FUNCTION with a dynamically-supplied list of ARGUMENTS."
  (eval (cons (unwrap function) arguments) (%%make-environment)))

(defmacro when (test . forms)
  "If TEST yields true, evaluate the FORMS as an implicit `progn'.
Otherwise, return void."
  (list #'if test (list* #'progn forms) #void))

(defmacro unless (test . forms)
  "If TEST yields false, evaluate the FORMS as an implicit `progn'.
Otherwise, return void."
  (list #'if test #void (list* #'progn forms)))

(defexpr cond clauses env
  "Multi-armed conditional.

Go through the CLAUSES in order.  Evaluate the TEST.  If it yields
true, evaluate the FORMS as an implicit `progn'.  If it yields false,
go to the next clause, or return void if there are no more clauses.

$(syntax clause (test . forms))"
  (unless (null clauses)
    (let ((((test . forms) . rest-clauses) clauses))
      (if (eval test env)
          (eval (cons #'progn forms) env)
          (eval (cons #'cond rest-clauses) env)))))

(defun not (boolean)
  "Invert the BOOLEAN."
  (if boolean #f #t))

(defexpr and operands env
  "Return true if all OPERANDS evaluate to true, false otherwise.  If
an operand evaluates to false, later operands are not evaluated.  If
there are no operands, return false."
  (cond ((null operands)           #t)
        ((null (cdr operands))     (the boolean (eval (car operands) env)))
        ((eval (car operands) env) (eval (cons #'and (cdr operands)) env))
        (#t                        #f)))

(defexpr or operands env
  "Return true if one of the OPERANDS evaluates to true, false
otherwise.  If an operand evaluates to true, later operands are not
evaluated.  If there are no operands, return true."
  (cond ((null operands)           #f)
        ((null (cdr operands))     (the boolean (eval (car operands) env)))
        ((eval (car operands) env) #t)
        (#t                        (eval (cons #'or (cdr operands)) env))))

(defmacro loop forms
  "Evaluate the FORMS in an infinite loop."
  (list #'%%loop (list* #'progn forms)))

(defmacro loop-let (name initializers . forms)
  "Labelled recursive loop, analogous to Scheme's named `let'.

Lexically bind a function named NAME with one PARAMETER for every
INITIALIZER and the FORMS as body.  Then immediately apply the
function to a list containing one VALUE for every INITIALIZER and
return the result.  The function is bound per `labels' so it can
recursively refer to itself.

$(syntax initializer (parameter value))"
  (list #'labels (list (list* name (mapcar #'car initializers) forms))
        (list* name (mapcar #'cadr initializers))))

(defexpr catch (tag . forms) env
  "Establish a catch tag and evaluate FORMS as an implicit `progn'
inside it.  The forms may use `throw' to nonlocally exit from the
tag.  Usually, `block' should be preferred."
  (eval (list #'%%catch (eval tag env) (list* #'progn forms)) env))

(defun throw (tag . result?)
  "Abort to a nesting catch tag established by `catch' and pass the
RESULT to it."
  (%%throw tag (optional result?)))

(defexpr block (block-name . forms) env
  "Establish a block named BLOCK-NAME and evaluate the FORMS as an
implicit `progn' inside it.  The forms may use `return-from' to
nonlocally exit from the block.

Note that unlike in Common Lisp, there is no separate namespace for
block names; a block is named in the normal variable namespace."
  (let ((tag (list #void))) ; cons up a fresh object as tag
    (flet ((escape (value) (throw tag value)))
      (catch tag
        (eval (list (list* #'lambda (list block-name) forms)
                    #'escape)
              env)))))

(defun return-from (#'block-name . value?)
  "Abort evaluation and return the optional VALUE (which defaults to
void) from the block named BLOCK-NAME.  It is an error to return from
a block whose dynamic extent has ended.

$(fn (block-name . value?))"
  (block-name (optional value?)))

(defmacro unwind-protect (protected-form . cleanup-forms)
  "Evaluate the PROTECTED-FORM and return its result.  Regardless of
whether the protected form returns normally, or via a nonlocal exit,
the CLEANUP-FORMS are evaluated after the protected form.  Note that
the protected forms are not evaluated in case of `panic'."
  (list #'%%unwind-protect protected-form (list* #'progn cleanup-forms)))

(defexpr set (environment definiend-tree value) dynamic-environment
  "Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,
creating or updating existing bindings."
  (eval (list #'def definiend-tree
              (list (unwrap #'eval) value dynamic-environment))
        (eval environment dynamic-environment)))

(defexpr prog1 (form . forms) env
  "Evaluate FORM and any additional FORMS, and return the result of FORM."
  (let ((result (eval form env)))
    (eval (list* #'progn forms) env)
    result))

(defexpr typecase (keyform . clauses) env
  "Multi-armed type test.

Evaluate the KEYFORM.  Go through the CLAUSES.  If the result of
evaluating KEYFORM is an instance of the class named by CLASS-NAME,
evaluate the FORMS as an implicit `progn'.  Otherwise go to the next
clause, or return void if there are no more clauses.

$(syntax clause (class-name . forms))"
  (let ((key (eval keyform env)))
    (loop-let -typecase- ((clauses clauses))
      (unless (null clauses)
        (let ((((class-name . forms) . rest-clauses) clauses))
          (if (typep key (find-class class-name env))
              (eval (cons #'progn forms) env)
              (-typecase- rest-clauses)))))))

(defun assert (boolean)
  "Signal an error if the BOOLEAN is false.  Otherwise return void."
  (unless boolean (error (make-instance (class assertion-error)))))

;;; Lists

(defun null (object)
  "Return true if the OBJECT is nil, false otherwise."
  (eq object #nil))

(defun caar (cons)
  "Return the `car' of the `car' of the CONS."
  (car (car cons)))

(defun cadr (cons)
  "Return the `car' of the `cdr' of the CONS."
  (car (cdr cons)))

(defun cdar (cons)
  "Return the `cdr' of the `car' of the CONS."
  (cdr (car cons)))

(defun cddr (cons)
  "Return the `cdr' of the `cdr' of the CONS."
  (cdr (cdr cons)))

(defun mapcar (#'function list)
  "Create a new list by applying the FUNCTION to every element of the LIST."
  (if (null list)
      #nil
      (cons (function (car list)) (mapcar #'function (cdr list)))))

(defun mapc (#'function list)
  "Apply the FUNCTION to every element of the LIST for effect.  Return the list."
  (unless (null list)
    (function (car list))
    (mapc #'function (cdr list)))
  list)

(defmacro dolist ((element list . result?) . forms)
  "For every element of the LIST, evaluate the FORMS with ELEMENT
bound to that element.  Return the optional RESULT or void."
  (list #'progn
        (list #'mapc (list* #'lambda (list element) forms) list)
        (optional result?)))

(defun elt (list n)
  "Return element number N of LIST, where the `car' is element zero."
  (if (= 0 n)
      (car list)
      (elt (cdr list) (- n 1))))

(defun reduce (#'function list :initial-value initial-value)
  "Use the binary FUNCTION to combine the elements of the LIST.  The
INITIAL-VALUE is logically placed before the list."
  (if (null list)
      initial-value
      (reduce #'function (cdr list) :initial-value (function initial-value (car list)))))

(defun memberp (element list :test #'test)
  "Return true if the ELEMENT is contained in the LIST according to
the TEST predicate, false otherwise."
  (if (null list)
      #f
      (if (test element (car list))
          #t
          (memberp element (cdr list) :test #'test))))

(defun remove-if (#'test list)
  "Return a new list from which the elements that satisfy the TEST
have been removed."
  (if (null list)
      #nil
      (if (test (car list))
          (remove-if #'test (cdr list))
          (cons (car list) (remove-if #'test (cdr list))))))

(defun remove-if-not (#'test list)
  "Return a new list from which the elements that don't satisfy the
TEST have been removed."
  (remove-if (lambda (item) (not (test item))) list))

(defun get? (plist indicator)
  "Search for the INDICATOR keyword in the property list PLIST (a list
of alternating keywords and values) and return the found value as an
option."
  (if (null plist)
      #nil
      (let (((i v . plist) plist))
        (if (eq i indicator)
            (some v)
            (get? plist indicator)))))

;;; Relational Operators

;; Note that unlike in Common Lisp, these operators currently require
;; at least two arguments.  This will be improved in the future.

(defun %relational-operator (#'binary-operator)
  "Utility to create an n-ary relational operator from a BINARY-OPERATOR."
  (labels ((operator (arg1 arg2 . rest)
             (if (binary-operator arg1 arg2)
                 (if (null rest)
                     #t
                     (apply #'operator (list* arg2 rest)))
                 #f)))
    #'operator))

(def #'= (%relational-operator #'%%=)
  "Return true if all ARGUMENTS are equal, false otherwise.

$(fn arguments)
$(type function)")

(def #'< (%relational-operator #'%%<)
  "Return true if the ARGUMENTS are in monotonically increasing order,
false otherwise.

$(fn arguments)
$(type function)")

(def #'> (%relational-operator #'%%>)
  "Return true if the ARGUMENTS are in monotonically decreasing order,
false otherwise.

$(fn arguments)
$(type function)")

(def #'<= (%relational-operator #'%%<=)
  "Return true if the ARGUMENTS are in monotonically nondecreasing
order, false otherwise.

$(fn arguments)
$(type function)")

(def #'>= (%relational-operator #'%%>=)
  "Return true if the ARGUMENTS are in monotonically nonincreasing
order, false otherwise.

$(fn arguments)
$(type function)")

(defun /= (arg . args)
  "Return true if no two ARGUMENTS are the same, false otherwise.

$(fn arguments)"
  (if (null args)
      #t
      (if (memberp arg args :test #'=)
          #f
          (apply #'/= args))))

;;; Numbers

;; The terms thetic (for + and *) and lytic (for - and /) are due to Hankel.

(defun %thetic-operator (#'binary-operator initial-value)
  "Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE."
  (lambda args
    (reduce #'binary-operator args :initial-value initial-value)))

(def #'+ (%thetic-operator #'%%+ 0)
  "Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.

$(fn arguments)
$(type function)")

(def #'* (%thetic-operator #'%%* 1)
  "Return the product of the ARGUMENTS, or 1 if no arguments are supplied.

$(fn arguments)
$(type function)")

(defun %lytic-operator (#'binary-operator initial-value)
  "Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE."
  (lambda (arg1 . rest)
    (if (null rest)
        (binary-operator initial-value arg1)
        (reduce #'binary-operator rest :initial-value arg1))))

(def #'- (%lytic-operator #'%%- 0)
  "If only one number is supplied in the ARGUMENTS, return the
negation of that number. If more than one number is supplied, subtract
all of the later ones from the first one and return the result.

$(fn arguments)
$(type function)")

(def #'/ (%lytic-operator #'%%/ 1)
  "If only one number is supplied in the ARGUMENTS, return the
reciprocal of that number.  If more than one number is supplied,
divide the first one by all of the later ones and return the result.

$(fn arguments)
$(type function)")

;;; Classes

(defmacro class (name)
  "Access a class by the (unevaluated) NAME symbol in the current
environment.  This is required because classes have their own
namespace."
  (class-symbol name))

(defun find-class (name environment)
  "Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT."
  (eval (class-symbol name) environment))

(defun class-name (class)
  "Return the name symbol of the CLASS."
  (%%class-name class))

(defun subclassp (class superclass)
  "Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
A class is considered a subclass of itself."
  (%%subclassp class superclass))

(defexpr defclass (name superclass? slot-specs . properties) env
  "Define a new `standard-class' with the given NAME, optional
SUPERCLASS, and SLOT-SPECS.  The superclass defaults to
`standard-object'.  The SLOT-SPECS and PROPERTIES are currently
ignored.

Note: In the future, this will redefine the class if it already
exists, but for now it always creates a new class.  Therefore it is
best to avoid multiple calls to `defclass' for the same class.

$(syntax slot-spec symbol)
$(syntax property (:documentation docstring))"
  (def superclass (find-class (optional superclass? 'standard-object) env))
  ;; Slot-specs are ignored for now, but check them nevertheless.
  (dolist (slot-spec slot-specs)
    (the symbol slot-spec))
  (eval (list #'def (class-symbol name) (%%make-standard-class name superclass)) env)
  name)

;;; Generic Functions

(defexpr defgeneric (name (receiver . parameters) . properties) env
  "Define a new generic function with the given NAME.  The RECEIVER,
PARAMETERS, and PROPERTIES are currently ignored.

$(syntax property (:documentation docstring))"
  ;; Parameters are ignored for now, but check them nevertheless.
  (the symbol receiver)
  (dolist (param parameters)
    (the symbol param))
  (def generic (lambda args (%%invoke-method name args)))
  (eval (list #'def (function-symbol name) generic) env)
  name)

(defexpr defmethod (name ((receiver class-name) . parameters) . forms) env
  "Add a new method to the generic function named by NAME specialized
for the class named by CLASS-NAME."
  (def class (find-class class-name env))
  ;; Note that the method can be a fexpr because the generic function
  ;; has already evaluated the arguments when it is called.
  (def method (eval (list* #'vau (cons receiver parameters) #ignore forms) env))
  (%%put-method class name method)
  name)

;;; Standard Objects

(defun make-instance (class . slot-inits)
  "Create a new instance of CLASS (that must be a `standard-class').
The SLOT-INITS must be of even length, and alternately contain slot
names (symbols, typically keywords) and values."
  (apply #'%%make-instance (cons class slot-inits)))

(defun slot-value (object slot-name)
  "Return the value of the slot named SLOT-NAME of the OBJECT."
  (%%slot-value object slot-name))

(defun set-slot-value (object slot-name value)
  "Set the value of the slot named SLOT-NAME of the OBJECT to VALUE."
  (%%set-slot-value object slot-name value))

(defun slot-bound-p (object slot-name)
  "Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise."
  (%%slot-bound-p object slot-name))

;;; Type Checks

(defun make-type-error (datum expected-type)
  "Create a `type-error' with the given DATUM and EXPECTED-TYPE."
  (make-instance (class type-error) :datum datum :expected-type expected-type))

(defun assert-type (object class)
  "Signal a `type-error' if the OBJECT is not an instance of the CLASS."
  (if (typep object class)
      object
      (error (make-type-error object (class-name class)))))

(defexpr the (class-name object) env
  "Shorthand for `assert-type'.  Signal a `type-error' if the OBJECT
is not an instance of the class named by CLASS-NAME."
  (assert-type (eval object env) (find-class class-name env)))

;;; Options

;; An option is either nil ("none"), or a one-element list ("some").
;; Variables holding options are conventionally suffixed with "?".

(defun some (value)
  "Create a one-element list from the VALUE."
  (list value))

(defexpr if-option ((name option?) then else) env
  "Destructure the OPTION.  If it's non-nil, evaluate the THEN form
with the NAME bound to the contents of the option.  If it's nil,
evaluate the ELSE form."
  ;; (Idea from Taylor R. Campbell's blag.)
  (let ((o? (eval option? env)))
    (if (null o?)
        (eval else env)
        (eval (list (list #'vau (list name) #ignore then)
                    (car o?))
              env))))

(defmacro when-option ((name option?) . forms)
  "Destructure the OPTION.  If it's non-nil, evaluate the FORMS with
the NAME bound to the contents of the option.  If it's nil, return nil."
  (list #'if-option (list name option?) (list* #'progn forms) #nil))

(defun optional (option? . default?)
  "Return the contents of the OPTION, or the DEFAULT if the option is
nil.  The default itself defaults to void."
  (if-option (value option?)
    value
    (if-option (default default?)
      default
      #void)))

(defun optionals (list . defaults)
  "Similar to `optional', but provides DEFAULTS for any number of
elements of LIST."
  (loop-let -optionals- ((list list) (defaults defaults))
    (if (null list)
        (if (null defaults)
            #nil
            (cons (car defaults) (-optionals- #nil (cdr defaults))))
        (if (null defaults)
            (cons (car list) (-optionals- (cdr list) #nil))
            (cons (car list) (-optionals- (cdr list) (cdr defaults)))))))

;;; Dynamic Binding

(defmacro defdynamic (name value . docstring?)
  "Define a new dynamic variable with the given NAME and default VALUE.
The optional DOCSTRING is currently ignored."
  (list #'def name (make-instance (class dynamic) :value value)))

(defun dynamic (dynamic-variable)
  "Return the current value of the DYNAMIC-VARIABLE."
  (slot-value dynamic-variable 'value))

(defexpr dynamic-let (bindings . forms) env
  "Evaluate the FORMS with the dynamic variables specified by BINDINGS
temporarily bound to new values.

$(syntax binding (dynamic-variable value))"
  (let ((dynamics (mapcar (lambda ((name #ignore)) (eval name env)) bindings))
        (values (mapcar (lambda ((#ignore value)) (eval value env)) bindings))
        (thunk (eval (list* #'lambda () forms) env)))
    (%%progv dynamics values thunk)))

(defmacro progv (dynamic-variables values . forms)
  "Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily
bound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have
the same length."
  (list #'%%progv dynamic-variables values (list* #'lambda () forms)))

;;; Delimited Control Operators

;; These operators follow the API put forth in the delimcc library
;; at URL `http://okmij.org/ftp/continuations/implementations.html'.

(defmacro push-prompt (prompt . forms)
  "Push the PROMPT and evaluate the FORMS inside the prompt.  This
delimits the continuation."
  (list #'%%push-prompt prompt (list* #'lambda () forms)))

(defmacro take-subcont (prompt name . forms)
  "Abort outwards to the PROMPT.  When the prompt is reached, evaluate
the FORMS with NAME bound to the captured continuation (which does not
include the prompt)."
  (list #'%%take-subcont prompt (list* #'lambda (list name) forms)))

(defmacro push-delim-subcont (prompt continuation . forms)
  "Push the PROMPT and compose the previously captured CONTINUATION
inside it.  The FORMS are then evaluated inside the new continuation."
  (list #'%%push-delim-subcont prompt continuation (list* #'lambda () forms)))

(defmacro push-subcont-barrier forms
  "Push a continuation barrier that prevents the FORMS from capturing
any continuations to the outside."
  (list #'%%push-subcont-barrier (list* #'lambda () forms)))

(defconstant +default-prompt+ 'default-prompt
  "This prompt is used for general coroutine-like use of continuations.")

;;; Condition System

;; Condition handling and restart handling share some similarities
;; while also being quite different in other respects.
;;
;; The main similarities between condition and restart handling are:
;;
;; * Both condition and restart handlers are arranged in
;;   dynamically-bound handler chains, consisting of individual
;;   handler frames.  Each frame binds a number of handlers.  We use
;;   two dynamic variables, `*condition-handler-frame?*' and
;;   `*restart-handler-frame?*', to point at the innermost frame of
;;   each chain.  Note that the variables hold options, as indicated
;;   by the question mark.
;;
;; * Signalling a condition and invoking a restart are very similar
;;   operations, in that a handler is looked up in the chain, and
;;   then its handler function is invoked.
;;
;; The main differences:
;;
;; * Conditions are classes organized in a type hierarchy
;;   (e.g. `type-error' as subtype of `error'), whereas restarts are
;;   plain names (e.g. `abort' and `continue').
;;
;; * A condition handler function always receives only a single
;;   argument, the condition, whereas a restart handler function
;;   receives any number of arguments passed to `invoke-restart'.
;;
;; * A condition handler function may decline handling a condition by
;;   returning normally instead of performing a nonlocal exit; this
;;   causes the search for a handler to continue.  In contrast, if a
;;   restart handler function returns normally, the restart is
;;   considered handled, and its result value is returned from
;;   `invoke-restart'.
;;
;; * A restart handler may optionally have an interactive function
;;   that prompts the user for arguments when the restart is invoked
;;   by `invoke-restart-interactively'.
;;
;; * A restart handler may optionally be associated with a list of
;;   conditions, to tell apart restarts belonging to different,
;;   concurrently signalled conditions.
;;
;; We follow the Common Lisp condition system quite closely
;; (including details like the condition firewall), with two
;; differences:
;;
;; 1) There is no `with-condition-restarts'.  Instead there is an
;;    additional keyword, `:associated-conditions', in the
;;    handler-specs of `restart-bind' and `restart-case' that
;;    establishes the associations.  Alternatively, `signal' and
;;    `error' also support the establishment of restart handlers
;;    associated with the signalled condition.
;;
;; 2) Every restart must have a non-nil name; anonymous restarts
;;    are not supported.

(defclass handler-frame ()
  (handlers
   parent-frame?)
  (:documentation "Instances of this class make up the condition and
restart handler chains.  Each frame stores a list of HANDLERS and an
optional PARENT-FRAME."))

(defclass condition-handler ()
  (condition-class
   handler-function)
  (:documentation "A condition handler is handling a particular
CONDITION-CLASS (can be `object' to handle all conditions).  The
HANDLER-FUNCTION receives a signalled condition as its single
argument."))

(defclass restart-handler ()
  (restart-name
   handler-function
   interactive-function?
   associated-conditions)
  (:documentation "A restart handler is handling a particular
RESTART-NAME.  The HANDLER-FUNCTION receives the arguments passed to
`invoke-restart'.  The optional INTERACTIVE-FUNCTION is called by
`invoke-restart-interactively' and should prompt the user for required
arguments.  The ASSOCIATED-CONDITIONS are a list of conditions with
which this handler is associated.  If the list is empty, the handler
is applicable to any condition.  If it's not empty, the handler is
applicable only to conditions in the list."))

(defdynamic *condition-handler-frame?* #nil
  "An option holding the innermost condition handler frame.")

(defdynamic *restart-handler-frame?* #nil
  "An option holding the innermost restart handler frame.")

(defun %make-handler-bind-operator (#'handler-spec-parser handler-frame-dynamic)
  "Metaprogramming utility to create `handler-bind' and `restart-bind'.

It is parameterized by a function that takes apart the handler
specifications of the `handler-bind' and `restart-bind' forms and
produces handlers from them, as well as the dynamic variable holding
the handler chain (the variable itself as a first class object, not
its value, so it can be used with `progv')."
  (vau (handler-specs . forms) env
    (let ((handler-frame (make-instance
                          (class handler-frame)
                          :handlers (mapcar (lambda (spec)
                                              (handler-spec-parser spec env))
                                            handler-specs)
                          :parent-frame? (dynamic handler-frame-dynamic))))
      (progv (list handler-frame-dynamic) (list (some handler-frame))
        (eval (list* #'progn forms) env)))))

(def #'handler-bind
  (%make-handler-bind-operator
   (lambda ((class-name function-form) env)
     (make-instance (class condition-handler)
                    :condition-class
                    (the class (find-class class-name env))
                    :handler-function
                    (the function (eval function-form env))))
   *condition-handler-frame?*)

  "Establish condition handlers specified by HANDLER-SPECS around FORMS.

$(fn (handler-specs . forms))
$(syntax handler-spec (condition-class handler-function))")

(def #'restart-bind
  (%make-handler-bind-operator
   (lambda ((restart-name function-form . properties) env)
     (make-instance (class restart-handler)
                    :restart-name
                    (the symbol restart-name)
                    :handler-function
                    (the function (eval function-form env))
                    :interactive-function?
                    (when-option (i-f-form (get? properties :interactive-function))
                      (some (the function (eval i-f-form env))))
                    :associated-conditions
                    (when-option (a-cs-form (get? properties :associated-conditions))
                      (the list (eval a-cs-form env)))))
   *restart-handler-frame?*)

  "Establish restart handlers specified by HANDLER-SPECS around FORMS.
You should usually prefer `restart-case'.

$(fn (handler-specs . forms))
$(syntax handler-spec (restart-name handler-function . properties))
$(syntax properties (&key interactive-function associated-conditions))")

(defun %make-handler-case-operator (#'handler-bind-operator)
  "Metaprogramming utility to create `handler-case'/`restart-case'
from `handler-bind'/`restart-bind'."
  (vau (handler-specs . forms) env
    (block exit
      ((block nested
         (eval (list #'handler-bind-operator
                     (mapcar (lambda ((name function-form . properties))
                               (list* name
                                      (lambda args
                                        (return-from nested
                                                     (lambda ()
                                                       (apply (eval function-form env) args))))
                                      properties))
                             handler-specs)
                     (list #'return-from exit (list* #'progn forms)))
               env))))))

(def #'handler-case (%make-handler-case-operator #'handler-bind)
  "Like `handler-bind', but the stack is unwound before a handler function is called.

$(fn (handler-specs . forms))")

(def #'restart-case (%make-handler-case-operator #'restart-bind)
  "Like `restart-bind', but the stack is unwound before a handler function is called.

$(fn (handler-specs . forms))")

(defun %error (condition)
  "Utility to signal the CONDITION.  If the condition is unhandled,
invoke the debugger.  Therefore never returns normally.  See `error'."
  (%signal condition)
  (invoke-debugger condition))

(defun invoke-debugger (condition)
  "Invoke the debugger, which currently just means panicking."
  (panic condition))

(defun %signal (condition)
  "Utility to signal the CONDITION.  If the signal is unhandled,
return void.  See `signal'."
  (loop-let -signal- ((handler-frame? (dynamic *condition-handler-frame?*)))
    ;; Payload to `%find-handler?' is always nil for condition handlers.
    (if-option ((handler frame) (%find-handler? condition handler-frame? #nil))
      (progn
        ;; Handler found; call it, passing along frame.
        (%call-condition-handler handler frame condition)
        ;; Signal unhandled: continue search for handlers.
        (-signal- (slot-value frame 'parent-frame?)))
      ;; No handler found, return void.
      #void)))

(defun %make-signal-with-restarts-operator (#'signal-operator)
  "Metaprogramming utility to create the `signal'/`error' operators
that take restart handler-specs from the `%signal'/`%error' ones that
don't."
  (vau (condition . handler-specs) env
    (let ((c (eval condition env)))
      (eval (list #'restart-case (mapcar (lambda (handler-spec)
                                           ;; Would be preferable to
                                           ;; adjoin `c' to the set of
                                           ;; any existing associated
                                           ;; conditions, then we
                                           ;; wouldn't need the rule
                                           ;; against supplying
                                           ;; `:associated-conditions'
                                           ;; to `signal'/`error'.
                                           (append
                                            handler-spec
                                            (list :associated-conditions (list #'list c))))
                                         handler-specs)
                  (list #'signal-operator c))
            env))))

(def #'signal (%make-signal-with-restarts-operator #'%signal)
  "Signal the CONDITION.  If the signal is unhandled, return void.

Restart handlers that are associated with the condition can be bound
as per `restart-case'.  The handlers should not specify the
`:associated-conditions' property, as it will be set automatically.

$(fn (condition . handler-specs))")

(def #'error (%make-signal-with-restarts-operator #'%error)
  "Signal the CONDITION.  If the condition is unhandled, invoke the
debugger.  Therefore never returns normally.

Restart handlers that are associated with the condition can be bound
as per `restart-case'.  The handlers should not specify the
`:associated-conditions' property, as it will be set automatically.

$(fn (condition . handler-specs))")

(defun %call-condition-handler (handler handler-frame condition)
  "Call a condition HANDLER's handler function with the given
CONDITION.  During the call, the condition handler chain gets swapped
to that chain that was active at the time the handler was established.
This is the so-called \"condition firewall\".  The chain gets passed
in as the value of HANDLER-FRAME."
  (dynamic-let ((*condition-handler-frame?* (slot-value handler-frame 'parent-frame?)))
    (%apply-handler-function handler (list condition))))

(defun %apply-handler-function (handler arguments)
  "Utility to call a condition or restart HANDLER's handler function
with a list of ARGUMENTS."
  (apply (slot-value handler 'handler-function) arguments))

(defun invoke-restart (restart-designator . arguments)
  "Invoke the restart designated by RESTART-DESIGNATOR, which can be a
symbol or a `restart-handler', with the given ARGUMENTS.  Signal an
error if the restart is not found."
  (%invoke-restart-with-arguments-producing-function
   restart-designator
   (lambda (#ignore) arguments)))

(defun invoke-restart-interactively (restart-designator)
  "Invoke the restart designated by RESTART-DESIGNATOR, which can be a
symbol or a `restart-handler', by prompting the user for arguments via
the restart's optional interactive function.  Signal an error if the
restart is not found."
  (%invoke-restart-with-arguments-producing-function
   restart-designator
   (lambda (restart-handler)
     (when-option (#'i-f (slot-value restart-handler 'interactive-function?))
       (i-f)))))

(defun %invoke-restart-with-arguments-producing-function (restart-designator #'function)
  "Utility to invoke the restart designated by RESTART-DESIGNATOR,
which can be a symbol or a `restart-handler', with an arguments list
produced by FUNCTION (which receives a `restart-handler' as argument)."
  (typecase restart-designator
    (symbol
     (if-option (restart-handler (find-restart? restart-designator))
       (%apply-handler-function restart-handler (function restart-handler))
       (error (make-restart-error restart-designator))))
    (restart-handler
     (%apply-handler-function restart-designator (function restart-designator)))
    (object
     (error (make-type-error restart-designator '(or symbol restart-handler))))))

(defun %find-handler? (object handler-frame? payload?)
  "Utility to find both condition handlers and restart handlers.

The OBJECT can be either a condition or a restart name.  The
HANDLER-FRAME is the handler frame where the search should start
(always the innermost handler frame at the start of the search).

Return an option of the found handler and the frame establishing it as
a two-element list.  The frame is needed so that we can access its
parent in the implementation of the condition firewall (see
`signal' and `%call-condition-handler').

The PAYLOAD? parameter can be used to pass in an optional condition if
we are looking for a restart handler (see `find-restart?').  If we are
looking for a condition handler, it is always nil."
  (when-option (handler-frame handler-frame?)
    (block found
      (dolist (handler (slot-value handler-frame 'handlers))
        (when (%handler-applicable-p handler object payload?)
          (return-from found (some (list handler handler-frame)))))
      (%find-handler? object (slot-value handler-frame 'parent-frame?) payload?))))

(defun find-restart? (name . condition?)
  "Find a restart handler by NAME, optionally limited to restarts
associated with a particular CONDITION."
  (when-option ((handler #ignore) (%find-handler?
                                   name
                                   (dynamic *restart-handler-frame?*)
                                   condition?))
    (some handler)))

(defgeneric %handler-applicable-p (handler object payload?)
  (:documentation "Return true if a condition or restart HANDLER is
applicable, false otherwise.  The OBJECT can be a condition or a
restart name.  The PAYLOAD? is only used for restart handlers, and
always nil for condition handlers."))

(defmethod %handler-applicable-p ((handler condition-handler) condition #nil)
  "A condition handler is applicable if the condition is an instance
of its condition class."
  (typep condition (slot-value handler 'condition-class)))

(defmethod %handler-applicable-p ((handler restart-handler) restart-name condition?)
  "A restart handler is applicable to a restart name and optional condition..."
  ;; ...if the restart name matches the handler's restart name, and...
  (and (eq restart-name (slot-value handler 'restart-name))
       ;; ...the handler is applicable to the condition.
       (%restart-handler-applicable-to-condition-p handler condition?)))

(defun %restart-handler-applicable-to-condition-p (handler condition?)
  "A restart handler is applicable to an optional condition..."
  (if-option (condition condition?)
    ;; ...if we are looking for restarts associated with a
    ;; particular condition...
    (let ((a-cs (slot-value handler 'associated-conditions)))
      (if (null a-cs)
          ;; ...if the restart handler is not associated with
          ;; particular conditions,...
          #t
          ;; ...or if the condition we are looking is one of the
          ;; handler's associated conditions.
          (memberp condition a-cs :test #'eq)))
    ;; ...if we are not looking for restarts associated with a
    ;; particular condition then every handler is applicable.
    #t))

(defun compute-restarts condition?
  "Return the list of currently active restarts, with most recently
established ones first, optionally limited to those that are
explicitly associated with the supplied CONDITION or not associated
with any condition."
  (loop-let -compute-restarts- ((handler-frame? (dynamic *restart-handler-frame?*))
                                (handlers ()))
    (if-option (handler-frame handler-frame?)
      (-compute-restarts- (slot-value handler-frame 'parent-frame?)
                          (append handlers
                                  (remove-if-not
                                   (lambda (handler)
                                     (%restart-handler-applicable-to-condition-p handler condition?))
                                   (slot-value handler-frame 'handlers))))
      handlers)))

(defclass restart-error (error)
  (restart-name)
  (:documentation "Signalled when no handler for RESTART-NAME is found."))

(defun make-restart-error (restart-name)
  "Create a new `restart-error' for the given RESTART-NAME."
  (make-instance (class restart-error) :restart-name restart-name))

(defclass simple-error (error)
  (message)
  (:documentation "Class for simple errors with a MESSAGE."))

(defun make-simple-error (message)
  "Create a new simple error with a MESSAGE."
  (make-instance (class simple-error) :message message))
