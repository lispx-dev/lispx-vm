;;; Test Utilities

;; Import Mocha test framework functions from the global scope.
(def #'mocha:describe (to-lisp-function (js-global "describe")))
(def #'mocha:it (to-lisp-function (js-global "it")))
(def #'mocha:before (to-lisp-function (js-global "before")))
(def #'mocha:after (to-lisp-function (js-global "after")))

(defexpr deftest (name expression . expected?) env
  "Run the EXPRESSION as a test identified by NAME and compare its
result to an EXPECTED value (which defaults to true).  Tests may
capture a continuation to the default prompt."
  (mocha:it
   (to-js-string (symbol-name name))
   (js-lambda ()
     ;; Push the default prompt for asynchronous tests.
     ;;
     ;; Note that this is quite subtle: when an asynchronous test
     ;; captures to this prompt, it returns a promise here.  This
     ;; promise is returned to Mocha, which does the right thing (wait
     ;; for it to resolve).
     (push-prompt +default-prompt+
       ;; Test and expected expressions are evaluated in fresh child
       ;; environments of the current environment, so that bindings
       ;; they create don't affect other tests.
       (assert (= (eval expression (make-environment env))
                  (eval (optional expected? #t) (make-environment env))))))))

(defexpr defsection (name . forms) env
  "Evaluate FORMS as a group of tests identified by NAME.  Currently
just sequential execution, but might get other functionality like
setup and teardown functions for the whole section in the future.  The
forms must not capure any continuations."
  (mocha:describe
   (to-js-string (symbol-name name))
   (js-lambda ()
     ;; We don't push a prompt here.  The reason is that Mocha
     ;; describe() doesn't support promises anyway.  So any Lisp code
     ;; that tries to capture a continuation directly inside a section
     ;; will get a "prompt not found" error.
     (eval (list* #'progn forms) env))))

(defexpr before forms env
  "Evaluate forms before all tests in the suite.  The forms may
capture a continuation to the default prompt."
  (mocha:before
   (js-lambda ()
     (push-prompt 'default-prompt
       (eval (list* #'progn forms) env)))))

(defexpr after forms env
  "Evaluate forms after all tests in the suite.  The forms may
capture a continuation to the default prompt."
  (mocha:after
   (js-lambda ()
     (push-prompt 'default-prompt
       (eval (list* #'progn forms) env)))))

(defexpr signals-error (form condition-class . slot-specs) env
  "Evaluate the FORM and assert that it signals a condition of the
given CONDITION-CLASS.  Expected slots of the condition can be
specified by SLOT-SPECS (a plist) and will be compared against the
slots of the signalled condition."
  (let ((class (find-class condition-class env)))
    (block exit
      (handler-bind ((object (lambda (c)
                               (if (typep c class)
                                   (progn
                                     (loop-let -check-slots- ((slot-specs slot-specs))
                                       (when (not (null slot-specs))
                                         (let (((name value . rest-slot-specs) slot-specs))
                                           (unless (= (slot-value c name) (eval value env))
                                             (return-from exit #f))
                                           (-check-slots- rest-slot-specs))))
                                     (return-from exit #t))
                                   (return-from exit #f)))))
        (eval form env))
      #f)))

(defexpr with-standard-input-from-string (string . forms) env
  "Evaluate FORMS with `*standard-input*' coming from STRING."
  (let ((s (eval string env)))
    (dynamic-let ((*standard-input* (make-string-input-stream s)))
      (eval (list* #'progn forms) env))))

(defexpr with-standard-output-to-string forms env
  "Evaluate FORMS with `*standard-output*' being collected in a string."
  (dynamic-let ((*standard-output* (make-string-output-stream)))
    (eval (list* #'progn forms) env)
    (get-output-stream-string (dynamic *standard-output*))))
