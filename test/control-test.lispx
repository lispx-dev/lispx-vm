;;; Control-related Tests

;;; Coroutines

;; The following implementation of coroutines follows the one at URL
;; `http://okmij.org/ftp/continuations/implementations.html#dynamic-wind'
;;
;; We use it for testing that built-in operators properly suspend and
;; resume.

(defconstant +coroutine-prompt+ 'coroutine-prompt
  "The prompt used for delimiting coroutines.")

(defclass yield-record ()
  (value continuation)
  (:documentation "Instances of this class are yielded."))

(defun make-yield-record (v k)
  "Create a new yield record with the given yielded value and resume continuation."
  (make-instance (class yield-record) :value v :continuation k))

(defun yield v?
  "Yield a value (which defaults to void)."
  (take-subcont +coroutine-prompt+ k
    (make-yield-record (optional v?) k)))

(defun resume (yield-record . v?)
  "Resume a suspended coroutine with a value (which defaults to void)."
  (push-delim-subcont +coroutine-prompt+ (slot-value yield-record 'continuation)
    (optional v?)))

(defmacro coroutine body
  "Evaluate the body expressions as a coroutine."
  (list* #'push-prompt '+coroutine-prompt+ body))

(defun run-coroutine (#'thunk)
  "Get all values yielded by a coroutine, and its final result, and
collect them in a list."
  (loop-let -run- ((result (coroutine (thunk))))
    (if (typep result (class yield-record))
        (cons (slot-value result 'value) (-run- (resume result)))
        (list result))))

(defun run-coroutine-with-values (#'thunk values)
  "Like `run-coroutine' but uses a list of values that are sent to the
coroutine with `resume'."
  (loop-let -run- ((result (coroutine (thunk))) (values values))
    (if (typep result (class yield-record))
        (cons (slot-value result 'value)
              (-run- (resume result (car values)) (cdr values)))
        (list result))))

(defsuite coroutines

  (deftest coroutine.1
    (coroutine 1 2 (= 1 1))
    #t)

  (deftest coroutine.2
    (progn
      (def yield-record (coroutine 1 2 (+ (yield (= 1 1)) 3)))
      (assert (typep yield-record (class yield-record)))
      (assert (= #t (slot-value yield-record 'value)))
      (assert (= 33 (resume yield-record 30))))
    #void)

  (deftest coroutine.progn.1
    (run-coroutine
     (lambda ()
       (progn
         (yield 1)
         (yield 2)
         3)))
    '(1 2 3))

  (deftest coroutine.progn.2
    (run-coroutine-with-values
     (lambda ()
       (progn
         (yield 1)
         (yield 2)))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.vau.1
    (run-coroutine
     (lambda ()
       ((vau () #ignore
          (yield 1)
          (yield 2)
          3))))
    '(1 2 3))

  (deftest coroutine.vau.2
    (run-coroutine-with-values
     (lambda ()
       ((vau () #ignore
          (yield 1)
          (yield 2))))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.lambda.1
    (run-coroutine
     (lambda ()
       ((lambda ()
          (yield 1)
          (yield 2)
          3))))
    '(1 2 3))

  (deftest coroutine.lambda.2
    (run-coroutine-with-values
     (lambda ()
       ((lambda ()
          (yield 1)
          (yield 2))))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.def.1
    (run-coroutine
     (lambda ()
       (def (x y) (list (yield 1) (yield 2)))
       (list x y)))
    '(1 2 (#void #void)))

  (deftest coroutine.def.2
    (run-coroutine-with-values
     (lambda ()
       (def (x y) (list (yield 1) (yield 2)))
       (list x y))
     '(3 4))
    '(1 2 (3 4)))

  (deftest coroutine.if.1
    (run-coroutine
     (lambda ()
       (if #t (yield 1) (yield 2))))
    '(1 #void))

  (deftest coroutine.if.2
    (run-coroutine-with-values
     (lambda ()
       (if #t (yield 1) (yield 2)))
     '(3))
    '(1 3))

  (deftest coroutine.if.3
    (run-coroutine
     (lambda ()
       (if #f (yield 1) (yield 2))))
    '(2 #void))

  (deftest coroutine.if.4
    (run-coroutine-with-values
     (lambda ()
       (if #f (yield 1) (yield 2)))
     '(3))
    '(2 3))

  (deftest coroutine.if.5
    (run-coroutine-with-values
     (lambda ()
       (if (yield 1) (yield 2) (yield 3)))
     '(#t 4))
    '(1 2 4))

  (deftest coroutine.if.6
    (run-coroutine-with-values
     (lambda ()
       (if (yield 1) (yield 2) (yield 3)))
     '(#f 4))
    '(1 3 4))

  (deftest coroutine.if.7
    (run-coroutine-with-values
     (lambda ()
       (if (progn (yield 1) (yield 2))
           (progn (yield 3) (yield 3.5))
           (progn (yield 4) (yield 4.5))))
     '(#void #t #void 5))
    '(1 2 3 3.5 5))

  (deftest coroutine.if.8
    (run-coroutine-with-values
     (lambda ()
       (if (progn (yield 1) (yield 2))
           (progn (yield 3) (yield 3.5))
           (progn (yield 4) (yield 4.5))))
     '(#void #f #void 5))
    '(1 2 4 4.5 5))

  (deftest coroutine.loop.1
    (run-coroutine
     (lambda ()
       (def ct 1)
       (def env (the-environment))
       (block exit
         (loop
          (if (= ct 5)
              (return-from exit ct)
              (progn
                (yield ct)
                (yield (- ct))
                (set env ct (+ ct 1))))))))
    '(1 -1 2 -2 3 -3 4 -4 5))

  (deftest coroutine.block.1
    (run-coroutine
     (lambda ()
       (block b
         (yield 1)
         (yield 2)
         3)))
    '(1 2 3))

  (deftest coroutine.block.2
    (run-coroutine-with-values
     (lambda ()
       (block b
         (yield 1)
         (yield 2)))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.block.3
    (run-coroutine
     (lambda ()
       (block b
         (yield 1)
         (yield 2)
         (return-from b 3))))
    '(1 2 3))

  (deftest coroutine.block.4
    (run-coroutine-with-values
     (lambda ()
       (block b
         (yield 1)
         (return-from b (yield 2))))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.catch.1
    (run-coroutine
     (lambda ()
       (catch 'b
         (yield 1)
         (yield 2)
         3)))
    '(1 2 3))

  (deftest coroutine.catch.2
    (run-coroutine-with-values
     (lambda ()
       (catch 'b
         (yield 1)
         (yield 2)))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.catch.3
    (run-coroutine
     (lambda ()
       (catch 'b
         (yield 1)
         (yield 2)
         (throw 'b 3))))
    '(1 2 3))

  (deftest coroutine.catch.4
    (run-coroutine-with-values
     (lambda ()
       (catch 'b
         (yield 1)
         (throw 'b (yield 2))))
     '(#void 3))
    '(1 2 3))

  (deftest coroutine.unwind-protect.1
    (run-coroutine-with-values
     (lambda ()
       (unwind-protect (yield 1)
         (yield 2)
         (yield 2.5)
         3))
     '(4 #void #void))
    '(1 2 2.5 4))

  (deftest coroutine.unwind-protect.2
    (run-coroutine-with-values
     (lambda ()
       (block exit
         (unwind-protect (return-from exit (yield 1))
           (yield 2)
           (yield 2.5)
           3)))
     '(4 #void #void))
    '(1 2 2.5 4))

  (deftest coroutine.unwind-protect.3
    (run-coroutine-with-values
     (lambda ()
       (block exit
         (unwind-protect (return-from exit 4)
           (yield 2)
           (yield 2.5)
           3)))
     '(#void #void))
    '(2 2.5 4))

  (deftest coroutine.unwind-protect.4
    (run-coroutine-with-values
     (lambda ()
       (block exit
         (unwind-protect (progn (yield 1) (yield 1.5))
           (yield 2)
           (yield 2.5)
           3)))
     '(#void 4 #void #void))
    '(1 1.5 2 2.5 4))

  (deftest coroutine.progv.1
    (run-coroutine
     (lambda ()
       (defdynamic *x*)
       (progv (list *x*) (list 1)
         (yield (dynamic *x*))
         (yield (dynamic *x*))
         (progv (list *x*) (list 2)
           (yield (dynamic *x*))
           (yield (dynamic *x*))
           3))))
    '(1 1 2 2 3))

  (deftest coroutine.progv.2
    (run-coroutine-with-values
     (lambda ()
       (defdynamic *x*)
       (progv (list *x*) (list 1)
         (yield (dynamic *x*))
         (yield (dynamic *x*))
         (progv (list *x*) (list 2)
           (yield (dynamic *x*))
           (yield (dynamic *x*)))))
     '(#void #void #void 3))
    '(1 1 2 2 3))

  (deftest coroutine.fun.1
    (run-coroutine
     (lambda ()
       (list (yield 1) (yield 2))))
    '(1 2 (#void #void)))

  (deftest coroutine.fun.2
    (run-coroutine-with-values
     (lambda () (list (yield 1) (yield 2)))
     '(3 4))
    '(1 2 (3 4))))

;;; Basic Operator Tests

(defsuite push-prompt

  (deftest push-prompt.1
    (signals-error
     (push-prompt)
     match-error))

  (deftest push-prompt.2
    (push-prompt 'p)
    #void)

  (deftest push-prompt.3
    (push-prompt 'p 1 2 (= 1 1))
    #t)

  (deftest push-prompt.4
    (progn
      (block ret
        (push-prompt 'p
          (assert (prompt-set-p 'p))
          (return-from ret)))
      (assert (not (prompt-set-p 'p))))
    #void)

  (deftest push-prompt.5
    (progn
      (assert (not (prompt-set-p 'p)))
      (assert (not (prompt-set-p 'q)))
      (push-prompt 'p
        (assert (prompt-set-p 'p))
        (assert (not (prompt-set-p 'q)))
        (push-prompt 'q
          (assert (prompt-set-p 'p))
          (assert (prompt-set-p 'q)))
        (assert (prompt-set-p 'p))
        (assert (not (prompt-set-p 'q))))
      (assert (not (prompt-set-p 'p)))
      (assert (not (prompt-set-p 'q))))
    #void))

(defsuite take-subcont

  (deftest take-subcont.1
    (signals-error
     (take-subcont)
     match-error))

  (deftest take-subcont.2
    (signals-error
     (take-subcont 'p)
     match-error))

  (deftest take-subcont.3
    (signals-error
     (take-subcont 'p #ignore)
     prompt-not-found-error :prompt 'p))

  (deftest take-subcont.4
    (signals-error
     (push-prompt 'p (take-subcont 'q #ignore))
     prompt-not-found-error :prompt 'q))

  (deftest take-subcont.5
    (push-prompt 'p (take-subcont 'p #ignore))
    #void)

  (deftest take-subcont.6
    (push-prompt 'p (take-subcont 'p #ignore (= 1 1)))
    #t)

  (deftest take-subcont.7
    (push-prompt 'p (take-subcont 'p k (push-delim-subcont 'p k (= 1 1))))
    #t))

(defsuite push-delim-subcont

  (deftest push-delim-subcont.1
    (signals-error
     (push-delim-subcont)
     match-error))

  (deftest push-delim-subcont.2
    (signals-error
     (push-delim-subcont 'p)
     match-error))

  (deftest push-delim-subcont.3
    (signals-error
     (push-delim-subcont 'p 12)
     type-error :datum 12))

  (deftest push-delim-subcont.4
    (let ((k (push-prompt 'p (+ 100 (take-subcont 'p k k)))))
      (assert (= 102 (push-delim-subcont 'p k (+ 1 1))))
      (assert (= 120 (push-delim-subcont 'p k (+ 10 10)))))
    #void)

  (deftest push-delim-subcont.5
    (let ((k (push-prompt 'p (push-prompt 'q (take-subcont 'p k k)))))
      (push-delim-subcont 'p k
        (assert (prompt-set-p 'q))
        (assert (prompt-set-p 'p))))
    #void))

(defsuite prompt-set-p

  (deftest prompt-set-p.1
    (signals-error
     (prompt-set-p)
     match-error))

  (deftest prompt-set-p.2
    (prompt-set-p 'p)
    #f)

  (deftest prompt-set-p.3
    (push-prompt 'p (progn (prompt-set-p 'p)))
    #t))

(defsuite push-subcont-barrier

  (deftest push-subcont-barrier.1
    (signals-error
     (push-subcont-barrier
      (take-subcont 'p1 sk))
     prompt-not-found-error :prompt 'p1))

  (deftest push-subcont-barrier.2
    (signals-error
     (push-prompt 'p1
       (push-subcont-barrier
         (take-subcont 'p1 sk)))
     prompt-not-found-error :prompt 'p1)))

(defsuite dynamics

  (deftest defdynamic.1
    (progn
      (defdynamic *x* 1)
      (defdynamic *y* 2)
      (assert (= (dynamic *x*) 1))
      (assert (= (dynamic *y*) 2))
      (dynamic-let ((*x* 3))
        (assert (= (dynamic *x*) 3))
        (assert (= (dynamic *y*) 2))
        (dynamic-let ((*y* 4))
          (assert (= (dynamic *x*) 3))
          (assert (= (dynamic *y*) 4)))
        (assert (= (dynamic *x*) 3))
        (assert (= (dynamic *y*) 2)))
      (assert (= (dynamic *x*) 1))
      (assert (= (dynamic *y*) 2)))
    #void)

  (deftest progv.1
    (progn
      (defdynamic *x* 1)
      (defdynamic *y* 2)
      (assert (= (dynamic *x*) 1))
      (assert (= (dynamic *y*) 2))
      (progv (list *x*) (list 3)
        (assert (= (dynamic *x*) 3))
        (assert (= (dynamic *y*) 2))
        (progv (list *y*) (list 4)
          (assert (= (dynamic *x*) 3))
          (assert (= (dynamic *y*) 4)))
        (assert (= (dynamic *x*) 3))
        (assert (= (dynamic *y*) 2)))
      (assert (= (dynamic *x*) 1))
      (assert (= (dynamic *y*) 2)))
    #void)

  (deftest dynamic.1
    (progn
      (defdynamic *foo*)
      (assert (= (dynamic *foo*) #void))
      (assert (= (slot-value *foo* 'value) #void))
      (assert (typep *foo* (class dynamic)))
      (assert (typep *foo* (class standard-object)))
      (assert (typep *foo* (class object)))
      (assert (subclassp (class dynamic) (class standard-object)))
      (assert (subclassp (class dynamic) (class object))))
    #void)

  (deftest set-dynamic.1
    (progn
      (defdynamic *bar*)
      (dynamic-let ((*bar* 1))
        (set-dynamic *bar* 2)
        (assert (= 2 (dynamic *bar*)))
        (dynamic-let ((*bar* 3))
          (assert (= 3 (dynamic *bar*))))
        (assert (= 2 (dynamic *bar*)))
        (set-dynamic *bar* 4)
        (assert (= 4 (dynamic *bar*))))
      (assert (= #void (dynamic *bar*)))
      #t))

  (deftest dynamic-let*.1
    (dynamic-let* () (+ 1 1))
    2)

  (deftest dynamic-let*.2
    (progn
      (defdynamic *x* 1)
      (dynamic-let* ((*x* 2)) (+ 1 (dynamic *x*))))
    3)

  (deftest dynamic-let*.2
    (progn
      (defdynamic *x* 1)
      (defdynamic *y* 0)
      (dynamic-let* ((*x* 2) (*y* (+ (dynamic *x*) 1)))
        (list (dynamic *x*) (dynamic *y*))))
    '(2 3))

  (deftest dynamic-let-sanity-check
    (progn
      (defdynamic *x* 1)
      (defdynamic *y* 0)
      (dynamic-let ((*x* 2) (*y* (+ (dynamic *x*) 1)))
        (list (dynamic *x*) (dynamic *y*))))
    '(2 2)))

(defsuite default-prompt

  (deftest |Default prompt exists|
    (boundp '+default-prompt+ (the-environment))))

;;; Simple Control Operators

(defsuite loop

  (deftest loop.1
    (let ((ct 0))
      (def env (the-environment))
      (block exit
        (loop 'just-a-symbol-to-test-implicit-progn
              (if (= ct 10)
                  (return-from exit ct)
                  (set env ct (+ ct 1))))))
    10))

(defsuite catch/throw

  (deftest catch.1
    (signals-error
     (catch)
     match-error))

  (deftest catch.2
    (catch 'x)
    #void)

  (deftest catch.3
    (catch 'x 1 2 3 (= 1 1))
    #t)

  (deftest catch.4
    (catch 'x 1 (throw 'x (= 1 2)) 3 (= 1 1))
    #f)

  (deftest catch.5
    (catch 'x 1 (throw 'x) 3 (= 1 1))
    #void)

  (deftest catch.6
    (catch 'x 1 (catch 'y (throw 'x 44)) 3 (= 1 1))
    44)

  (deftest catch.7
    (catch 'x 1 (catch 'y (throw 'y 2)) 3 55)
    55)

  (deftest catch.8
    (catch 'x 1 (catch 'y (throw 'y 2)))
    2)

  (deftest catch.9
    (catch 'x 1 (catch 'y (throw 'y)))
    #void))

(defsuite block/return-from

  (deftest block.1
    (signals-error
     (block)
     match-error))

  (deftest block.2
    (block x)
    #void)

  (deftest block.3
    (block x 1 2 3 (= 1 1))
    #t)

  (deftest block.4
    (block x 1 (return-from x (= 1 2)) 3 (= 1 1))
    #f)

  (deftest block.5
    (block x 1 (return-from x) 3 (= 1 1))
    #void)

  (deftest block.6
    (block x 1 (block y (return-from x (= 1 2))) 3 (= 1 1))
    #f)

  (deftest block.7
    (block x 1 (block y (return-from y 2)) 3 (= 1 1))
    #t)

  (deftest block.8
    (block x 1 (block y (return-from y 2)))
    2)

  (deftest block.9
    (block x 1 (block y (return-from y)))
    #void))

(defsuite unwind-protect

  (deftest unwind-protect.1
    (signals-error
     (unwind-protect)
     match-error))

  (deftest unwind-protect.2
    (unwind-protect (= 1 1))
    #t)

  (deftest unwind-protect.3
    (progn
      (def env (the-environment))
      (+ (unwind-protect 1 2 3 (set env x 10))
         x))
    11)

  (deftest unwind-protect.4
    (progn
      (def env (the-environment))
      (+ (block exit
           (unwind-protect (return-from exit 1) 2 3 (set env x 10)))
         x))
    11)

  (deftest unwind-protect.5
    (block exit
      (unwind-protect 1 2 3 (return-from exit 4)))
    4)

  (deftest unwind-protect.6
    (block exit
      (unwind-protect (return-from exit 1) 2 3 (return-from exit 4)))
    4))
