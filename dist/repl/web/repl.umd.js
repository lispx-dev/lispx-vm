!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["lispx-repl"]=t():e["lispx-repl"]=t()}(this,(()=>(()=>{"use strict";var e={r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t);var n=1e6,r=1e6,s="[big.js] ",o=s+"Invalid ",i=o+"decimal places",a=o+"rounding mode",l=s+"Division by zero",c={},u=void 0,d=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function _(e,t,n,r){var s=e.c;if(n===u&&(n=e.constructor.RM),0!==n&&1!==n&&2!==n&&3!==n)throw Error(a);if(t<1)r=3===n&&(r||!!s[0])||0===t&&(1===n&&s[0]>=5||2===n&&(s[0]>5||5===s[0]&&(r||s[1]!==u))),s.length=1,r?(e.e=e.e-t+1,s[0]=1):s[0]=e.e=0;else if(t<s.length){if(r=1===n&&s[t]>=5||2===n&&(s[t]>5||5===s[t]&&(r||s[t+1]!==u||1&s[t-1]))||3===n&&(r||!!s[0]),s.length=t,r)for(;++s[--t]>9;)if(s[t]=0,0===t){++e.e,s.unshift(1);break}for(t=s.length;!s[--t];)s.pop()}return e}function p(e,t,n){var r=e.e,s=e.c.join(""),o=s.length;if(t)s=s.charAt(0)+(o>1?"."+s.slice(1):"")+(r<0?"e":"e+")+r;else if(r<0){for(;++r;)s="0"+s;s="0."+s}else if(r>0)if(++r>o)for(r-=o;r--;)s+="0";else r<o&&(s=s.slice(0,r)+"."+s.slice(r));else o>1&&(s=s.charAt(0)+"."+s.slice(1));return e.s<0&&n?"-"+s:s}c.abs=function(){var e=new this.constructor(this);return e.s=1,e},c.cmp=function(e){var t,n=this,r=n.c,s=(e=new n.constructor(e)).c,o=n.s,i=e.s,a=n.e,l=e.e;if(!r[0]||!s[0])return r[0]?o:s[0]?-i:0;if(o!=i)return o;if(t=o<0,a!=l)return a>l^t?1:-1;for(i=(a=r.length)<(l=s.length)?a:l,o=-1;++o<i;)if(r[o]!=s[o])return r[o]>s[o]^t?1:-1;return a==l?0:a>l^t?1:-1},c.div=function(e){var t=this,r=t.constructor,s=t.c,o=(e=new r(e)).c,a=t.s==e.s?1:-1,c=r.DP;if(c!==~~c||c<0||c>n)throw Error(i);if(!o[0])throw Error(l);if(!s[0])return e.s=a,e.c=[e.e=0],e;var d,p,f,m,b,h=o.slice(),y=d=o.length,g=s.length,v=s.slice(0,d),w=v.length,j=e,k=j.c=[],E=0,x=c+(j.e=t.e-e.e)+1;for(j.s=a,a=x<0?0:x,h.unshift(0);w++<d;)v.push(0);do{for(f=0;f<10;f++){if(d!=(w=v.length))m=d>w?1:-1;else for(b=-1,m=0;++b<d;)if(o[b]!=v[b]){m=o[b]>v[b]?1:-1;break}if(!(m<0))break;for(p=w==d?o:h;w;){if(v[--w]<p[w]){for(b=w;b&&!v[--b];)v[b]=9;--v[b],v[w]+=10}v[w]-=p[w]}for(;!v[0];)v.shift()}k[E++]=m?f:++f,v[0]&&m?v[w]=s[y]||0:v=[s[y]]}while((y++<g||v[0]!==u)&&a--);return k[0]||1==E||(k.shift(),j.e--,x--),E>x&&_(j,x,r.RM,v[0]!==u),j},c.eq=function(e){return 0===this.cmp(e)},c.gt=function(e){return this.cmp(e)>0},c.gte=function(e){return this.cmp(e)>-1},c.lt=function(e){return this.cmp(e)<0},c.lte=function(e){return this.cmp(e)<1},c.minus=c.sub=function(e){var t,n,r,s,o=this,i=o.constructor,a=o.s,l=(e=new i(e)).s;if(a!=l)return e.s=-l,o.plus(e);var c=o.c.slice(),u=o.e,d=e.c,_=e.e;if(!c[0]||!d[0])return d[0]?e.s=-l:c[0]?e=new i(o):e.s=1,e;if(a=u-_){for((s=a<0)?(a=-a,r=c):(_=u,r=d),r.reverse(),l=a;l--;)r.push(0);r.reverse()}else for(n=((s=c.length<d.length)?c:d).length,a=l=0;l<n;l++)if(c[l]!=d[l]){s=c[l]<d[l];break}if(s&&(r=c,c=d,d=r,e.s=-e.s),(l=(n=d.length)-(t=c.length))>0)for(;l--;)c[t++]=0;for(l=t;n>a;){if(c[--n]<d[n]){for(t=n;t&&!c[--t];)c[t]=9;--c[t],c[n]+=10}c[n]-=d[n]}for(;0===c[--l];)c.pop();for(;0===c[0];)c.shift(),--_;return c[0]||(e.s=1,c=[_=0]),e.c=c,e.e=_,e},c.mod=function(e){var t,n=this,r=n.constructor,s=n.s,o=(e=new r(e)).s;if(!e.c[0])throw Error(l);return n.s=e.s=1,t=1==e.cmp(n),n.s=s,e.s=o,t?new r(n):(s=r.DP,o=r.RM,r.DP=r.RM=0,n=n.div(e),r.DP=s,r.RM=o,this.minus(n.times(e)))},c.neg=function(){var e=new this.constructor(this);return e.s=-e.s,e},c.plus=c.add=function(e){var t,n,r,s=this,o=s.constructor;if(e=new o(e),s.s!=e.s)return e.s=-e.s,s.minus(e);var i=s.e,a=s.c,l=e.e,c=e.c;if(!a[0]||!c[0])return c[0]||(a[0]?e=new o(s):e.s=s.s),e;if(a=a.slice(),t=i-l){for(t>0?(l=i,r=c):(t=-t,r=a),r.reverse();t--;)r.push(0);r.reverse()}for(a.length-c.length<0&&(r=c,c=a,a=r),t=c.length,n=0;t;a[t]%=10)n=(a[--t]=a[t]+c[t]+n)/10|0;for(n&&(a.unshift(n),++l),t=a.length;0===a[--t];)a.pop();return e.c=a,e.e=l,e},c.pow=function(e){var t=this,n=new t.constructor("1"),s=n,i=e<0;if(e!==~~e||e<-1e6||e>r)throw Error(o+"exponent");for(i&&(e=-e);1&e&&(s=s.times(t)),e>>=1;)t=t.times(t);return i?n.div(s):s},c.prec=function(e,t){if(e!==~~e||e<1||e>n)throw Error(o+"precision");return _(new this.constructor(this),e,t)},c.round=function(e,t){if(e===u)e=0;else if(e!==~~e||e<-n||e>n)throw Error(i);return _(new this.constructor(this),e+this.e+1,t)},c.sqrt=function(){var e,t,n,r=this,o=r.constructor,i=r.s,a=r.e,l=new o("0.5");if(!r.c[0])return new o(r);if(i<0)throw Error(s+"No square root");0===(i=Math.sqrt(r+""))||i===1/0?((t=r.c.join("")).length+a&1||(t+="0"),a=((a+1)/2|0)-(a<0||1&a),e=new o(((i=Math.sqrt(t))==1/0?"5e":(i=i.toExponential()).slice(0,i.indexOf("e")+1))+a)):e=new o(i+""),a=e.e+(o.DP+=4);do{n=e,e=l.times(n.plus(r.div(n)))}while(n.c.slice(0,a).join("")!==e.c.slice(0,a).join(""));return _(e,(o.DP-=4)+e.e+1,o.RM)},c.times=c.mul=function(e){var t,n=this,r=n.constructor,s=n.c,o=(e=new r(e)).c,i=s.length,a=o.length,l=n.e,c=e.e;if(e.s=n.s==e.s?1:-1,!s[0]||!o[0])return e.c=[e.e=0],e;for(e.e=l+c,i<a&&(t=s,s=o,o=t,c=i,i=a,a=c),t=new Array(c=i+a);c--;)t[c]=0;for(l=a;l--;){for(a=0,c=i+l;c>l;)a=t[c]+o[l]*s[c-l-1]+a,t[c--]=a%10,a=a/10|0;t[c]=a}for(a?++e.e:t.shift(),l=t.length;!t[--l];)t.pop();return e.c=t,e},c.toExponential=function(e,t){var r=this,s=r.c[0];if(e!==u){if(e!==~~e||e<0||e>n)throw Error(i);for(r=_(new r.constructor(r),++e,t);r.c.length<e;)r.c.push(0)}return p(r,!0,!!s)},c.toFixed=function(e,t){var r=this,s=r.c[0];if(e!==u){if(e!==~~e||e<0||e>n)throw Error(i);for(e=e+(r=_(new r.constructor(r),e+r.e+1,t)).e+1;r.c.length<e;)r.c.push(0)}return p(r,!1,!!s)},c[Symbol.for("nodejs.util.inspect.custom")]=c.toJSON=c.toString=function(){var e=this,t=e.constructor;return p(e,e.e<=t.NE||e.e>=t.PE,!!e.c[0])},c.toNumber=function(){var e=Number(p(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(e.toString()))throw Error(s+"Imprecise conversion");return e},c.toPrecision=function(e,t){var r=this,s=r.constructor,i=r.c[0];if(e!==u){if(e!==~~e||e<1||e>n)throw Error(o+"precision");for(r=_(new s(r),e,t);r.c.length<e;)r.c.push(0)}return p(r,e<=r.e||r.e<=s.NE||r.e>=s.PE,!!i)},c.valueOf=function(){var e=this,t=e.constructor;if(!0===t.strict)throw Error(s+"valueOf disallowed");return p(e,e.e<=t.NE||e.e>=t.PE,!0)};var f=function e(){function t(n){var r=this;if(!(r instanceof t))return n===u?e():new t(n);if(n instanceof t)r.s=n.s,r.e=n.e,r.c=n.c.slice();else{if("string"!=typeof n){if(!0===t.strict&&"bigint"!=typeof n)throw TypeError(o+"value");n=0===n&&1/n<0?"-0":String(n)}!function(e,t){var n,r,s;if(!d.test(t))throw Error(o+"number");e.s="-"==t.charAt(0)?(t=t.slice(1),-1):1,(n=t.indexOf("."))>-1&&(t=t.replace(".",""));(r=t.search(/e/i))>0?(n<0&&(n=r),n+=+t.slice(r+1),t=t.substring(0,r)):n<0&&(n=t.length);for(s=t.length,r=0;r<s&&"0"==t.charAt(r);)++r;if(r==s)e.c=[e.e=0];else{for(;s>0&&"0"==t.charAt(--s););for(e.e=n-r-1,e.c=[],n=0;r<=s;)e.c[n++]=+t.charAt(r++)}}(r,n)}r.constructor=t}return t.prototype=c,t.DP=20,t.RM=1,t.NE=-7,t.PE=21,t.strict=false,t.roundDown=0,t.roundHalfUp=1,t.roundHalfEven=2,t.roundUp=3,t}();const m=f;function b(e){e.eval=(t,n=e.get_user_environment())=>e.trap_exceptions((()=>(e.assert_type(n,e.Environment),t instanceof e.Symbol?function(t,n){return t.get_namespace()===e.KEYWORD_NAMESPACE?t:n.lookup(t)}(t,n):t instanceof e.Cons?function(t,n){return e.bind((()=>function(t,n){return t instanceof e.Symbol?e.trap_exceptions((()=>n.lookup(t.to_function_symbol()))):e.eval(t,n)}(t.car(),n)),(r=>e.operate(r,t.cdr(),n)),e.trace(t.car(),n))}(t,n):t))),e.operate=(t,n,r=e.get_user_environment())=>e.trap_exceptions((()=>(e.assert_type(t,e.Operator),e.assert_type(n,e.TYPE_ANY),e.assert_type(r,e.Environment),t.operate(n,r))));const t=e.type_or(e.Symbol,e.Ignore),n=e.type_or(e.Symbol,e.Ignore,e.List);e.match=(t,r,s)=>{if(t instanceof e.Symbol)if(t.get_namespace()===e.KEYWORD_NAMESPACE){if(t!==r)throw new e.Match_error(t,r)}else s.put(t,r);else if(t instanceof e.Cons){if(!(r instanceof e.Cons))throw new e.Match_error(t,r);e.match(t.car(),r.car(),s),e.match(t.cdr(),r.cdr(),s)}else if(t===e.nil()){if(r!==e.nil())throw new e.Match_error(t,r)}else if(t!==e.ignore())throw e.make_type_error(t,n);return r},e.Match_error=class extends e.Error{constructor(t,n){super("Match error: "+e.write_to_js_string(t)+" vs "+e.write_to_js_string(n)),this.lisp_slot_definiend=t,this.lisp_slot_value=n}},e.Operator=class extends e.Object{operate(t,n){e.abstract_method()}},e.Fexpr=class extends e.Operator{constructor(r,s,o,i){super(),this.param_tree=e.assert_type(r,n),this.env_param=e.assert_type(s,t),this.body_form=e.assert_type(o,e.TYPE_ANY),this.def_env=e.assert_type(i,e.Environment)}operate(t,n){const r=e.make_environment(this.def_env);return e.match(this.param_tree,t,r),e.match(this.env_param,n,r),e.eval(this.body_form,r)}},e.Function=class extends e.Operator{constructor(t){super(),e.assert_type(t,e.Operator),this.wrapped_operator=t}operate(t,n){return e.bind((()=>r(t,e.nil())),(t=>e.operate(this.wrapped_operator,t,n)),e.trace(e.cons(this,t),n));function r(t,s){return t===e.nil()?e.reverse(s):e.bind((()=>e.eval(t.car(),n)),(n=>r(t.cdr(),e.cons(n,s))),e.trace(t.car(),n))}}unwrap(){return this.wrapped_operator}},e.wrap=t=>new e.Function(t),e.Built_in_operator=class extends e.Operator{constructor(t){super(),e.assert_type(t,"function"),this.operate_function=t}operate(e,t){return this.operate_function(e,t)}},e.built_in_operator=t=>new e.Built_in_operator(t),e.built_in_function=t=>e.wrap(e.built_in_operator(t)),e.alien_operator=t=>(e.assert_type(t,"function"),e.built_in_operator((function(n,r){return t.apply(null,e.list_to_array(n))}))),e.alien_function=t=>e.wrap(e.alien_operator(t)),e.trap_exceptions=t=>{try{return t()}catch(t){if(t instanceof e.Nonlocal_exit||t instanceof e.Panic)throw t;return e.call_user_error_handler(t)}},e.call_user_error_handler=t=>{const n=e.get_user_environment(),r=e.fsym("error");if(n.is_bound(r))return e.operate(n.lookup(r),e.list(t),e.make_environment());e.panic(t)},e.Panic=class extends Error{constructor(e){e&&e.message?super("LISP panic: "+e.message):super("LISP panic!"),this.cause=e}},e.panic=t=>{throw new e.Panic(t)},e.define_variable=(t,n)=>{e.define(e.sym(t),n)},e.define_constant=(t,n)=>{e.define_variable(t,n)},e.define_operator=(t,n)=>{e.define(e.fsym(t),n)},e.define_built_in_operator=(t,n)=>{e.define_operator(t,e.built_in_operator(n))},e.define_built_in_function=(t,n)=>{e.define_operator(t,e.built_in_function(n))},e.define_alien_function=(t,n)=>{e.define_operator(t,e.alien_function(n))},e.define_class("operator",e.Operator),e.define_class("built-in-operator",e.Built_in_operator,e.Operator),e.define_class("fexpr",e.Fexpr,e.Operator),e.define_class("function",e.Function,e.Operator),e.define_condition("match-error",e.Match_error,e.Error),e.define_built_in_operator("%vau",(function(t,n){const r=e.elt(t,0),s=e.elt(t,1),o=e.elt(t,2),i=n;return new e.Fexpr(r,s,o,i)})),e.define_built_in_operator("%def",(function(t,n){const r=e.elt(t,0),s=e.elt(t,1);return e.bind((()=>e.eval(s,n)),(t=>e.match(r,t,n)),e.trace(s,n))})),e.define_built_in_operator("%progn",(function(t,n){return t===e.nil()?e.void():function t(r){return e.bind((()=>e.eval(r.car(),n)),(n=>r.cdr()===e.nil()?n:t(r.cdr())),e.trace(r.car(),n))}(t)})),e.define_built_in_operator("%if",(function(t,n){const r=e.elt(t,0),s=e.elt(t,1),o=e.elt(t,2);return e.bind((()=>e.eval(r,n)),(t=>(e.assert_type(t,e.Boolean),t==e.t()?e.eval(s,n):e.eval(o,n))),e.trace(r,n))})),e.define_alien_function("%wrap",(t=>e.wrap(t))),e.define_alien_function("%unwrap",(t=>e.assert_type(t,e.Function).unwrap())),e.define_alien_function("%eval",((t,n)=>e.eval(t,n))),e.define_alien_function("%eq",((t,n)=>e.to_lisp_boolean(t===n))),e.define_alien_function("%=",((t,n)=>e.to_lisp_boolean(e.equal(t,n)))),e.define_alien_function("%<",((t,n)=>e.to_lisp_boolean(e.compare(t,n)<0))),e.define_alien_function("%>",((t,n)=>e.to_lisp_boolean(e.compare(t,n)>0))),e.define_alien_function("%<=",((t,n)=>e.to_lisp_boolean(e.compare(t,n)<=0))),e.define_alien_function("%>=",((t,n)=>e.to_lisp_boolean(e.compare(t,n)>=0))),e.define_alien_function("%+",((t,n)=>e.add(t,n))),e.define_alien_function("%-",((t,n)=>e.subtract(t,n))),e.define_alien_function("%*",((t,n)=>e.multiply(t,n))),e.define_alien_function("%/",((t,n)=>e.divide(t,n))),e.define_alien_function("%cons",((t,n)=>e.cons(t,n))),e.define_alien_function("%car",(t=>e.assert_type(t,e.Cons).car())),e.define_alien_function("%cdr",(t=>e.assert_type(t,e.Cons).cdr())),e.define_alien_function("%intern",(t=>e.intern(t))),e.define_alien_function("%symbol-name",(t=>e.assert_type(t,e.Symbol).get_string())),e.define_alien_function("%variable-symbol",(t=>e.assert_type(t,e.Symbol).to_variable_symbol())),e.define_alien_function("%function-symbol",(t=>e.assert_type(t,e.Symbol).to_function_symbol())),e.define_alien_function("%class-symbol",(t=>e.assert_type(t,e.Symbol).to_class_symbol())),e.define_alien_function("%keyword-symbol",(t=>e.assert_type(t,e.Symbol).to_keyword_symbol())),e.define_alien_function("%make-environment",((t=null)=>e.make_environment(t))),e.define_alien_function("%boundp",((t,n)=>e.to_lisp_boolean(e.assert_type(n,e.Environment).is_bound(t)))),e.define_alien_function("%class-of",(t=>e.class_of(t))),e.define_alien_function("%typep",((t,n)=>e.to_lisp_boolean(e.is_subclass(e.class_of(t),n)))),e.define_alien_function("%make-instance",((t,...n)=>e.make_instance(t,...n))),e.define_alien_function("%slot-value",((t,n)=>e.assert_type(t,e.Standard_object).slot_value(n))),e.define_alien_function("%set-slot-value",((t,n,r)=>e.assert_type(t,e.Standard_object).set_slot_value(n,r))),e.define_alien_function("%slot-bound-p",((t,n)=>e.to_lisp_boolean(e.assert_type(t,e.Standard_object).is_slot_bound(n)))),e.define_alien_function("%add-method",((t,n,r)=>e.assert_type(t,e.Class).add_method(n,r))),e.define_alien_function("%find-method",((t,n)=>e.assert_type(t,e.Class).find_method(n))),e.define_alien_function("%make-standard-class",((t,n)=>e.make_standard_class(t,n))),e.define_alien_function("%reinitialize-standard-class",((t,n)=>e.reinitialize_standard_class(t,n))),e.define_alien_function("%class-name",(t=>e.assert_type(t,e.Class).get_name())),e.define_alien_function("%subclassp",((t,n)=>e.to_lisp_boolean(e.is_subclass(t,n)))),e.define_alien_function("%panic",(t=>e.panic(t)))}function h(e){function t(n,r,s,o=null){let i;return i=o instanceof e.Resumption?o.resume():n(),i instanceof e.Suspension?i.suspend((e=>t(n,r,s,e)),s):r(i)}function n(t,r,s,o,i=null){return e.progv(t,r,(()=>{let a;return a=i instanceof e.Resumption?i.resume():e.operate(s,e.nil(),o),a instanceof e.Suspension?a.suspend((e=>n(t,r,s,o,e))):a}))}function r(t,n,s=null){let o=!0;for(;;){let i;if(o&&s instanceof e.Resumption?(o=!1,i=s.resume()):i=e.eval(t,n),i instanceof e.Suspension)return i.suspend((e=>r(t,n,e)))}}function s(t,n,r,o=null){try{let i;return i=o instanceof e.Resumption?o.resume():e.operate(n,e.nil(),r),i instanceof e.Suspension?i.suspend((e=>s(t,n,r,e))):i}catch(n){if(n instanceof e.Nonlocal_exit&&n.tag===t)return n.value;throw n}}function o(t,n,r,s=null){try{let a;return a=s instanceof e.Resumption?s.resume():e.eval(t,r),a instanceof e.Suspension?a.suspend((e=>o(t,n,r,e))):i(n,a,!0,r)}catch(e){return i(n,e,!1,r)}}function i(t,n,r,s,o=null){let a;if(a=o instanceof e.Resumption?o.resume():e.eval(t,s),a instanceof e.Suspension)return a.suspend((e=>i(t,n,r,s,e)));if(r)return n;throw n}e.Continuation=class extends e.Object{constructor(t,n,r){super(),e.assert_type(t,"function"),e.assert_type(n,e.type_or(e.TYPE_NULL,e.Continuation)),e.assert_type(r,e.type_or(e.TYPE_NULL,e.Trace)),this.work_fun=t,this.inner=n,this.trace=r}},e.Suspension=class{constructor(t,n){e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Function),this.prompt=t,this.handler=n,this.continuation=null}suspend(t,n=null){return this.continuation=new e.Continuation(t,this.continuation,n),this}},e.Resumption=class{constructor(t,n){e.assert_type(t,e.Continuation),e.assert_type(n,e.Function),this.continuation=t,this.handler=n}resume(){const e=this.continuation;return this.continuation=e.inner,e.work_fun(this)}},e.Trace=class{constructor(t,n){this.expr=e.assert_type(t,e.TYPE_ANY),this.env=e.assert_type(n,e.Environment)}},e.trace=(t,n)=>new e.Trace(t,n),e.bind=(n,r,s)=>(e.assert_type(n,"function"),e.assert_type(r,"function"),e.assert_type(s,e.Trace),t(n,r,s)),e.push_prompt=(t,n,r,s=null)=>{let o;return o=s instanceof e.Resumption?s.resume():n(),o instanceof e.Suspension?e.equal(t,o.prompt)?e.operate(o.handler,e.list(o.continuation),r):o.suspend((s=>e.push_prompt(t,n,r,s))):o},e.push_subcont_barrier=(t,n,r=null)=>{let s;if(s=r instanceof e.Resumption?r.resume():t(),s instanceof e.Suspension){s.suspend((r=>e.push_subcont_barrier(t,n,r)));const r=e.alien_function((()=>{throw new e.Prompt_not_found_error(s.prompt)}));return new e.Resumption(s.continuation,r).resume()}return s},e.Prompt_not_found_error=class extends e.Error{constructor(t){super("Prompt not found: "+e.write_to_js_string(t)),this.lisp_slot_prompt=t}},e.Dynamic=class extends e.Standard_object{constructor(t=e.void()){super(),this.lisp_slot_value=t}get_value(){return this.lisp_slot_value}set_value(e){this.lisp_slot_value=e}},e.make_dynamic=(t=e.void())=>new e.Dynamic(t),e.progv=(t,n,r)=>{e.assert(t.length===n.length);const s=[];for(let r=0;r<t.length;r++){const o=e.assert_type(t[r],e.Dynamic);s[r]=o.get_value(),o.set_value(n[r])}try{return r()}finally{for(let e=0;e<t.length;e++)t[e].set_value(s[e])}},e.Nonlocal_exit=class{constructor(e,t){this.tag=e,this.value=t}};const a=e.sym("root-prompt");e.eval_form=(t,n=e.get_user_environment())=>e.push_subcont_barrier((()=>e.push_prompt(a,(()=>e.eval(t,n)),n)),n),e.define_class("continuation",e.Continuation),e.define_class("dynamic",e.Dynamic,e.Standard_object,e.Standard_class),e.define_condition("prompt-not-found-error",e.Prompt_not_found_error,e.Error),e.define_built_in_function("%take-subcont",(function(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Function);return new e.Suspension(r,s).suspend((t=>e.operate(t.handler,e.nil(),n)))})),e.define_built_in_function("%push-prompt",(function(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Function);return e.push_prompt(r,(()=>e.operate(s,e.nil(),n)),n)})),e.define_built_in_function("%push-delim-subcont",(function(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Continuation),o=e.assert_type(e.elt(t,2),e.Function);return e.push_prompt(r,(()=>new e.Resumption(s,o).resume()),n)})),e.define_built_in_function("%push-subcont-barrier",(function(t,n){const r=e.assert_type(e.elt(t,0),e.Function);return e.push_subcont_barrier((()=>e.operate(r,e.nil(),n)),n)})),e.define_built_in_function("%progv",(function(t,r){return n(e.list_to_array(e.elt(t,0)),e.list_to_array(e.elt(t,1)),e.assert_type(e.elt(t,2),e.Function),r)})),e.define_built_in_operator("%loop",(function(t,n){return r(e.assert_type(e.elt(t,0),e.TYPE_ANY),n)})),e.define_built_in_function("%catch",(function(t,n){return s(e.assert_type(e.elt(t,0),e.TYPE_ANY),e.assert_type(e.elt(t,1),e.Function),n)})),e.define_built_in_function("%throw",(function(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.TYPE_ANY);throw new e.Nonlocal_exit(r,s)})),e.define_built_in_operator("%unwind-protect",(function(t,n){return o(e.assert_type(e.elt(t,0),e.TYPE_ANY),e.assert_type(e.elt(t,1),e.TYPE_ANY),n)})),e.define_constant("+root-prompt+",a),e.define_alien_function("%print-stacktrace",(function(t){e.assert_type(t,e.Continuation);const n=[];do{null!==t.trace&&n.push(t.trace.expr)}while(t=t.inner);n.reverse();const r=e.STANDARD_OUTPUT.get_value();n.slice(29,38).forEach((t=>{r.fresh_line(),e.write(t,r),r.force_output()}))}))}function y(e){const t=e.sym("."),n=e.sym("quote");function r(t,r=!0,l=e.void()){const c=e.skip_whitespace(t,!1);if(c===e.void())return e.eof(r,l);switch(c){case"(":return e.read_delimited_list(t,")");case'"':return function(e){return o(e,'"')}(t);case"'":return function(t){return e.list(n,e.read(t,!0))}(t);case":":return a(t,e.KEYWORD_NAMESPACE);case"#":return function(t){const n=t.read_byte(!0);if(function(e){return/^[a-z]$/.test(e)}(n))return t.unread_byte(n),function(t){const n=e.read(t,!0);e.assert_type(n,e.Symbol);const r=i[n.get_string().get_utf8_bytes()];if(r)return r;throw new e.Reader_error("Illegal constant")}(t);switch(n){case"'":return a(t,e.FUNCTION_NAMESPACE);case"^":return a(t,e.CLASS_NAMESPACE);default:throw new e.Reader_error(`Illegal dispatching character ${n}`)}}(t);case"|":return function(t){return e.intern(o(t,"|"))}(t);case")":throw new e.Reader_error("Unbalanced parenthesis");default:return e.is_macro_character(c)?e.call_reader_macro(t,c):(t.unread_byte(c),function(t){let n="";for(;;){const r=t.read_byte(!1);if(r===e.void()||e.is_whitespace(r))break;if(e.is_terminating_character(r)){t.unread_byte(r);break}n+="\\"===r?s(t):r}return e.parses_as_number(n)?e.num(n):e.intern(new e.String(n))}(t))}}function s(t){const n=t.read_byte(!0);switch(n){case"n":return"\n";case"t":return"\t";case'"':return'"';case"\\":return"\\";case"|":return"|";default:throw new e.Reader_error(`Invalid escape character ${n}`)}}function o(t,n){let r="";for(;;){const e=t.read_byte(!0);if(e===n)break;"\\"!==e?r+=e:r+=s(t)}return new e.String(r)}e.read=(n,s=!0,o=e.void())=>{e.assert_type(n,e.Input_stream),e.assert_type(s,"boolean"),e.assert_type(o,e.TYPE_ANY);const i={},a=r(n,!1,i);if(a===i)return e.eof(s,o);if(a===t)throw new e.Reader_error("Consing dot not allowed here");return a},e.Reader_error=class extends e.Error{constructor(e){super(e)}},e.is_terminating_character=t=>{switch(t){case"(":case")":case";":case'"':case"'":case"|":return!0;default:return e.is_terminating_macro_character(t)}},e.parses_as_number=e=>/^-?\d+(\.\d+)?$/.test(e),e.read_delimited_list=(n,s)=>{let o=e.nil(),i=o;for(;;){const a=e.skip_whitespace(n,!0);if(a===s)return o;{n.unread_byte(a);const l=r(n,!0);if(l===t){if(o===e.nil())throw new e.Reader_error("Consing dot at start of list");i.set_cdr(e.read(n,!0));if(e.skip_whitespace(n,!0)===s)return o;throw new e.Reader_error("Multiple objects after consing dot")}{const t=e.cons(l,e.nil());o===e.nil()?(o=t,i=o):(i.set_cdr(t),i=t)}}}};const i={t:e.t(),f:e.f(),nil:e.nil(),void:e.void(),ignore:e.ignore()};function a(t,n){const r=e.read(t,!0);return e.assert_type(r,e.Symbol),r.to_namespace(n)}function l(e){for(;;){const t=e.read_byte(!0);if("|"!==t)"#"!==t||"|"===e.read_byte(!0)&&l(e);else if("#"===e.read_byte(!0))break}}e.skip_whitespace=(t,n=!0,r=e.void())=>{for(;;){const s=t.read_byte(!1);if(s===e.void())return e.eof(n,r);if(!e.is_whitespace(s)){if(";"!==s){if("#"===s){const n=t.read_byte(!1);if("|"===n){l(t);continue}return n===e.void()||t.unread_byte(n),s}return s}e:for(;;){switch(t.read_byte(!1)){case e.void():return e.eof(n,r);case"\n":break e;default:continue e}}}}},e.is_whitespace=e=>{switch(e){case" ":case"\n":case"\t":return!0;default:return!1}};const c={};e.set_macro_character=(e,t,n=!1)=>{c[e]={fun:t,non_terminating_p:n}},e.unset_macro_character=e=>{delete c[e]},e.is_macro_character=e=>void 0!==c[e],e.is_terminating_macro_character=t=>e.is_macro_character(t)&&!c[t].non_terminating_p,e.call_reader_macro=(e,t)=>c[t].fun(e,t).car(),e.eval_stream=function(t,n=e.get_user_environment()){e.assert_type(t,e.Input_stream),e.assert_type(n,e.Environment);const r={};let s=e.void();for(;;){const o=e.read(t,!1,r);if(o===r)break;s=e.eval_form(o,n)}return s},e.eval_string=function(t,n=e.get_user_environment()){return e.eval_stream(new e.String_input_stream(t),n)},e.eval_js_string=function(t,n=e.get_user_environment()){return e.eval_string(e.str(t),n)},e.define_condition("reader-error",e.Reader_error,e.Error),e.define_alien_function("%read",((t,n,r)=>(e.assert_type(n,e.Boolean),e.read(t,n.to_js_boolean(),r))))}function g(e){function t(e,t,n){t.write_byte(n);const r=e.get_utf8_bytes();for(let e=0;e<r.length;e++){const s=r[e];s===n||"\\"===s?(t.write_byte("\\"),t.write_byte(s)):t.write_byte(s)}t.write_byte(n)}function n(t,n){const r=e.PRINT_LEVEL_OPTION.get_value(),s=e.CURRENT_PRINT_LEVEL.get_value();r===e.nil()||e.compare(s,r.car())<0?n():t.write_byte("#")}e.PRINT_ESCAPE=e.make_dynamic(e.t()),e.PRINT_LEVEL_OPTION=e.make_dynamic(e.nil()),e.CURRENT_PRINT_LEVEL=e.make_dynamic(e.num(-1)),e.write=(t,n)=>(e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Output_stream),function(t){const n=e.add(e.CURRENT_PRINT_LEVEL.get_value(),e.num(1));e.progv([e.CURRENT_PRINT_LEVEL],[n],t)}((()=>{e.is_lisp_object(t)?t.write_object(n):e.write_js_object(t,n)})),t),e.write_js_object=(t,n)=>{n.write_string(e.str("#<<js "+typeof t+" "+String(t)+">>"))},e.write_unreadable_object=(t,n,r=null)=>{e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Output_stream),n.write_string(e.str("#<")),n.write_string(e.class_of(t).get_name().get_string()),null!==r&&r(),n.write_byte(">")},e.Object.prototype.write_object=function(t){e.write_unreadable_object(this,t)},e.Boolean.prototype.write_object=function(t){t.write_string(this===e.t()?e.str("#t"):e.str("#f"))},e.Nil.prototype.write_object=function(t){t.write_string(e.str("()"))},e.Void.prototype.write_object=function(t){t.write_string(e.str("#void"))},e.Ignore.prototype.write_object=function(t){t.write_string(e.str("#ignore"))},e.Number.prototype.write_object=function(e){e.write_string(this.to_string())},e.Symbol.prototype.write_object=function(n){e.PRINT_ESCAPE.get_value()===e.t()?(n.write_string(function(t){switch(t.get_namespace()){case e.VARIABLE_NAMESPACE:return e.str("");case e.FUNCTION_NAMESPACE:return e.str("#'");case e.CLASS_NAMESPACE:return e.str("#^");case e.KEYWORD_NAMESPACE:return e.str(":");default:e.panic("Unknown symbol namespace")}}(this)),!function(t){const n=t.get_string().get_utf8_bytes();if(e.parses_as_number(n))return!0;for(let t=0;t<n.length;t++){const r=n[t];if(e.is_whitespace(r)||e.is_terminating_character(r)||"\\"===r)return!0}return!1}(this)?n.write_string(this.get_string()):t(this.get_string(),n,"|")):n.write_string(this.get_string())},e.String.prototype.write_object=function(n){e.PRINT_ESCAPE.get_value()===e.t()?t(this,n,'"'):n.write_string(this)},e.Cons.prototype.write_object=function(t){function r(t,n){t.cdr()===e.nil()?e.write(t.car(),n):t.cdr()instanceof e.Cons?(e.write(t.car(),n),n.write_byte(" "),r(t.cdr(),n)):(e.write(t.car(),n),n.write_string(e.str(" . ")),e.write(t.cdr(),n))}n(t,(()=>{t.write_byte("("),r(this,t),t.write_byte(")")}))},e.Standard_object.prototype.write_object=function(t){const r="lisp_slot_";n(t,(()=>{e.write_unreadable_object(this,t,(()=>{for(const n of Object.getOwnPropertyNames(this).sort())n.startsWith(r)&&(t.write_byte(" "),e.write(e.kwd(n.slice(10)),t),t.write_byte(" "),e.write(this[n],t))}))}))},e.write_to_string=t=>{const n=new e.String_output_stream;return e.write(t,n),n.get_string()},e.write_to_js_string=t=>e.write_to_string(t).to_js_string(),e.define_variable("*print-escape*",e.PRINT_ESCAPE),e.define_variable("*print-level?*",e.PRINT_LEVEL_OPTION),e.define_alien_function("%write",((t,n)=>e.write(t,n)))}class v{constructor(){var e;!function(e){e.Object=class{equal_same_type(e){return this===e}compare_same_type(t){e.abstract_method()}},e.String=class extends e.Object{constructor(t){super(),e.assert_type(t,"string"),this.utf8_bytes=t}equal_same_type(e){return this.get_utf8_bytes()===e.get_utf8_bytes()}to_js_string(){return e.utf8_decode(this.get_utf8_bytes())}get_utf8_bytes(){return this.utf8_bytes}},e.utf8_encode=t=>(e.assert_type(t,"string"),unescape(encodeURIComponent(t))),e.utf8_decode=t=>(e.assert_type(t,"string"),decodeURIComponent(escape(t))),e.Symbol=class extends e.Object{constructor(t,n){super(),this.string=e.assert_type(t,e.String),this.namespace=e.assert_type(n,"string")}get_string(){return this.string}get_namespace(){return this.namespace}to_namespace(t){return e.assert_type(t,"string"),e.intern(this.get_string(),t)}to_variable_symbol(){return this.to_namespace(e.VARIABLE_NAMESPACE)}to_function_symbol(){return this.to_namespace(e.FUNCTION_NAMESPACE)}to_class_symbol(){return this.to_namespace(e.CLASS_NAMESPACE)}to_keyword_symbol(){return this.to_namespace(e.KEYWORD_NAMESPACE)}get_key(){return e.Symbol.make_key(this.get_string(),this.get_namespace())}static make_key(e,t){return t+"_"+e.get_utf8_bytes()}},e.VARIABLE_NAMESPACE="variable",e.FUNCTION_NAMESPACE="function",e.CLASS_NAMESPACE="class",e.KEYWORD_NAMESPACE="keyword",e.Number=class extends e.Object{constructor(t){super(),e.assert_type(t,m),this.big=t}equal_same_type(e){return this.get_big().eq(e.get_big())}compare_same_type(e){return this.get_big().cmp(e.get_big())}to_js_number(){return this.get_big().toNumber()}to_string(){return e.str(this.get_big().toFixed())}get_big(){return this.big}},e.add=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().add(n.get_big()))),e.subtract=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().minus(n.get_big()))),e.multiply=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().times(n.get_big()))),e.divide=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().div(n.get_big()))),e.Boolean=class extends e.Object{constructor(t){super(),this.bool=e.assert_type(t,"boolean")}to_js_boolean(){return this.bool}},e.List=class extends e.Object{},e.Cons=class extends e.List{constructor(e,t){super(),this._car=e,this._cdr=t}equal_same_type(t){return e.equal(this.car(),t.car())&&e.equal(this.cdr(),t.cdr())}car(){return this._car}set_car(e){this._car=e}cdr(){return this._cdr}set_cdr(e){this._cdr=e}},e.Nil=class extends e.List{constructor(){super()}},e.Void=class extends e.Object{constructor(){super()}},e.Ignore=class extends e.Object{constructor(){super()}},e.Environment=class extends e.Object{constructor(t=null){super(),null!==t&&e.assert_type(t,e.Environment),this.parent=t,this.bindings=Object.create(null===t?null:t.get_bindings())}put(t,n){e.assert_type(t,e.Symbol),this.bindings[t.get_key()]=n}lookup(t){e.assert_type(t,e.Symbol);const n=t.get_key(),r=this.bindings[n];if(void 0!==r)return r;if(!(n in this.bindings))throw new e.Unbound_symbol_error(t,this)}is_bound(t){e.assert_type(t,e.Symbol);return t.get_key()in this.bindings}get_bindings(){return this.bindings}},e.Class=class extends e.Object{constructor(t,n,r){super(),this.name=e.assert_type(t,e.Symbol),this.js_class=e.assert_type(n,"function"),this.superclass=e.assert_type(r,e.type_or(e.TYPE_NULL,e.Class))}add_method(t,n){e.assert_type(n,e.Operator);const r=this.method_key(t);this.get_js_class().prototype[r]=n}find_method(t){const n=this.method_key(t),r=this.get_js_class().prototype[n];if(void 0!==r)return r;throw new e.Unbound_method_error(this,t)}method_key(t){e.assert_type(t,e.Symbol);return"lisp_method_"+t.get_string().get_utf8_bytes()}get_name(){return this.name}get_js_class(){return this.js_class}get_superclass(){return this.superclass}},e.Built_in_class=class extends e.Class{constructor(e,t,n){super(e,t,n)}},e.Standard_class=class extends e.Class{constructor(e,t,n){super(e,t,n)}};const t="lisp_slot_";e.Standard_object=class extends e.Object{slot_value(t){const n=this.symbol_to_slot_key(t);if(this.hasOwnProperty(n))return this[n];throw new e.Unbound_slot_error(this,t)}set_slot_value(e,t){return this[this.symbol_to_slot_key(e)]=t}is_slot_bound(e){const t=this.symbol_to_slot_key(e);return this.hasOwnProperty(t)}slot_names(){return Object.getOwnPropertyNames(this).map((e=>this.slot_key_to_symbol(e)))}symbol_to_slot_key(n){e.assert_type(n,e.Symbol);const r=n.get_string().get_utf8_bytes();return t+r}slot_key_to_symbol(n){const r=n.slice(t.length);return e.intern(new e.String(r))}},e.make_instance=(t,...n)=>{e.assert_type(t,e.Standard_class),e.assert(n.length%2==0);const r=new(t.get_js_class());for(let e=0;e<n.length;e+=2){const t=n[e],s=n[e+1];r.set_slot_value(t,s)}return r},e.is_subclass=(t,n)=>{if(e.assert_type(t,e.Class),e.assert_type(n,e.Class),t===n)return!0;{const e=t.get_js_class(),r=n.get_js_class();return e.prototype instanceof r}},e.make_standard_class=(t,n)=>{e.assert_type(t,e.Symbol),e.assert_type(n,e.Standard_class);const r=n.get_js_class(),s=class extends r{constructor(){super()}},o=t.get_string().to_js_string();Object.defineProperty(s,"name",{value:o});return e.bless_class(t,s,r,e.Standard_class)},e.reinitialize_standard_class=(t,n)=>{e.assert_type(t,e.Standard_class),e.assert_type(n,e.Standard_class);const r=t.get_js_class(),s=n.get_js_class();return Object.setPrototypeOf(r.prototype,s.prototype),t},e.Condition=class extends e.Standard_object{},e.Error=class extends e.Condition{constructor(t){super();const n=new Error(t);Object.getOwnPropertyNames(n).forEach((e=>{const t=Object.getOwnPropertyDescriptor(n,e);Object.defineProperty(this,e,t)})),"string"==typeof t&&(this.lisp_slot_message=e.str(t))}},e.Type_error=class extends e.Error{constructor(t,n){super("Type assertion failed: expected "+e.write_to_js_string(n)+" got "+e.write_to_js_string(t)),this.lisp_slot_datum=t,this["lisp_slot_expected-type"]=n}},e.make_type_error=(t,n)=>new e.Type_error(t,e.to_lisp_type_spec(n)),e.Unbound_symbol_error=class extends e.Error{constructor(t,n){e.assert_type(t,e.Symbol),e.assert_type(n,e.Environment);const r=t.get_string().to_js_string();super(`Unbound ${t.get_namespace()}: ${r}`),this.lisp_slot_symbol=t,this.lisp_slot_environment=n}},e.Unbound_slot_error=class extends e.Error{constructor(t,n){e.assert_type(t,e.Standard_object),e.assert_type(n,e.Symbol);super(`Unbound slot: ${n.get_string().to_js_string()}`),this.lisp_slot_object=t,this["lisp_slot_slot-name"]=n}},e.Unbound_method_error=class extends e.Error{constructor(t,n){e.assert_type(t,e.Class),e.assert_type(n,e.Symbol);super(`Unbound method: ${n.get_string().to_js_string()}`),this.lisp_slot_class=t,this["lisp_slot_method-name"]=n}},e.Assertion_error=class extends e.Error{constructor(e){super(e||"Assertion failed")}},e.assert=(t,n="Assertion failed")=>{if(!t)throw new e.Assertion_error(n)},e.abstract_method=()=>{throw new e.Error("You called an abstract method. Congratulations!")},e.has_type=(t,n)=>{if("string"==typeof n)return typeof t===n;if("function"==typeof n)return t instanceof n;if(n&&n.custom_check)return n.custom_check(t);throw new e.Error("Unknown type spec")},e.TYPE_ANY={custom_check:e=>!0,to_lisp_type_spec:()=>e.sym("object")},e.TYPE_NULL={custom_check:e=>null===e,to_lisp_type_spec:()=>e.str("null")},e.type_or=(...t)=>({custom_check(n){for(let r=0;r<t.length;r++)if(e.has_type(n,t[r]))return!0;return!1},to_lisp_type_spec:()=>e.cons(e.sym("or"),e.array_to_list(t.map(e.to_lisp_type_spec)))}),e.assert_type=(t,n)=>{if(e.has_type(t,n))return t;throw e.make_type_error(t,n)},e.to_lisp_type_spec=t=>{if("string"==typeof t)return e.str(t);if("function"==typeof t)return e.has_lisp_class(t)?e.lisp_class(t).get_name():t;if(t&&t.to_lisp_type_spec)return t.to_lisp_type_spec();throw new e.Error("Unknown type spec")},e.elt=(t,n)=>(e.assert_type(t,e.Cons),e.assert_type(n,"number"),0===n?t.car():e.elt(t.cdr(),n-1)),e.list_to_array=t=>{e.assert_type(t,e.List);const n=[];for(;t!==e.nil();)n.push(t.car()),t=t.cdr();return n},e.array_to_list=t=>{e.assert(Array.isArray(t),"Not an array");let n=e.nil();for(let r=t.length;r>0;r--)n=e.cons(t[r-1],n);return n},e.reverse=t=>{e.assert_type(t,e.List);let n=e.nil();for(;t!==e.nil();)n=e.cons(t.car(),n),t=t.cdr();return n},e.system_environment=e.make_environment(),e.user_environment=e.make_environment(e.system_environment),e.define=(t,n)=>{e.system_environment.put(t,n)},e.symbols=Object.create(null);const n=new e.Boolean(!0),r=new e.Boolean(!1),s=new e.Nil,o=new e.Void,i=new e.Ignore,a=e.num(0),l=e.num(1);e.t=()=>n,e.f=()=>r,e.nil=()=>s,e.void=()=>o,e.ignore=()=>i,e.zero=()=>a,e.one=()=>l,e.define_class=(t,n,r=e.Object,s=e.Built_in_class)=>{const o=e.sym(t),i=e.bless_class(o,n,r,s);e.define(o.to_class_symbol(),i)},e.bless_class=(t,n,r=e.Object,s=e.Built_in_class)=>{e.assert_type(t,e.Symbol),e.assert_type(n,"function"),e.assert_type(r,e.type_or(e.TYPE_NULL,"function")),e.assert_type(s,"function");const o=new s(t,n,r?e.lisp_class(r):null);return n.prototype.lisp_class=o,o},e.define_condition=(t,n,r)=>{e.define_class(t,n,r,e.Standard_class)},e.define_class("object",e.Object,null),e.define_class("string",e.String),e.define_class("symbol",e.Symbol),e.define_class("number",e.Number),e.define_class("boolean",e.Boolean),e.define_class("list",e.List),e.define_class("cons",e.Cons,e.List),e.define_class("nil",e.Nil,e.List),e.define_class("void",e.Void),e.define_class("ignore",e.Ignore),e.define_class("environment",e.Environment),e.define_class("class",e.Class),e.define_class("built-in-class",e.Built_in_class,e.Class),e.define_class("standard-class",e.Standard_class,e.Class),e.define_class("standard-object",e.Standard_object,e.Object,e.Standard_class),e.define_condition("condition",e.Condition,e.Standard_object),e.define_condition("error",e.Error,e.Condition),e.define_condition("type-error",e.Type_error,e.Error),e.define_condition("unbound-symbol-error",e.Unbound_symbol_error,e.Error),e.define_condition("unbound-slot-error",e.Unbound_slot_error,e.Error),e.define_condition("unbound-method-error",e.Unbound_method_error,e.Error),e.define_condition("assertion-error",e.Assertion_error,e.Error)}(this),b(this),h(this),function(e){function t(t){return t===e.void()?void 0:e.assert_type(t,e.Number).to_js_number()}e.list_star=(...t)=>{const n=t.length;let r=n>=1?t[n-1]:e.nil();for(let s=n-1;s>0;s--)r=e.cons(t[s-1],r);return r},e.append=(t,n)=>(e.assert_type(t,e.List),t===e.nil()?n:e.cons(t.car(),e.append(t.cdr(),n))),e.list_length=t=>(e.assert_type(t,e.List),t===e.nil()?0:1+e.list_length(t.cdr())),e.nthcdr=(t,n)=>{if(e.assert_type(n,e.List),0===t)return n;if(n===e.nil())throw new e.Out_of_bounds_error;return e.nthcdr(t-1,n.cdr())},e.mapcar=(t,n)=>n===e.nil()?e.nil():e.cons(t(n.car()),e.mapcar(t,n.cdr())),e.mapc=(t,n)=>(n!==e.nil()&&(t(n.car()),e.mapc(t,n.cdr())),n),e.list_subseq=(t,n,r=void 0)=>{e.assert_type(t,e.List),e.assert_type(n,"number");const s=e.nthcdr(n,t);return void 0===r?s:function t(n,r){if(0===r)return e.nil();if(n===e.nil())throw new e.Out_of_bounds_error;return e.cons(n.car(),t(n.cdr(),r-1))}(s,r-n)},e.string_subseq=(t,n,r=void 0)=>{e.assert_type(t,e.String);const s=t.get_utf8_bytes();return new e.String(e.slice_subseq(s,n,r))},e.slice_subseq=(t,n,r=void 0)=>{if(e.assert_type(n,"number"),n>t.length)throw new e.Out_of_bounds_error;if(void 0===r)return t.slice(n);if(r>t.length)throw new e.Out_of_bounds_error;return t.slice(n,r)},e.some=t=>e.list(t),e.optional=(t,n=(()=>e.void()))=>t===e.nil()?n():e.elt(t,0),e.Out_of_bounds_error=class extends e.Error{constructor(){super("Out of bounds")}},e.define_alien_function("%list*",((...t)=>e.list_star(...t))),e.define_alien_function("%append",((t,n)=>e.append(t,n))),e.define_alien_function("%list-length",(t=>e.num(e.list_length(t)))),e.define_alien_function("%nth",((t,n)=>e.elt(n,e.assert_type(t,e.Number).to_js_number()))),e.define_alien_function("%nthcdr",((t,n)=>e.nthcdr(e.assert_type(t,e.Number).to_js_number(),n))),e.define_alien_function("%list-subseq",((n,r,s)=>e.list_subseq(n,e.assert_type(r,e.Number).to_js_number(),t(s)))),e.define_alien_function("%string-subseq",((n,r,s)=>e.string_subseq(n,e.assert_type(r,e.Number).to_js_number(),t(s)))),e.define_alien_function("%reverse",(t=>e.reverse(t))),e.define_condition("out-of-bounds-error",e.Out_of_bounds_error,e.Error)}(this),(e=this).Input_stream=class extends e.Object{read_byte(t,n){e.abstract_method()}unread_byte(t){e.abstract_method()}peek_byte(t=!1,n=!0,r=e.void()){const s=t?e.skip_whitespace(this,!1):this.read_byte(!1);return s===e.void()?e.eof(n,r):(this.unread_byte(s),s)}},e.String_input_stream=class extends e.Input_stream{constructor(t){super(),e.assert_type(t,e.String),this.bytes=t.get_utf8_bytes(),this.pos=-1}read_byte(t=!0,n=e.void()){return e.assert_type(t,"boolean"),e.assert_type(n,e.TYPE_ANY),this.pos+1<this.bytes.length?(this.pos++,this.byte_at_pos(this.pos)):e.eof(t,n)}unread_byte(t){if(e.assert_type(t,"string"),!(this.pos>=0&&this.byte_at_pos(this.pos)===t))throw new e.Stream_error("Cannot unread byte");this.pos--}byte_at_pos(e){return this.bytes[e]}},e.Output_stream=class extends e.Object{write_byte(t){e.abstract_method()}write_string(t){e.assert_type(t,e.String);const n=t.get_utf8_bytes();for(let e=0;e<n.length;e++)this.write_byte(n[e]);return t}force_output(){return e.void()}fresh_line(){return this.write_byte("\n"),e.t()}},e.String_output_stream=class extends e.Output_stream{constructor(){super(),this.bytes=""}write_byte(t){return e.assert_type(t,"string"),e.assert(1===t.length),this.bytes+=t,t}get_string(){return new e.String(this.bytes)}},e.eof=(t,n)=>{if(t)throw new e.End_of_file;return n},e.Stream_error=class extends e.Error{constructor(e){super(e)}},e.End_of_file=class extends e.Stream_error{constructor(){super("EOF")}},e.STANDARD_INPUT=e.make_dynamic(e.void()),e.STANDARD_OUTPUT=e.make_dynamic(e.void()),e.define_class("input-stream",e.Input_stream),e.define_class("string-input-stream",e.String_input_stream,e.Input_stream),e.define_class("output-stream",e.Output_stream),e.define_class("string-output-stream",e.String_output_stream,e.Output_stream),e.define_condition("stream-error",e.Stream_error,e.Error),e.define_condition("end-of-file",e.End_of_file,e.Stream_error),e.define_variable("*standard-input*",e.STANDARD_INPUT),e.define_variable("*standard-output*",e.STANDARD_OUTPUT),e.define_alien_function("%make-string-input-stream",(t=>new e.String_input_stream(t))),e.define_alien_function("%make-string-output-stream",(()=>new e.String_output_stream)),e.define_alien_function("%get-output-stream-string",(t=>e.assert_type(t,e.String_output_stream).get_string())),e.define_alien_function("%fresh-line",(t=>e.assert_type(t,e.Output_stream).fresh_line())),e.define_alien_function("%force-output",(t=>e.assert_type(t,e.Output_stream).force_output())),y(this),g(this),function(e){e.js_global=t=>(e.assert_type(t,e.String),globalThis[t.to_js_string()]),e.js_set_global=(t,n)=>(e.assert_type(t,e.String),globalThis[t.to_js_string()]=n),e.js_new=function(t){return e.assert_type(t,"function"),new(t.bind.apply(t,arguments))},e.js_get=(t,n)=>(e.assert_type(n,e.String),t[n.to_js_string()]),e.js_elt=(t,n)=>(e.assert(Array.isArray(t)),e.assert_type(n,e.Number),t[n.to_js_number()]),e.apply_js_method=(t,n,r)=>(e.assert_type(n,e.String),e.assert_type(r,e.List),e.assert_type(t[n.to_js_string()],"function").apply(t,e.list_to_array(r))),e.to_lisp_boolean=t=>e.assert_type(t,"boolean")?e.t():e.f(),e.to_lisp_function=t=>e.alien_function(t,"anonymous JS function"),e.to_js_function=t=>(e.assert_type(t,e.Operator),function(){var n=e.array_to_list(Array.prototype.slice.call(arguments));return e.operate(t,n,e.make_environment())}),e.JS_console_output_stream=class extends e.Output_stream{constructor(e=console.log){super(),this.buffer="",this.output_function=e}write_byte(t){return e.assert_type(t,"string"),e.assert(1===t.length),this.buffer+=t,t}fresh_line(){return 0===this.buffer.length||"\n"===this.buffer[this.buffer.length-1]?e.f():(this.write_byte("\n"),e.t())}force_output(){return this.buffer.length>0&&(this.output_function(e.utf8_decode(this.buffer)),this.buffer=""),e.void()}},e.define_constant("+js-true+",!0),e.define_constant("+js-false+",!1),e.define_constant("+js-null+",null),e.define_constant("+js-undefined+",void 0),e.define_alien_function("%js-global",e.js_global),e.define_alien_function("%js-set-global",e.js_set_global),e.define_alien_function("%js-new",e.js_new),e.define_alien_function("%js-get",e.js_get),e.define_alien_function("%js-elt",e.js_elt),e.define_alien_function("%to-lisp-boolean",e.to_lisp_boolean),e.define_alien_function("%to-js-boolean",(t=>e.assert_type(t,e.Boolean).to_js_boolean())),e.define_alien_function("%to-lisp-number",(t=>e.num(e.assert_type(t,"number")))),e.define_alien_function("%to-js-number",(t=>e.assert_type(t,e.Number).to_js_number())),e.define_alien_function("%to-lisp-string",(t=>e.str(e.assert_type(t,"string")))),e.define_alien_function("%to-js-string",(t=>e.assert_type(t,e.String).to_js_string())),e.define_alien_function("%to-lisp-function",e.to_lisp_function),e.define_alien_function("%to-js-function",e.to_js_function),e.define_alien_function("%list-to-js-array",e.list_to_array),e.define_alien_function("%js-array-to-list",e.array_to_list),e.define_alien_function("%apply-js-method",e.apply_js_method),e.define_alien_function("%js-log",((...e)=>console.log(...e))),e.define_alien_function("%sleep",(t=>(e.assert_type(t,e.Number),new Promise((e=>setTimeout(e,t.to_js_number())))))),e.define_class("js-console-output-stream",e.JS_console_output_stream,e.Output_stream),e.STANDARD_OUTPUT.set_value(new e.JS_console_output_stream)}(this)}str(e){return new this.String(this.utf8_encode(e))}sym(e,t=this.VARIABLE_NAMESPACE){return this.intern(this.str(e),t)}fsym(e){return this.sym(e,this.FUNCTION_NAMESPACE)}csym(e){return this.sym(e,this.CLASS_NAMESPACE)}kwd(e){return this.sym(e,this.KEYWORD_NAMESPACE)}intern(e,t=this.VARIABLE_NAMESPACE){this.assert_type(e,this.String),this.assert_type(t,"string");const n=this.Symbol.make_key(e,t),r=this.symbols[n];return void 0!==r?r:this.symbols[n]=new this.Symbol(e,t)}num(e){return this.assert_type(e,this.type_or("string","number")),new this.Number(new m(e))}cons(e,t){return new this.Cons(e,t)}list(...e){return this.array_to_list(e)}make_environment(e=null){return new this.Environment(e)}equal(e,t){return this.is_lisp_object(e)&&this.is_lisp_object(t)&&this.class_of(e)===this.class_of(t)?e.equal_same_type(t):e===t}compare(e,t){if(this.is_lisp_object(e)&&this.is_lisp_object(t)&&this.class_of(e)===this.class_of(t))return e.compare_same_type(t);throw this.make_type_error(t,this.class_of(e).get_js_class())}is_lisp_object(e){return e instanceof this.Object}class_of(e){return this.is_lisp_object(e)?e.lisp_class:this.lisp_class(this.Object)}lisp_class(e){return this.assert_type(e,"function"),this.assert(this.has_lisp_class(e)),e.prototype.lisp_class}has_lisp_class(e){return this.has_type(e.prototype.lisp_class,this.Class)}get_system_environment(){return this.system_environment}get_user_environment(){return this.user_environment}}const w="(%def #'list (%wrap (%vau arguments #ignore arguments))) (%def #'vau (%vau (parameter-tree environment-parameter . forms) env (%eval (list #'%vau parameter-tree environment-parameter (%list* #'%progn forms)) env))) (%def #'lispx::make-macro (%wrap (%vau (expander) #ignore (%vau operand env (%eval (%eval (%cons expander operand) (%make-environment)) env))))) (%def #'macro (lispx::make-macro (%vau (parameter-tree . forms) #ignore (list #'lispx::make-macro (%list* #'vau parameter-tree #ignore forms))))) (%def #'defmacro (macro (name parameter-tree . forms) (list #'%def (%function-symbol name) (%list* #'macro parameter-tree forms)))) (defmacro defexpr (name parameter-tree environment-parameter . forms) (list #'%def (%function-symbol name) (%list* #'vau parameter-tree environment-parameter forms))) (defmacro def (definiend-tree value . docstring?) (list #'%def definiend-tree value)) (defmacro defconstant (name value . docstring?) (list #'def name value)) (defmacro lambda (parameter-tree . forms) (list #'%wrap (%list* #'vau parameter-tree #ignore forms))) (defmacro defun (name parameter-tree . forms) (list #'def (%function-symbol name) (%list* #'lambda parameter-tree forms))) (defmacro progn forms (list* #'%progn forms)) (defmacro if (test consequent alternative) (list #'%if test consequent alternative)) (defmacro catch (tag . forms) (list #'%catch tag (list* #'lambda () forms))) (defun throw (tag . result?) (%throw tag (optional result?))) (defmacro loop forms (list #'%loop (list* #'progn forms))) (defun eq (a b) (%eq a b)) (defun class-of (object) (%class-of object)) (defun typep (object class) (%typep object class)) (defun intern (string) (%intern string)) (defun symbol-name (symbol) (%symbol-name symbol)) (defun variable-symbol (symbol) (%variable-symbol symbol)) (defun function-symbol (symbol) (%function-symbol symbol)) (defun class-symbol (symbol) (%class-symbol symbol)) (defun keyword-symbol (symbol) (%keyword-symbol symbol)) (defun cons (car cdr) (%cons car cdr)) (defun car (cons) (%car cons)) (defun cdr (cons) (%cdr cons)) (defun list* arguments (apply #'%list* arguments)) (defun reverse (list) (%reverse list)) (defun wrap (operator) (%wrap operator)) (defun unwrap (function) (%unwrap function)) (defun eval (form environment) (%eval form environment)) (defun make-environment parent-environment? (apply #'%make-environment parent-environment?)) (defun boundp (symbol environment) (%boundp symbol environment)) (defun panic (error) (%panic error)) (defun invoke-debugger (condition) (take-subcont +root-prompt+ k (push-delim-subcont +root-prompt+ k (%print-stacktrace k) (panic condition)))) (defmacro let (bindings . forms) (list* (list* #'lambda (mapcar #'car bindings) forms) (mapcar #'cadr bindings))) (defmacro let* (bindings . forms) (if (null bindings) (list* #'let () forms) (list #'let (list (car bindings)) (list* #'let* (cdr bindings) forms)))) (defmacro lispx::letrec (bindings . forms) (if (null bindings) (list* #'let () forms) (list* #'let () (list #'def (mapcar #'car bindings) (list* #'list (mapcar #'cadr bindings))) forms))) (defun lispx::make-function-binding ((name parameter-tree . forms)) (list (function-symbol name) (list* #'lambda parameter-tree forms))) (defmacro flet (function-bindings . forms) (list* #'let (mapcar #'lispx::make-function-binding function-bindings) forms)) (defmacro labels (function-bindings . forms) (list* #'lispx::letrec (mapcar #'lispx::make-function-binding function-bindings) forms)) (defexpr quote (operand) #ignore operand) (defexpr the-environment () environment environment) (defun apply (function arguments) (eval (cons (unwrap function) arguments) (%make-environment))) (defmacro when (test . forms) (list #'if test (list* #'progn forms) #void)) (defmacro unless (test . forms) (list #'if test #void (list* #'progn forms))) (defexpr cond clauses env (unless (null clauses) (let ((((test . forms) . rest-clauses) clauses)) (if (eval test env) (eval (cons #'progn forms) env) (eval (cons #'cond rest-clauses) env))))) (defun not (boolean) (if boolean #f #t)) (defexpr and operands env (cond ((null operands) #t) ((null (cdr operands)) (the boolean (eval (car operands) env))) ((eval (car operands) env) (eval (cons #'and (cdr operands)) env)) (#t #f))) (defexpr or operands env (cond ((null operands) #f) ((null (cdr operands)) (the boolean (eval (car operands) env))) ((eval (car operands) env) #t) (#t (eval (cons #'or (cdr operands)) env)))) (defexpr while (test-form . forms) env (let ((forms (list* #'progn forms))) (block exit (loop (if (eval test-form env) (eval forms env) (return-from exit)))))) (defmacro until (test-form . forms) (list* #'while (list #'not test-form) forms)) (defmacro dotimes ((var count-form . result-form?) . body-forms) (flet ((_dotimes_ (n #'body #'result) (let ((#'i (box 0))) (while (< (i) n) (body (i)) (i (+ (i) 1))) (result (i))))) (list #'_dotimes_ count-form (list* #'lambda (list var) body-forms) (list* #'lambda (list var) result-form?)))) (defmacro loop-let (name initializers . forms) (list #'labels (list (list* name (mapcar #'car initializers) forms)) (list* name (mapcar #'cadr initializers)))) (defexpr block (block-name . forms) env (let ((tag (list #void))) (flet ((escape (value) (throw tag value))) (catch tag (eval (list (list* #'lambda (list block-name) forms) #'escape) env))))) (defun return-from (#'block-name . value?) (block-name (optional value?))) (defmacro unwind-protect (protected-form . cleanup-forms) (list #'%unwind-protect protected-form (list* #'progn cleanup-forms))) (defexpr prog1 (form . forms) env (let ((result (eval form env))) (eval (list* #'progn forms) env) result)) (defun lispx::make-typecase-with-default-function (#'default) (vau (keyform . clauses) env (let ((key (eval keyform env))) (loop-let -typecase- ((clauses clauses)) (if (null clauses) (default key) (let ((((class-name . forms) . rest-clauses) clauses)) (if (typep key (find-class class-name env)) (eval (list* #'progn forms) env) (-typecase- rest-clauses)))))))) (def #'typecase (lispx::make-typecase-with-default-function (lambda (#ignore) #void))) (def #'etypecase (lispx::make-typecase-with-default-function (lambda (key) (error (make-type-error key #^object))))) (defexpr set (environment definiend-tree value) dynamic-environment (eval (list #'def definiend-tree (list (unwrap #'eval) value dynamic-environment)) (eval environment dynamic-environment))) (defun box initial-value? (def value (optional initial-value?)) (def env (the-environment)) (lambda new-value? (if-option (new-value new-value?) (set env value new-value) value))) (defun assert (boolean) (unless boolean (error (make-instance #^assertion-error)))) (defun compose (#'f #'g) (lambda args (g (apply #'f args)))) (defun identity (x) x) (defun null (object) (eq object ())) (defun consp (object) (typep object #^cons)) (defun caar (cons) (car (car cons))) (defun cadr (cons) (car (cdr cons))) (defun cdar (cons) (cdr (car cons))) (defun cddr (cons) (cdr (cdr cons))) (defun append (list1 list2) (%append list1 list2)) (defun nth (n list) (%nth n list)) (defun nthcdr (n list) (%nthcdr n list)) (defun mapcar (#'function list) (if (null list) () (cons (function (car list)) (mapcar #'function (cdr list))))) (defun mapc (#'function list) (unless (null list) (function (car list)) (mapc #'function (cdr list))) list) (defun mapcan (#'function list) (if (null list) () (append (function (car list)) (mapcan #'function (cdr list))))) (defmacro dolist ((var list-form . result-form?) . body-forms) (labels ((_dolist_ (list #'body #'result) (if (null list) (result list) (progn (body (car list)) (_dolist_ (cdr list) #'body #'result))))) (list #'_dolist_ list-form (list* #'lambda (list var) body-forms) (list* #'lambda (list var) result-form?)))) (defun reduce (#'function list :initial-value initial-value) (if (null list) initial-value (reduce #'function (cdr list) :initial-value (function initial-value (car list))))) (defun member (item list . keywords) (let ((#'test (optional (get? keywords :test) #'eq)) (#'key (optional (get? keywords :key) #'identity))) (loop-let -member- ((items list)) (if (null items) () (if (test item (key (car items))) items (-member- (cdr items))))))) (defun remove-if (#'test list) (if (null list) () (if (test (car list)) (remove-if #'test (cdr list)) (cons (car list) (remove-if #'test (cdr list)))))) (defun get? (plist indicator) (if (null plist) () (let (((i v . plist) plist)) (if (eq i indicator) (some v) (get? plist indicator))))) (defun lispx::make-relational-operator (#'binary-operator) (labels ((operator (arg1 arg2 . rest) (if (binary-operator arg1 arg2) (if (null rest) #t (apply #'operator (list* arg2 rest))) #f))) #'operator)) (def #'= (lispx::make-relational-operator #'%=)) (def #'< (lispx::make-relational-operator #'%<)) (def #'> (lispx::make-relational-operator #'%>)) (def #'<= (lispx::make-relational-operator #'%<=)) (def #'>= (lispx::make-relational-operator #'%>=)) (defun /= (arg . args) (if (null args) #t (if (consp (member arg args :test #'=)) #f (apply #'/= args)))) (defun lispx::make-thetic-operator (#'binary-operator initial-value) (lambda args (reduce #'binary-operator args :initial-value initial-value))) (def #'+ (lispx::make-thetic-operator #'%+ 0)) (def #'* (lispx::make-thetic-operator #'%* 1)) (defun lispx::make-lytic-operator (#'binary-operator initial-value) (lambda (arg1 . rest) (if (null rest) (binary-operator initial-value arg1) (reduce #'binary-operator rest :initial-value arg1)))) (def #'- (lispx::make-lytic-operator #'%- 0)) (def #'/ (lispx::make-lytic-operator #'%/ 1)) (defun find-class (name environment) (eval (class-symbol name) environment)) (defun class-name (class) (%class-name class)) (defun subclassp (class superclass) (%subclassp class superclass)) (defexpr defclass (name superclass? slot-specs . properties) env (dolist (slot-spec slot-specs) (the symbol slot-spec)) (let ((class-name (class-symbol name)) (superclass (find-class (optional superclass? (quote standard-object)) env))) (if (boundp class-name env) (%reinitialize-standard-class (eval class-name env) superclass) (eval (list #'def class-name (%make-standard-class name superclass)) env)))) (defexpr defgeneric (name (receiver . parameters) . properties) env (flet ((generic args (apply (%find-method (class-of (car args)) name) args))) (eval (list #'def (function-symbol name) #'generic) env))) (defexpr defmethod (name ((receiver class-name) . parameters) . forms) env (let ((#'method (eval (list* #'lambda (list* receiver parameters) forms) env))) (%add-method (find-class class-name env) name #'method))) (defun make-instance (class . slot-inits) (apply #'%make-instance (cons class slot-inits))) (defun slot-value (object slot-name) (%slot-value object slot-name)) (defun set-slot-value (object slot-name value) (%set-slot-value object slot-name value)) (defun slot-bound-p (object slot-name) (%slot-bound-p object slot-name)) (defun make-type-error (datum expected-type) (make-instance #^type-error :datum datum :expected-type expected-type)) (defun assert-type (object class) (if (typep object class) object (error (make-type-error object (class-name class))))) (defexpr the (class-name object) env (assert-type (eval object env) (find-class class-name env))) (defgeneric length (sequence)) (defmethod length ((seq list)) (%list-length seq)) (defgeneric elt (sequence index)) (defmethod elt ((seq list) index) (nth index seq)) (defgeneric subseq (sequence start . end?)) (defmethod subseq ((seq list) start . end?) (%list-subseq seq start (optional end?))) (defmethod subseq ((seq string) start . end?) (%string-subseq seq start (optional end?))) (defun some (value) (list value)) (defexpr if-option ((name option?) then else) env (let ((o? (eval option? env))) (if (null o?) (eval else env) (eval (list (list #'vau (list name) #ignore then) (car o?)) env)))) (defmacro when-option ((name option?) . forms) (list #'if-option (list name option?) (list* #'progn forms) ())) (defmacro unless-option (option? . forms) (list #'if-option (list #ignore option?) () (list* #'progn forms))) (defexpr optional (option? . default?) env (if-option (value (eval option? env)) value (if-option (default default?) (eval default env) #void))) (defexpr optionals (list . defaults) env (loop-let -optionals- ((list (eval list env)) (defaults defaults)) (if (null list) (if (null defaults) () (cons (eval (car defaults) env) (-optionals- () (cdr defaults)))) (if (null defaults) (cons (car list) (-optionals- (cdr list) ())) (cons (car list) (-optionals- (cdr list) (cdr defaults))))))) (defun get-option (option?) (optional option? (simple-error \"Option is nil\"))) (defexpr defdynamic (name . value-and-docstring?) env (def value (eval (optional value-and-docstring?) env)) (if (boundp name env) (set-dynamic (eval name env) value) (eval (list #'def name (make-instance #^dynamic :value value)) env))) (defun dynamic (dynamic-variable) (slot-value dynamic-variable (quote value))) (defun set-dynamic (dynamic-variable value) (set-slot-value dynamic-variable (quote value) value)) (defexpr dynamic-let (bindings . forms) env (let ((dynamics (mapcar (lambda ((name #ignore)) (eval name env)) bindings)) (values (mapcar (lambda ((#ignore value)) (eval value env)) bindings)) (thunk (eval (list* #'lambda () forms) env))) (%progv dynamics values thunk))) (defmacro dynamic-let* (bindings . forms) (if (null bindings) (list* #'progn forms) (list #'dynamic-let (list (car bindings)) (list* #'dynamic-let* (cdr bindings) forms)))) (defmacro progv (dynamic-variables values . forms) (list #'%progv dynamic-variables values (list* #'lambda () forms))) (defmacro push-prompt (prompt . forms) (list #'%push-prompt prompt (list* #'lambda () forms))) (defmacro take-subcont (prompt name . forms) (list #'%take-subcont prompt (list* #'lambda (list name) forms))) (defmacro push-delim-subcont (prompt continuation . forms) (list #'%push-delim-subcont prompt continuation (list* #'lambda () forms))) (defmacro push-subcont-barrier forms (list #'%push-subcont-barrier (list* #'lambda () forms))) (defconstant +default-prompt+ (quote default-prompt) \"This prompt is used for general coroutine-like use of\ncontinuations.\") (defmacro coroutine forms (list* #'push-prompt (quote +default-prompt+) forms)) (defmacro yield (name . forms) (list* #'take-subcont (quote +default-prompt+) name forms)) (defmacro resume (k . forms) (list* #'push-delim-subcont (quote +default-prompt+) k forms))",j="(defclass handler-frame () (handlers parent-frame?)) (defclass condition-handler () (condition-class handler-function)) (defclass restart-handler () (restart-name handler-function interactive-function? associated-conditions)) (defdynamic *condition-handler-frame?* ()) (defdynamic *restart-handler-frame?* ()) (defun lispx::make-handler-bind-operator (#'handler-spec-parser handler-frame-dynamic) (vau (handler-specs . forms) env (let ((handler-frame (make-instance #^handler-frame :handlers (mapcar (lambda (spec) (handler-spec-parser spec env)) handler-specs) :parent-frame? (dynamic handler-frame-dynamic)))) (progv (list handler-frame-dynamic) (list (some handler-frame)) (eval (list* #'progn forms) env))))) (def #'handler-bind (lispx::make-handler-bind-operator (lambda ((class-name function-form) env) (make-instance #^condition-handler :condition-class (the class (find-class class-name env)) :handler-function (the function (eval function-form env)))) *condition-handler-frame?*)) (def #'restart-bind (lispx::make-handler-bind-operator (lambda ((restart-name function-form . properties) env) (make-instance #^restart-handler :restart-name (the symbol restart-name) :handler-function (the function (eval function-form env)) :interactive-function? (when-option (i-f-form (get? properties :interactive-function)) (some (the function (eval i-f-form env)))) :associated-conditions (when-option (a-cs-form (get? properties :associated-conditions)) (the list (eval a-cs-form env))))) *restart-handler-frame?*)) (defun lispx::make-handler-case-operator (#'handler-bind-operator) (vau (handler-specs . forms) env (block exit ((block trampoline (eval (list #'handler-bind-operator (mapcar (lambda ((name function-form . properties)) (list* name (lambda args (return-from trampoline (lambda () (apply (eval function-form env) args)))) properties)) handler-specs) (list #'return-from exit (list* #'progn forms))) env)))))) (def #'handler-case (lispx::make-handler-case-operator #'handler-bind)) (def #'restart-case (lispx::make-handler-case-operator #'restart-bind)) (defun _signal_ (condition) (loop-let -signal- ((handler-frame? (dynamic *condition-handler-frame?*))) (if-option ((handler frame) (lispx::find-handler? condition handler-frame? ())) (progn (lispx::call-condition-handler handler frame condition) (-signal- (slot-value frame (quote parent-frame?)))) #void))) (defun lispx::call-condition-handler (handler handler-frame condition) (dynamic-let ((*condition-handler-frame?* (slot-value handler-frame (quote parent-frame?)))) (lispx::apply-handler-function handler (list condition)))) (defun lispx::apply-handler-function (handler arguments) (apply (slot-value handler (quote handler-function)) arguments)) (defun _error_ (condition) (signal condition) (invoke-debugger condition)) (defun lispx::make-signal-with-restarts-operator (#'signal-operator) (vau (condition . handler-specs) env (let ((c (eval condition env))) (flet ((append-associated-condition (handler-spec) (append handler-spec (list :associated-conditions (list #'list c))))) (eval (list #'restart-case (mapcar #'append-associated-condition handler-specs) (list #'signal-operator c)) env))))) (def #'signal (lispx::make-signal-with-restarts-operator #'_signal_)) (def #'error (lispx::make-signal-with-restarts-operator #'_error_)) (defun invoke-restart (restart-designator . arguments) (lispx::invoke-restart-with-arguments-producing-function restart-designator (lambda (#ignore) arguments))) (defun invoke-restart-interactively (restart-designator) (lispx::invoke-restart-with-arguments-producing-function restart-designator (lambda (restart-handler) (when-option (#'i-f (slot-value restart-handler (quote interactive-function?))) (i-f))))) (defun lispx::invoke-restart-with-arguments-producing-function (restart-designator #'function) (etypecase restart-designator (symbol (if-option (restart-handler (find-restart? restart-designator)) (lispx::apply-handler-function restart-handler (function restart-handler)) (error (make-restart-error restart-designator)))) (restart-handler (lispx::apply-handler-function restart-designator (function restart-designator))))) (defun lispx::find-handler? (object handler-frame? payload?) (when-option (handler-frame handler-frame?) (block found (dolist (handler (slot-value handler-frame (quote handlers))) (when (lispx::handler-applicable-p handler object payload?) (return-from found (some (list handler handler-frame))))) (lispx::find-handler? object (slot-value handler-frame (quote parent-frame?)) payload?)))) (defun find-restart? (name . condition?) (when-option ((handler #ignore) (lispx::find-handler? name (dynamic *restart-handler-frame?*) condition?)) (some handler))) (defgeneric lispx::handler-applicable-p (handler object payload?)) (defmethod lispx::handler-applicable-p ((handler condition-handler) condition ()) (typep condition (slot-value handler (quote condition-class)))) (defmethod lispx::handler-applicable-p ((handler restart-handler) restart-name condition?) (and (eq restart-name (slot-value handler (quote restart-name))) (lispx::restart-handler-applicable-to-condition-p handler condition?))) (defun lispx::restart-handler-applicable-to-condition-p (handler condition?) (if-option (condition condition?) (let ((a-cs (slot-value handler (quote associated-conditions)))) (if (null a-cs) #t (consp (member condition a-cs)))) #t)) (defun compute-restarts condition? (loop-let -compute-restarts- ((restarts (quote ())) (handler-frame? (dynamic *restart-handler-frame?*))) (if-option (handler-frame handler-frame?) (-compute-restarts- (append restarts (remove-if (lambda (restart) (not (lispx::restart-handler-applicable-to-condition-p restart condition?))) (slot-value handler-frame (quote handlers)))) (slot-value handler-frame (quote parent-frame?))) restarts))) (defclass restart-error (error) (restart-name)) (defun make-restart-error (restart-name) (make-instance #^restart-error :restart-name restart-name)) (defclass simple-error (error) (message)) (defun make-simple-error (message) (make-instance #^simple-error :message message)) (defun simple-error (message) (error (make-simple-error message)))",k="(defun make-string-input-stream (string) (%make-string-input-stream string)) (defexpr with-standard-input-from-string (string . forms) env (let ((s (eval string env))) (dynamic-let ((*standard-input* (make-string-input-stream s))) (eval (list* #'progn forms) env)))) (defun make-string-output-stream () (%make-string-output-stream)) (defun get-output-stream-string (stream) (%get-output-stream-string stream)) (defexpr with-standard-output-to-string forms env (dynamic-let ((*standard-output* (make-string-output-stream))) (eval (list* #'progn forms) env) (get-output-stream-string (dynamic *standard-output*)))) (defun fresh-line stream? (%fresh-line (optional stream? (dynamic *standard-output*)))) (defun force-output stream? (%force-output (optional stream? (dynamic *standard-output*))))",E="(defun read arguments (apply #'stream-read (optionals arguments (dynamic *standard-input*) #t #void))) (defgeneric stream-read (stream eof-error-p eof-value)) (defmethod stream-read ((stream input-stream) eof-error-p eof-value) (%read stream eof-error-p eof-value))",x="(defun write (object . keywords) (%write object (optional (get? keywords :stream) (dynamic *standard-output*)))) (defun write-to-string (object) (with-standard-output-to-string (write object))) (defun print1 (object) (dynamic-let ((*print-escape* #t)) (write object))) (defun uprint1 (object) (dynamic-let ((*print-escape* #f)) (write object))) (defun print (object) (fresh-line) (prog1 (print1 object) (force-output))) (defun uprint (object) (fresh-line) (prog1 (uprint1 object) (force-output)))",S="(defun js-eq (a b) (eq a b)) (defun apply-js-function (js-function arguments) (apply (to-lisp-function js-function) arguments)) (defun call-js-function (js-function . arguments) (apply-js-function js-function arguments)) (defmacro js-lambda (parameter-tree . forms) (list #'to-js-function (list #'lambda parameter-tree (list #'push-subcont-barrier (list* #'push-prompt (quote +root-prompt+) forms))))) (defun js-global (name) (%js-global name)) (defun js-set-global (name value) (%js-set-global name value)) (defun js-new (constructor . arguments) (apply #'%js-new (cons constructor arguments))) (defun js-get (object name) (%js-get object name)) (defun to-lisp-boolean (js-boolean) (%to-lisp-boolean js-boolean)) (defun to-js-boolean (lisp-boolean) (%to-js-boolean lisp-boolean)) (defun to-lisp-number (js-number) (%to-lisp-number js-number)) (defun to-js-number (lisp-number) (%to-js-number lisp-number)) (defun to-lisp-string (js-string) (%to-lisp-string js-string)) (defun to-js-string (lisp-string) (%to-js-string lisp-string)) (defun to-lisp-function (js-function) (%to-lisp-function js-function)) (defun to-js-function (lisp-operator) (%to-js-function lisp-operator)) (defun list-to-js-array (list) (%list-to-js-array list)) (defun js-array-to-list (array) (%js-array-to-list array)) (defun js-array elements (list-to-js-array elements)) (defmethod elt ((seq object) index) (if (or (< index 0) (>= index (length seq))) (error (make-instance #^out-of-bounds-error)) (%js-elt seq index))) (defmethod length ((seq object)) (to-lisp-number (js-get seq \"length\"))) (defun apply-js-method (receiver name arguments) (%apply-js-method receiver name arguments)) (defun call-js-method (receiver name . arguments) (apply #'apply-js-method (list receiver name arguments))) (defun js-method (method-name) (lambda (receiver . arguments) (apply-js-method receiver method-name arguments))) (defmacro define-js-method (name method-name) (list #'def (function-symbol name) (js-method method-name))) (defun js-undefined-option (value) (if (eq value +js-undefined+) () (some value))) (defun js-null-option (value) (if (eq value +js-null+) () (some value))) (defun await (promise) (yield k (call-js-method promise \"then\" (js-lambda (value) (resume k value)) (js-lambda (error) (resume k (error error)))))) (defun sync (#'fun) (lambda args (await (apply #'fun args)))) (defmacro define-js-method/sync (name method-name) (list #'def (function-symbol name) (sync (js-method method-name)))) (defun sleep (ms) (await (%sleep ms))) (defun js-log arguments (apply #'%js-log arguments))";function N(){return function(){const e=new v;return e.eval_js_string(w),e.eval_js_string(j),e.eval_js_string(k),e.eval_js_string(E),e.eval_js_string(x),e.eval_js_string(S),e}()}let A,P;function O(){A&&(this.set_position(A),A=!1)}function q(e){var t=this;")"==e.key?setTimeout((function(){A=t.get_position();for(var e,n=t.before_cursor(),r=1,s=A-1;r>0;){if(!(e=n[--s]))return;"("===e?r--:")"==e&&r++}"("==e&&(clearTimeout(P),setTimeout((function(){t.set_position(s),P=setTimeout((function(){t.set_position(A),A=!1}),200)}),0))}),0):A=!1}return $((function(){const e=N();!function(e){e.REPL_input_buffer=class extends e.Object{constructor(){super(),this.buffer="",this.wake_up_function=null}set_wake_up_function(t){e.assert_type(t,e.Function),null===this.wake_up_function?this.wake_up_function=t:e.panic(new e.Error("Concurrent access detected"))}add_line(t){if(e.assert_type(t,e.String),this.buffer+=t.get_utf8_bytes(),null!==this.wake_up_function){const t=this.wake_up_function;this.wake_up_function=null,e.eval_form(e.list(t))}else e.panic(new e.Error("No wakeup function - Lisp crashed?"))}get_input_stream(){return new e.String_input_stream(new e.String(this.buffer))}truncate_input_buffer(t){e.assert_type(t,e.String_input_stream),e.assert(t.pos>0),this.buffer=this.buffer.slice(t.pos+1)}clear_input_buffer(){this.buffer=""}},e.define_class("repl:input-buffer",e.REPL_input_buffer),e.define_alien_function("repl:%set-input-buffer-wake-up-function",((e,t)=>e.set_wake_up_function(t))),e.define_alien_function("repl:%make-input-buffer-stream",(e=>e.get_input_stream())),e.define_alien_function("repl:%truncate-input-buffer",((e,t)=>e.truncate_input_buffer(t))),e.define_alien_function("repl:%clear-input-buffer",((e,t)=>e.clear_input_buffer(t)))}(e);const t=$("#terminal").terminal((function(t){r.add_line(e.str(t+"\n")),n.force_output()}),{greetings:"Welcome to LispX!",historySize:1024,keydown:O,keypress:q});t.set_prompt("* ");const n=new e.JS_console_output_stream(t.echo);e.STANDARD_OUTPUT.set_value(n);const r=new e.REPL_input_buffer;e.STANDARD_INPUT.set_value(r),e.define_alien_function("repl:%display-prompt",(n=>{const r=e.assert_type(n,e.Number).to_js_number();0===r?t.set_prompt("* "):t.set_prompt("["+r+"] ")})),e.eval_js_string("(defmethod stream-read ((input-buffer repl:input-buffer) . #ignore) (block exit (loop ((block trampoline (let ((stream (repl:%make-input-buffer-stream input-buffer))) (handler-case ((end-of-file (lambda #ignore (return-from trampoline (lambda () (take-subcont +root-prompt+ k (repl:%set-input-buffer-wake-up-function input-buffer (lambda () (push-delim-subcont +root-prompt+ k)))))))) (reader-error (lambda (e) (repl:%clear-input-buffer input-buffer) (error e)))) (let ((form (read stream))) (repl:%truncate-input-buffer input-buffer stream) (return-from exit form)))))))))"),e.eval_js_string('(defconstant repl:+environment+ (the-environment) "The environment in which REPL expressions are evaluated.") (defdynamic repl:*debug-level* 0) (defun repl:run () (loop (restart-case ((repl-abort (lambda ()))) (repl:%display-prompt (dynamic repl:*debug-level*)) (print (eval (read) repl:+environment+))))) (defun repl:run-debugger-loop (condition k) (uprint "Debugger invoked on condition:") (print condition) (uprint "Available restarts -- use (invoke-restart \'name ...) to invoke:") (mapc (lambda (restart) (unless (eq (slot-value restart (quote restart-name)) (quote repl-abort)) (print (slot-value restart (quote restart-name))))) (compute-restarts condition)) (uprint "Backtrace:") (%print-stacktrace k) (repl:run)) (defun invoke-debugger (condition) (take-subcont +root-prompt+ k (push-delim-subcont +root-prompt+ k (dynamic-let ((repl:*debug-level* (+ (dynamic repl:*debug-level*) 1))) (restart-case ((abort (lambda () (invoke-restart (quote repl-abort))))) (typecase condition (unbound-symbol-error (let ((symbol (slot-value condition (quote symbol))) (env (slot-value condition (quote environment)))) (restart-case ((continue (lambda () (eval symbol env)) :associated-conditions (list condition)) (use-value (lambda (value) value) :associated-conditions (list condition)) (store-value (lambda (value) (eval (list #\'def symbol value) env)) :associated-conditions (list condition))) (repl:run-debugger-loop condition k)))) (object (repl:run-debugger-loop condition k))))))))'),e.eval_js_string("(repl:run)")})),t})()));