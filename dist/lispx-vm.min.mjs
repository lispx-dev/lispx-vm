/*! For license information please see lispx-vm.min.mjs.LICENSE.txt */
var e={"./src/boot.lispx":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="(%def #'list (%wrap (%vau arguments #ignore arguments)))(%def #'vau (%vau (parameter-tree environment-parameter . forms) env (%eval (list #'%vau parameter-tree environment-parameter (%list* #'%progn forms)) env)))(%def #'lispx::make-macro (%wrap (%vau (expander) #ignore (%vau operand env (%eval (%eval (%cons expander operand) (%make-environment)) env)))))(%def #'macro (lispx::make-macro (%vau (parameter-tree . forms) #ignore (list #'lispx::make-macro (%list* #'vau parameter-tree #ignore forms)))))(%def #'defmacro (macro (name parameter-tree . forms) (list #'%def (%function-symbol name) (%list* #'macro parameter-tree forms))))(defmacro defexpr (name parameter-tree environment-parameter . forms) (list #'%def (%function-symbol name) (%list* #'vau parameter-tree environment-parameter forms)))(defmacro def (definiend-tree value . docstring?) (list #'%def definiend-tree value))(defmacro defconstant (name value . docstring?) (list #'def name value))(defmacro lambda (parameter-tree . forms) (list #'%wrap (%list* #'vau parameter-tree #ignore forms)))(defmacro defun (name parameter-tree . forms) (list #'def (%function-symbol name) (%list* #'lambda parameter-tree forms)))(defmacro progn forms (list* #'%progn forms))(defmacro if (test consequent alternative) (list #'%if test consequent alternative))(defmacro catch (tag . forms) (list #'%catch tag (list* #'lambda () forms)))(defun throw (tag . result?) (%throw tag (optional result?)))(defmacro loop forms (list #'%loop (list* #'progn forms)))(defun eq (a b) (%eq a b))(defun class-of (object) (%class-of object))(defun typep (object class) (%typep object class))(defun intern (string) (%intern string))(defun symbol-name (symbol) (%symbol-name symbol))(defun variable-symbol (symbol) (%variable-symbol symbol))(defun function-symbol (symbol) (%function-symbol symbol))(defun class-symbol (symbol) (%class-symbol symbol))(defun keyword-symbol (symbol) (%keyword-symbol symbol))(defun cons (car cdr) (%cons car cdr))(defun car (cons) (%car cons))(defun cdr (cons) (%cdr cons))(defun list* arguments (apply #'%list* arguments))(defun reverse (list) (%reverse list))(defun wrap (operator) (%wrap operator))(defun unwrap (function) (%unwrap function))(defun eval (form environment) (%eval form environment))(defun make-environment parent-environment? (apply #'%make-environment parent-environment?))(defun boundp (symbol environment) (%boundp symbol environment))(defun panic (error) (%panic error))(defun invoke-debugger (condition) (take-subcont +root-prompt+ k (push-delim-subcont +root-prompt+ k (%print-stacktrace k) (panic condition))))(defmacro let (bindings . forms) (list* (list* #'lambda (mapcar #'car bindings) forms) (mapcar #'cadr bindings)))(defmacro let* (bindings . forms) (if (null bindings) (list* #'let () forms) (list #'let (list (car bindings)) (list* #'let* (cdr bindings) forms))))(defmacro lispx::letrec (bindings . forms) (if (null bindings) (list* #'let () forms) (list* #'let () (list #'def (mapcar #'car bindings) (list* #'list (mapcar #'cadr bindings))) forms)))(defun lispx::make-function-binding ((name parameter-tree . forms)) (list (function-symbol name) (list* #'lambda parameter-tree forms)))(defmacro flet (function-bindings . forms) (list* #'let (mapcar #'lispx::make-function-binding function-bindings) forms))(defmacro labels (function-bindings . forms) (list* #'lispx::letrec (mapcar #'lispx::make-function-binding function-bindings) forms))(defexpr quote (operand) #ignore operand)(defexpr the-environment () environment environment)(defun apply (function arguments) (eval (cons (unwrap function) arguments) (%make-environment)))(defmacro when (test . forms) (list #'if test (list* #'progn forms) #void))(defmacro unless (test . forms) (list #'if test #void (list* #'progn forms)))(defexpr cond clauses env (unless (null clauses) (let ((((test . forms) . rest-clauses) clauses)) (if (eval test env) (eval (cons #'progn forms) env) (eval (cons #'cond rest-clauses) env)))))(defun not (boolean) (if boolean #f #t))(defexpr and operands env (cond ((null operands) #t) ((null (cdr operands)) (the boolean (eval (car operands) env))) ((eval (car operands) env) (eval (cons #'and (cdr operands)) env)) (#t #f)))(defexpr or operands env (cond ((null operands) #f) ((null (cdr operands)) (the boolean (eval (car operands) env))) ((eval (car operands) env) #t) (#t (eval (cons #'or (cdr operands)) env))))(defexpr while (test-form . forms) env (let ((forms (list* #'progn forms))) (block exit (loop (if (eval test-form env) (eval forms env) (return-from exit))))))(defmacro until (test-form . forms) (list* #'while (list #'not test-form) forms))(defmacro dotimes ((var count-form . result-form?) . body-forms) (flet ((_dotimes_ (n #'body #'result) (let ((#'i (box 0))) (while (< (i) n) (body (i)) (i (+ (i) 1))) (result (i))))) (list #'_dotimes_ count-form (list* #'lambda (list var) body-forms) (list* #'lambda (list var) result-form?))))(defmacro loop-let (name initializers . forms) (list #'labels (list (list* name (mapcar #'car initializers) forms)) (list* name (mapcar #'cadr initializers))))(defexpr block (block-name . forms) env (let ((tag (list #void))) (flet ((escape (value) (throw tag value))) (catch tag (eval (list (list* #'lambda (list block-name) forms) #'escape) env)))))(defun return-from (#'block-name . value?) (block-name (optional value?)))(defmacro unwind-protect (protected-form . cleanup-forms) (list #'%unwind-protect protected-form (list* #'progn cleanup-forms)))(defexpr prog1 (form . forms) env (let ((result (eval form env))) (eval (list* #'progn forms) env) result))(defun lispx::make-typecase-with-default-function (#'default) (vau (keyform . clauses) env (let ((key (eval keyform env))) (loop-let -typecase- ((clauses clauses)) (if (null clauses) (default key) (let ((((class-name . forms) . rest-clauses) clauses)) (if (typep key (find-class class-name env)) (eval (list* #'progn forms) env) (-typecase- rest-clauses))))))))(def #'typecase (lispx::make-typecase-with-default-function (lambda (#ignore) #void)))(def #'etypecase (lispx::make-typecase-with-default-function (lambda (key) (error (make-type-error key #^object)))))(defexpr set (environment definiend-tree value) dynamic-environment (eval (list #'def definiend-tree (list (unwrap #'eval) value dynamic-environment)) (eval environment dynamic-environment)))(defun box initial-value? (def value (optional initial-value?)) (def env (the-environment)) (lambda new-value? (if-option (new-value new-value?) (set env value new-value) value)))(defun assert (boolean) (unless boolean (error (make-instance #^assertion-error))))(defun identity (x) x)(defun null (object) (eq object ()))(defun consp (object) (typep object #^cons))(defun caar (cons) (car (car cons)))(defun cadr (cons) (car (cdr cons)))(defun cdar (cons) (cdr (car cons)))(defun cddr (cons) (cdr (cdr cons)))(defun append (list1 list2) (%append list1 list2))(defun nth (n list) (%nth n list))(defun nthcdr (n list) (%nthcdr n list))(defun mapcar (#'function list) (if (null list) () (cons (function (car list)) (mapcar #'function (cdr list)))))(defun mapc (#'function list) (unless (null list) (function (car list)) (mapc #'function (cdr list))) list)(defun mapcan (#'function list) (if (null list) () (append (function (car list)) (mapcan #'function (cdr list)))))(defmacro dolist ((var list-form . result-form?) . body-forms) (labels ((_dolist_ (list #'body #'result) (if (null list) (result list) (progn (body (car list)) (_dolist_ (cdr list) #'body #'result))))) (list #'_dolist_ list-form (list* #'lambda (list var) body-forms) (list* #'lambda (list var) result-form?))))(defun reduce (#'function list :initial-value initial-value) (if (null list) initial-value (reduce #'function (cdr list) :initial-value (function initial-value (car list)))))(defun member (item list . keywords) (let ((#'test (optional (get? keywords :test) #'eq)) (#'key (optional (get? keywords :key) #'identity))) (loop-let -member- ((items list)) (if (null items) () (if (test item (key (car items))) items (-member- (cdr items)))))))(defun remove-if (#'test list) (if (null list) () (if (test (car list)) (remove-if #'test (cdr list)) (cons (car list) (remove-if #'test (cdr list))))))(defun get? (plist indicator) (if (null plist) () (let (((i v . plist) plist)) (if (eq i indicator) (some v) (get? plist indicator)))))(defun lispx::make-relational-operator (#'binary-operator) (labels ((operator (arg1 arg2 . rest) (if (binary-operator arg1 arg2) (if (null rest) #t (apply #'operator (list* arg2 rest))) #f))) #'operator))(def #'= (lispx::make-relational-operator #'%=))(def #'< (lispx::make-relational-operator #'%<))(def #'> (lispx::make-relational-operator #'%>))(def #'<= (lispx::make-relational-operator #'%<=))(def #'>= (lispx::make-relational-operator #'%>=))(defun /= (arg . args) (if (null args) #t (if (consp (member arg args :test #'=)) #f (apply #'/= args))))(defun lispx::make-thetic-operator (#'binary-operator initial-value) (lambda args (reduce #'binary-operator args :initial-value initial-value)))(def #'+ (lispx::make-thetic-operator #'%+ 0))(def #'* (lispx::make-thetic-operator #'%* 1))(defun lispx::make-lytic-operator (#'binary-operator initial-value) (lambda (arg1 . rest) (if (null rest) (binary-operator initial-value arg1) (reduce #'binary-operator rest :initial-value arg1))))(def #'- (lispx::make-lytic-operator #'%- 0))(def #'/ (lispx::make-lytic-operator #'%/ 1))(defmacro class (name) (class-symbol name))(defun find-class (name environment) (eval (class-symbol name) environment))(defun class-name (class) (%class-name class))(defun subclassp (class superclass) (%subclassp class superclass))(defexpr defclass (name superclass? slot-specs . properties) env (dolist (slot-spec slot-specs) (the symbol slot-spec)) (let ((class-name (class-symbol name)) (superclass (find-class (optional superclass? (quote standard-object)) env))) (if (boundp class-name env) (%reinitialize-standard-class (eval class-name env) superclass) (eval (list #'def class-name (%make-standard-class name superclass)) env))))(defexpr defgeneric (name (receiver . parameters) . properties) env (flet ((generic args (apply (%find-method (class-of (car args)) name) args))) (eval (list #'def (function-symbol name) #'generic) env)))(defexpr defmethod (name ((receiver class-name) . parameters) . forms) env (let ((#'method (eval (list* #'lambda (list* receiver parameters) forms) env))) (%add-method (find-class class-name env) name #'method)))(defun make-instance (class . slot-inits) (apply #'%make-instance (cons class slot-inits)))(defun slot-value (object slot-name) (%slot-value object slot-name))(defun set-slot-value (object slot-name value) (%set-slot-value object slot-name value))(defun slot-bound-p (object slot-name) (%slot-bound-p object slot-name))(defun make-type-error (datum expected-type) (make-instance #^type-error :datum datum :expected-type expected-type))(defun assert-type (object class) (if (typep object class) object (error (make-type-error object (class-name class)))))(defexpr the (class-name object) env (assert-type (eval object env) (find-class class-name env)))(defgeneric length (sequence) (:documentation \"Return the number of elements in a sequence.\"))(defmethod length ((seq list)) (%list-length seq))(defgeneric elt (sequence index) (:documentation \"Return the sequence element at the specified index.\"))(defmethod elt ((seq list) index) (nth index seq))(defgeneric subseq (sequence start . end?) (:documentation \"Create a sequence that is a copy of the subsequence\nof the SEQUENCE bounded by START and optional END?.  If END?  is not\nsupplied or void, the subsequence stretches until the end of the\nlist.\"))(defmethod subseq ((seq list) start . end?) (%list-subseq seq start (optional end?)))(defmethod subseq ((seq string) start . end?) (%string-subseq seq start (optional end?)))(defun some (value) (list value))(defexpr if-option ((name option?) then else) env (let ((o? (eval option? env))) (if (null o?) (eval else env) (eval (list (list #'vau (list name) #ignore then) (car o?)) env))))(defmacro when-option ((name option?) . forms) (list #'if-option (list name option?) (list* #'progn forms) ()))(defmacro unless-option (option? . forms) (list #'if-option (list #ignore option?) () (list* #'progn forms)))(defexpr optional (option? . default?) env (if-option (value (eval option? env)) value (if-option (default default?) (eval default env) #void)))(defexpr optionals (list . defaults) env (loop-let -optionals- ((list (eval list env)) (defaults defaults)) (if (null list) (if (null defaults) () (cons (eval (car defaults) env) (-optionals- () (cdr defaults)))) (if (null defaults) (cons (car list) (-optionals- (cdr list) ())) (cons (car list) (-optionals- (cdr list) (cdr defaults)))))))(defun get-option (option?) (optional option? (simple-error \"Option is nil\")))(defexpr defdynamic (name . value-and-docstring?) env (def value (eval (optional value-and-docstring?) env)) (if (boundp name env) (set-dynamic (eval name env) value) (eval (list #'def name (make-instance #^dynamic :value value)) env)))(defun dynamic (dynamic-variable) (slot-value dynamic-variable (quote value)))(defun set-dynamic (dynamic-variable value) (set-slot-value dynamic-variable (quote value) value))(defexpr dynamic-let (bindings . forms) env (let ((dynamics (mapcar (lambda ((name #ignore)) (eval name env)) bindings)) (values (mapcar (lambda ((#ignore value)) (eval value env)) bindings)) (thunk (eval (list* #'lambda () forms) env))) (%progv dynamics values thunk)))(defmacro dynamic-let* (bindings . forms) (if (null bindings) (list* #'progn forms) (list #'dynamic-let (list (car bindings)) (list* #'dynamic-let* (cdr bindings) forms))))(defmacro progv (dynamic-variables values . forms) (list #'%progv dynamic-variables values (list* #'lambda () forms)))(defmacro push-prompt (prompt . forms) (list #'%push-prompt prompt (list* #'lambda () forms)))(defmacro take-subcont (prompt name . forms) (list #'%take-subcont prompt (list* #'lambda (list name) forms)))(defmacro push-delim-subcont (prompt continuation . forms) (list #'%push-delim-subcont prompt continuation (list* #'lambda () forms)))(defmacro push-subcont-barrier forms (list #'%push-subcont-barrier (list* #'lambda () forms)))(defconstant +default-prompt+ (quote default-prompt) \"This prompt is used for general coroutine-like use of\ncontinuations.\")(defmacro coroutine forms (list* #'push-prompt (quote +default-prompt+) forms))(defmacro yield (name . forms) (list* #'take-subcont (quote +default-prompt+) name forms))(defmacro resume (k . forms) (list* #'push-delim-subcont (quote +default-prompt+) k forms))"},"./src/cond-sys.lispx":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="(defclass handler-frame () (handlers parent-frame?) (:documentation \"Instances of this class make up the condition and\nrestart handler chains.  Each frame stores a list of HANDLERS and an\noptional PARENT-FRAME?.\"))(defclass condition-handler () (condition-class handler-function) (:documentation \"A condition handler is handling a particular\nCONDITION-CLASS (can be `object' to handle all conditions).  The\nHANDLER-FUNCTION receives a signalled condition as its single\nargument.\"))(defclass restart-handler () (restart-name handler-function interactive-function? associated-conditions) (:documentation \"A restart handler is handling a particular\nRESTART-NAME.  The HANDLER-FUNCTION receives the arguments passed to\n`invoke-restart'.  The optional INTERACTIVE-FUNCTION? is called by\n`invoke-restart-interactively' and should prompt the user for required\narguments.  The ASSOCIATED-CONDITIONS are a list of conditions with\nwhich this handler is associated.  If the list is empty, the handler\nis applicable to any condition.  If it's not empty, the handler is\napplicable only to conditions in the list.\"))(defdynamic *condition-handler-frame?* ())(defdynamic *restart-handler-frame?* ())(defun lispx::make-handler-bind-operator (#'handler-spec-parser handler-frame-dynamic) (vau (handler-specs . forms) env (let ((handler-frame (make-instance #^handler-frame :handlers (mapcar (lambda (spec) (handler-spec-parser spec env)) handler-specs) :parent-frame? (dynamic handler-frame-dynamic)))) (progv (list handler-frame-dynamic) (list (some handler-frame)) (eval (list* #'progn forms) env)))))(def #'handler-bind (lispx::make-handler-bind-operator (lambda ((class-name function-form) env) (make-instance #^condition-handler :condition-class (the class (find-class class-name env)) :handler-function (the function (eval function-form env)))) *condition-handler-frame?*))(def #'restart-bind (lispx::make-handler-bind-operator (lambda ((restart-name function-form . properties) env) (make-instance #^restart-handler :restart-name (the symbol restart-name) :handler-function (the function (eval function-form env)) :interactive-function? (when-option (i-f-form (get? properties :interactive-function)) (some (the function (eval i-f-form env)))) :associated-conditions (when-option (a-cs-form (get? properties :associated-conditions)) (the list (eval a-cs-form env))))) *restart-handler-frame?*))(defun lispx::make-handler-case-operator (#'handler-bind-operator) (vau (handler-specs . forms) env (block exit ((block trampoline (eval (list #'handler-bind-operator (mapcar (lambda ((name function-form . properties)) (list* name (lambda args (return-from trampoline (lambda () (apply (eval function-form env) args)))) properties)) handler-specs) (list #'return-from exit (list* #'progn forms))) env))))))(def #'handler-case (lispx::make-handler-case-operator #'handler-bind))(def #'restart-case (lispx::make-handler-case-operator #'restart-bind))(defun _signal_ (condition) (loop-let -signal- ((handler-frame? (dynamic *condition-handler-frame?*))) (if-option ((handler frame) (lispx::find-handler? condition handler-frame? ())) (progn (lispx::call-condition-handler handler frame condition) (-signal- (slot-value frame (quote parent-frame?)))) #void)))(defun lispx::call-condition-handler (handler handler-frame condition) (dynamic-let ((*condition-handler-frame?* (slot-value handler-frame (quote parent-frame?)))) (lispx::apply-handler-function handler (list condition))))(defun lispx::apply-handler-function (handler arguments) (apply (slot-value handler (quote handler-function)) arguments))(defun _error_ (condition) (signal condition) (invoke-debugger condition))(defun lispx::make-signal-with-restarts-operator (#'signal-operator) (vau (condition . handler-specs) env (let ((c (eval condition env))) (flet ((append-associated-condition (handler-spec) (append handler-spec (list :associated-conditions (list #'list c))))) (eval (list #'restart-case (mapcar #'append-associated-condition handler-specs) (list #'signal-operator c)) env)))))(def #'signal (lispx::make-signal-with-restarts-operator #'_signal_))(def #'error (lispx::make-signal-with-restarts-operator #'_error_))(defun invoke-restart (restart-designator . arguments) (lispx::invoke-restart-with-arguments-producing-function restart-designator (lambda (#ignore) arguments)))(defun invoke-restart-interactively (restart-designator) (lispx::invoke-restart-with-arguments-producing-function restart-designator (lambda (restart-handler) (when-option (#'i-f (slot-value restart-handler (quote interactive-function?))) (i-f)))))(defun lispx::invoke-restart-with-arguments-producing-function (restart-designator #'function) (etypecase restart-designator (symbol (if-option (restart-handler (find-restart? restart-designator)) (lispx::apply-handler-function restart-handler (function restart-handler)) (error (make-restart-error restart-designator)))) (restart-handler (lispx::apply-handler-function restart-designator (function restart-designator)))))(defun lispx::find-handler? (object handler-frame? payload?) (when-option (handler-frame handler-frame?) (block found (dolist (handler (slot-value handler-frame (quote handlers))) (when (lispx::handler-applicable-p handler object payload?) (return-from found (some (list handler handler-frame))))) (lispx::find-handler? object (slot-value handler-frame (quote parent-frame?)) payload?))))(defun find-restart? (name . condition?) (when-option ((handler #ignore) (lispx::find-handler? name (dynamic *restart-handler-frame?*) condition?)) (some handler)))(defgeneric lispx::handler-applicable-p (handler object payload?) (:documentation \"Return true if a condition or restart HANDLER is\napplicable, false otherwise.  The OBJECT can be a condition or a\nrestart name.  The PAYLOAD? is only used for restart handlers, and\nalways nil for condition handlers.\"))(defmethod lispx::handler-applicable-p ((handler condition-handler) condition ()) (typep condition (slot-value handler (quote condition-class))))(defmethod lispx::handler-applicable-p ((handler restart-handler) restart-name condition?) (and (eq restart-name (slot-value handler (quote restart-name))) (lispx::restart-handler-applicable-to-condition-p handler condition?)))(defun lispx::restart-handler-applicable-to-condition-p (handler condition?) (if-option (condition condition?) (let ((a-cs (slot-value handler (quote associated-conditions)))) (if (null a-cs) #t (consp (member condition a-cs)))) #t))(defun compute-restarts condition? (loop-let -compute-restarts- ((restarts (quote ())) (handler-frame? (dynamic *restart-handler-frame?*))) (if-option (handler-frame handler-frame?) (-compute-restarts- (append restarts (remove-if (lambda (restart) (not (lispx::restart-handler-applicable-to-condition-p restart condition?))) (slot-value handler-frame (quote handlers)))) (slot-value handler-frame (quote parent-frame?))) restarts)))(defclass restart-error (error) (restart-name) (:documentation \"Signalled when no handler for RESTART-NAME is found.\"))(defun make-restart-error (restart-name) (make-instance #^restart-error :restart-name restart-name))(defclass simple-error (error) (message) (:documentation \"Class for simple errors with a MESSAGE.\"))(defun make-simple-error (message) (make-instance #^simple-error :message message))(defun simple-error (message) (error (make-simple-error message)))"},"./src/js.lispx":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="(defun js-eq (a b) (eq a b))(defun apply-js-function (js-function arguments) (apply (to-lisp-function js-function) arguments))(defun call-js-function (js-function . arguments) (apply-js-function js-function arguments))(defmacro js-lambda (parameter-tree . forms) (list #'to-js-function (list #'lambda parameter-tree (list #'push-subcont-barrier (list* #'push-prompt (quote +root-prompt+) forms)))))(defun js-global (name) (%js-global name))(defun js-new (constructor . arguments) (apply #'%js-new (cons constructor arguments)))(defun js-get (object name) (%js-get object name))(defun to-lisp-boolean (js-boolean) (%to-lisp-boolean js-boolean))(defun to-js-boolean (lisp-boolean) (%to-js-boolean lisp-boolean))(defun to-lisp-number (js-number) (%to-lisp-number js-number))(defun to-js-number (lisp-number) (%to-js-number lisp-number))(defun to-lisp-string (js-string) (%to-lisp-string js-string))(defun to-js-string (lisp-string) (%to-js-string lisp-string))(defun to-lisp-function (js-function) (%to-lisp-function js-function))(defun to-js-function (lisp-operator) (%to-js-function lisp-operator))(defun list-to-js-array (list) (%list-to-js-array list))(defun js-array-to-list (array) (%js-array-to-list array))(defun js-array elements (list-to-js-array elements))(defmethod elt ((seq object) index) (if (or (< index 0) (>= index (length seq))) (error (make-instance #^out-of-bounds-error)) (%js-elt seq index)))(defmethod length ((seq object)) (to-lisp-number (js-get seq \"length\")))(defun apply-js-method (receiver name arguments) (%apply-js-method receiver name arguments))(defun call-js-method (receiver name . arguments) (apply #'apply-js-method (list receiver name arguments)))(defun js-method (method-name) (lambda (receiver . arguments) (apply-js-method receiver method-name arguments)))(defmacro define-js-method (name method-name) (list #'def (function-symbol name) (js-method method-name)))(defun js-undefined-option (value) (if (eq value +js-undefined+) () (some value)))(defun js-null-option (value) (if (eq value +js-null+) () (some value)))(defun await (promise) (yield k (call-js-method promise \"then\" (js-lambda (value) (resume k value)) (js-lambda (error) (resume k (error error))))))(defun sync (#'fun) (lambda args (await (apply #'fun args))))(defmacro define-js-method/sync (name method-name) (list #'def (function-symbol name) (sync (js-method method-name))))(defun sleep (ms) (await (%sleep ms)))(defun js-log arguments (apply #'%js-log arguments))"},"./src/print.lispx":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="(defun write (object . keywords) (%write object (optional (get? keywords :stream) (dynamic *standard-output*))))(defun write-to-string (object) (with-standard-output-to-string (write object)))(defun print1 (object) (dynamic-let ((*print-escape* #t)) (write object)))(defun uprint1 (object) (dynamic-let ((*print-escape* #f)) (write object)))(defun print (object) (fresh-line) (prog1 (print1 object) (force-output)))(defun uprint (object) (fresh-line) (prog1 (uprint1 object) (force-output)))"},"./src/read.lispx":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="(defun read arguments (apply #'stream-read (optionals arguments (dynamic *standard-input*) #t #void)))(defgeneric stream-read (stream eof-error-p eof-value) (:documentation \"Underlying, generic implementation of `read'.\nEvery stream class can provide a specialized method.\"))(defmethod stream-read ((stream input-stream) eof-error-p eof-value) (%read stream eof-error-p eof-value))"},"./src/stream.lispx":(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="(defun make-string-input-stream (string) (%make-string-input-stream string))(defexpr with-standard-input-from-string (string . forms) env (let ((s (eval string env))) (dynamic-let ((*standard-input* (make-string-input-stream s))) (eval (list* #'progn forms) env))))(defun make-string-output-stream () (%make-string-output-stream))(defun get-output-stream-string (stream) (%get-output-stream-string stream))(defexpr with-standard-output-to-string forms env (dynamic-let ((*standard-output* (make-string-output-stream))) (eval (list* #'progn forms) env) (get-output-stream-string (dynamic *standard-output*))))(defun fresh-line stream? (%fresh-line (optional stream? (dynamic *standard-output*))))(defun force-output stream? (%force-output (optional stream? (dynamic *standard-output*))))"},"./node_modules/big.js/big.mjs":(e,t,n)=>{n.r(t),n.d(t,{Big:()=>d,default:()=>p});var r=1e6,s=1e6,i="[big.js] ",o=i+"Invalid ",a=o+"decimal places",l=i+"Division by zero",c={},u=void 0,_=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function round(e,t,n,r){var s=e.c;if(n===u&&(n=e.constructor.RM),0!==n&&1!==n&&2!==n&&3!==n)throw Error("[big.js] Invalid rounding mode");if(t<1)r=3===n&&(r||!!s[0])||0===t&&(1===n&&s[0]>=5||2===n&&(s[0]>5||5===s[0]&&(r||s[1]!==u))),s.length=1,r?(e.e=e.e-t+1,s[0]=1):s[0]=e.e=0;else if(t<s.length){if(r=1===n&&s[t]>=5||2===n&&(s[t]>5||5===s[t]&&(r||s[t+1]!==u||1&s[t-1]))||3===n&&(r||!!s[0]),s.length=t,r)for(;++s[--t]>9;)if(s[t]=0,0===t){++e.e,s.unshift(1);break}for(t=s.length;!s[--t];)s.pop()}return e}function stringify(e,t,n){var r=e.e,s=e.c.join(""),i=s.length;if(t)s=s.charAt(0)+(i>1?"."+s.slice(1):"")+(r<0?"e":"e+")+r;else if(r<0){for(;++r;)s="0"+s;s="0."+s}else if(r>0)if(++r>i)for(r-=i;r--;)s+="0";else r<i&&(s=s.slice(0,r)+"."+s.slice(r));else i>1&&(s=s.charAt(0)+"."+s.slice(1));return e.s<0&&n?"-"+s:s}c.abs=function(){var e=new this.constructor(this);return e.s=1,e},c.cmp=function(e){var t,n=this,r=n.c,s=(e=new n.constructor(e)).c,i=n.s,o=e.s,a=n.e,l=e.e;if(!r[0]||!s[0])return r[0]?i:s[0]?-o:0;if(i!=o)return i;if(t=i<0,a!=l)return a>l^t?1:-1;for(o=(a=r.length)<(l=s.length)?a:l,i=-1;++i<o;)if(r[i]!=s[i])return r[i]>s[i]^t?1:-1;return a==l?0:a>l^t?1:-1},c.div=function(e){var t=this,n=t.constructor,s=t.c,i=(e=new n(e)).c,o=t.s==e.s?1:-1,c=n.DP;if(c!==~~c||c<0||c>r)throw Error(a);if(!i[0])throw Error(l);if(!s[0])return e.s=o,e.c=[e.e=0],e;var _,d,p,f,m,b=i.slice(),h=_=i.length,y=s.length,g=s.slice(0,_),v=g.length,w=e,j=w.c=[],k=0,E=c+(w.e=t.e-e.e)+1;for(w.s=o,o=E<0?0:E,b.unshift(0);v++<_;)g.push(0);do{for(p=0;p<10;p++){if(_!=(v=g.length))f=_>v?1:-1;else for(m=-1,f=0;++m<_;)if(i[m]!=g[m]){f=i[m]>g[m]?1:-1;break}if(!(f<0))break;for(d=v==_?i:b;v;){if(g[--v]<d[v]){for(m=v;m&&!g[--m];)g[m]=9;--g[m],g[v]+=10}g[v]-=d[v]}for(;!g[0];)g.shift()}j[k++]=f?p:++p,g[0]&&f?g[v]=s[h]||0:g=[s[h]]}while((h++<y||g[0]!==u)&&o--);return j[0]||1==k||(j.shift(),w.e--,E--),k>E&&round(w,E,n.RM,g[0]!==u),w},c.eq=function(e){return 0===this.cmp(e)},c.gt=function(e){return this.cmp(e)>0},c.gte=function(e){return this.cmp(e)>-1},c.lt=function(e){return this.cmp(e)<0},c.lte=function(e){return this.cmp(e)<1},c.minus=c.sub=function(e){var t,n,r,s,i=this,o=i.constructor,a=i.s,l=(e=new o(e)).s;if(a!=l)return e.s=-l,i.plus(e);var c=i.c.slice(),u=i.e,_=e.c,d=e.e;if(!c[0]||!_[0])return _[0]?e.s=-l:c[0]?e=new o(i):e.s=1,e;if(a=u-d){for((s=a<0)?(a=-a,r=c):(d=u,r=_),r.reverse(),l=a;l--;)r.push(0);r.reverse()}else for(n=((s=c.length<_.length)?c:_).length,a=l=0;l<n;l++)if(c[l]!=_[l]){s=c[l]<_[l];break}if(s&&(r=c,c=_,_=r,e.s=-e.s),(l=(n=_.length)-(t=c.length))>0)for(;l--;)c[t++]=0;for(l=t;n>a;){if(c[--n]<_[n]){for(t=n;t&&!c[--t];)c[t]=9;--c[t],c[n]+=10}c[n]-=_[n]}for(;0===c[--l];)c.pop();for(;0===c[0];)c.shift(),--d;return c[0]||(e.s=1,c=[d=0]),e.c=c,e.e=d,e},c.mod=function(e){var t,n=this,r=n.constructor,s=n.s,i=(e=new r(e)).s;if(!e.c[0])throw Error(l);return n.s=e.s=1,t=1==e.cmp(n),n.s=s,e.s=i,t?new r(n):(s=r.DP,i=r.RM,r.DP=r.RM=0,n=n.div(e),r.DP=s,r.RM=i,this.minus(n.times(e)))},c.neg=function(){var e=new this.constructor(this);return e.s=-e.s,e},c.plus=c.add=function(e){var t,n,r,s=this,i=s.constructor;if(e=new i(e),s.s!=e.s)return e.s=-e.s,s.minus(e);var o=s.e,a=s.c,l=e.e,c=e.c;if(!a[0]||!c[0])return c[0]||(a[0]?e=new i(s):e.s=s.s),e;if(a=a.slice(),t=o-l){for(t>0?(l=o,r=c):(t=-t,r=a),r.reverse();t--;)r.push(0);r.reverse()}for(a.length-c.length<0&&(r=c,c=a,a=r),t=c.length,n=0;t;a[t]%=10)n=(a[--t]=a[t]+c[t]+n)/10|0;for(n&&(a.unshift(n),++l),t=a.length;0===a[--t];)a.pop();return e.c=a,e.e=l,e},c.pow=function(e){var t=this,n=new t.constructor("1"),r=n,i=e<0;if(e!==~~e||e<-1e6||e>s)throw Error(o+"exponent");for(i&&(e=-e);1&e&&(r=r.times(t)),e>>=1;)t=t.times(t);return i?n.div(r):r},c.prec=function(e,t){if(e!==~~e||e<1||e>r)throw Error(o+"precision");return round(new this.constructor(this),e,t)},c.round=function(e,t){if(e===u)e=0;else if(e!==~~e||e<-r||e>r)throw Error(a);return round(new this.constructor(this),e+this.e+1,t)},c.sqrt=function(){var e,t,n,r=this,s=r.constructor,o=r.s,a=r.e,l=new s("0.5");if(!r.c[0])return new s(r);if(o<0)throw Error(i+"No square root");0===(o=Math.sqrt(r+""))||o===1/0?((t=r.c.join("")).length+a&1||(t+="0"),a=((a+1)/2|0)-(a<0||1&a),e=new s(((o=Math.sqrt(t))==1/0?"5e":(o=o.toExponential()).slice(0,o.indexOf("e")+1))+a)):e=new s(o+""),a=e.e+(s.DP+=4);do{n=e,e=l.times(n.plus(r.div(n)))}while(n.c.slice(0,a).join("")!==e.c.slice(0,a).join(""));return round(e,(s.DP-=4)+e.e+1,s.RM)},c.times=c.mul=function(e){var t,n=this,r=n.constructor,s=n.c,i=(e=new r(e)).c,o=s.length,a=i.length,l=n.e,c=e.e;if(e.s=n.s==e.s?1:-1,!s[0]||!i[0])return e.c=[e.e=0],e;for(e.e=l+c,o<a&&(t=s,s=i,i=t,c=o,o=a,a=c),t=new Array(c=o+a);c--;)t[c]=0;for(l=a;l--;){for(a=0,c=o+l;c>l;)a=t[c]+i[l]*s[c-l-1]+a,t[c--]=a%10,a=a/10|0;t[c]=a}for(a?++e.e:t.shift(),l=t.length;!t[--l];)t.pop();return e.c=t,e},c.toExponential=function(e,t){var n=this,s=n.c[0];if(e!==u){if(e!==~~e||e<0||e>r)throw Error(a);for(n=round(new n.constructor(n),++e,t);n.c.length<e;)n.c.push(0)}return stringify(n,!0,!!s)},c.toFixed=function(e,t){var n=this,s=n.c[0];if(e!==u){if(e!==~~e||e<0||e>r)throw Error(a);for(e=e+(n=round(new n.constructor(n),e+n.e+1,t)).e+1;n.c.length<e;)n.c.push(0)}return stringify(n,!1,!!s)},c[Symbol.for("nodejs.util.inspect.custom")]=c.toJSON=c.toString=function(){var e=this,t=e.constructor;return stringify(e,e.e<=t.NE||e.e>=t.PE,!!e.c[0])},c.toNumber=function(){var e=Number(stringify(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(e.toString()))throw Error(i+"Imprecise conversion");return e},c.toPrecision=function(e,t){var n=this,s=n.constructor,i=n.c[0];if(e!==u){if(e!==~~e||e<1||e>r)throw Error(o+"precision");for(n=round(new s(n),e,t);n.c.length<e;)n.c.push(0)}return stringify(n,e<=n.e||n.e<=s.NE||n.e>=s.PE,!!i)},c.valueOf=function(){var e=this,t=e.constructor;if(!0===t.strict)throw Error(i+"valueOf disallowed");return stringify(e,e.e<=t.NE||e.e>=t.PE,!0)};var d=function _Big_(){function Big(e){var t=this;if(!(t instanceof Big))return e===u?_Big_():new Big(e);if(e instanceof Big)t.s=e.s,t.e=e.e,t.c=e.c.slice();else{if("string"!=typeof e){if(!0===Big.strict&&"bigint"!=typeof e)throw TypeError(o+"value");e=0===e&&1/e<0?"-0":String(e)}!function parse(e,t){var n,r,s;if(!_.test(t))throw Error(o+"number");e.s="-"==t.charAt(0)?(t=t.slice(1),-1):1,(n=t.indexOf("."))>-1&&(t=t.replace(".",""));(r=t.search(/e/i))>0?(n<0&&(n=r),n+=+t.slice(r+1),t=t.substring(0,r)):n<0&&(n=t.length);for(s=t.length,r=0;r<s&&"0"==t.charAt(r);)++r;if(r==s)e.c=[e.e=0];else{for(;s>0&&"0"==t.charAt(--s););for(e.e=n-r-1,e.c=[],n=0;r<=s;)e.c[n++]=+t.charAt(r++)}return e}(t,e)}t.constructor=Big}return Big.prototype=c,Big.DP=20,Big.RM=1,Big.NE=-7,Big.PE=21,Big.strict=false,Big.roundDown=0,Big.roundHalfUp=1,Big.roundHalfEven=2,Big.roundUp=3,Big}();const p=d},"./src/control.mjs":(e,t,n)=>{function init_control(e){e.Continuation=class Lisp_continuation extends e.Object{constructor(t,n,r){super(),e.assert_type(t,"function"),e.assert_type(n,e.type_or(e.TYPE_NULL,e.Continuation)),this.work_fun=t,this.inner=n,this.trace=r}},e.Suspension=class Suspension{constructor(t,n){e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Function),this.prompt=t,this.handler=n,this.continuation=null}suspend(t,n){return e.assert_type(t,"function"),this.continuation=new e.Continuation(t,this.continuation,n),this}},e.Resumption=class Resumption{constructor(t,n){e.assert_type(t,e.Continuation),e.assert_type(n,e.Function),this.continuation=t,this.handler=n}resume(){const e=this.continuation;return this.continuation=e.inner,e.work_fun(this)}};class Trace{constructor(e,t){this.expr=e,this.env=t}}function do_bind(t,n,r,s=null){let i;return i=s instanceof e.Resumption?s.resume():t(),i instanceof e.Suspension?i.suspend((e=>do_bind(t,n,r,e)),r):n(i)}function do_progv(t,n,r,s,i=null){return e.progv(t,n,(()=>{let o;return o=i instanceof e.Resumption?i.resume():e.operate(r,e.nil(),s),o instanceof e.Suspension?o.suspend((e=>do_progv(t,n,r,s,e))):o}))}function do_loop(t,n,r=null){let s=!0;for(;;){let i;if(s&&r instanceof e.Resumption?(s=!1,i=r.resume()):i=e.eval(t,n),i instanceof e.Suspension)return i.suspend((e=>do_loop(t,n,e)))}}function do_catch(t,n,r,s=null){try{let i;return i=s instanceof e.Resumption?s.resume():e.operate(n,e.nil(),r),i instanceof e.Suspension?i.suspend((e=>do_catch(t,n,r,e))):i}catch(n){if(n instanceof e.Nonlocal_exit&&n.tag===t)return n.value;throw n}}function do_unwind_protect_1(t,n,r,s=null){try{let i;return i=s instanceof e.Resumption?s.resume():e.eval(t,r),i instanceof e.Suspension?i.suspend((e=>do_unwind_protect_1(t,n,r,e))):do_unwind_protect_2(n,i,!0,r)}catch(e){return do_unwind_protect_2(n,e,!1,r)}}function do_unwind_protect_2(t,n,r,s,i=null){let o;if(o=i instanceof e.Resumption?i.resume():e.eval(t,s),o instanceof e.Suspension)return o.suspend((e=>do_unwind_protect_2(t,n,r,s,e)));if(r)return n;throw n}e.trace=(e,t)=>new Trace(e,t),e.bind=(t,n,r)=>(e.assert_type(t,"function"),e.assert_type(n,"function"),do_bind(t,n,r)),e.push_prompt=(t,n,r,s=null)=>{let i;return i=s instanceof e.Resumption?s.resume():n(),i instanceof e.Suspension?e.equal(t,i.prompt)?e.operate(i.handler,e.list(i.continuation),r):i.suspend((s=>e.push_prompt(t,n,r,s))):i},e.push_subcont_barrier=(t,n,r=null)=>{let s;if(s=r instanceof e.Resumption?r.resume():t(),s instanceof e.Suspension){s.suspend((r=>e.push_subcont_barrier(t,n,r)));const r=e.alien_function((()=>{throw new e.Prompt_not_found_error(s.prompt)}));return new e.Resumption(s.continuation,r).resume()}return s},e.Prompt_not_found_error=class Lisp_prompt_not_found_error extends e.Error{constructor(t){super("Prompt not found: "+e.write_to_js_string(t)),this.lisp_slot_prompt=t}},e.Dynamic=class Lisp_dynamic extends e.Standard_object{constructor(t=e.void()){super(),this.lisp_slot_value=t}get_value(){return this.lisp_slot_value}set_value(e){this.lisp_slot_value=e}},e.make_dynamic=(t=e.void())=>new e.Dynamic(t),e.progv=(t,n,r)=>{e.assert(t.length===n.length);const s=[];for(let r=0;r<t.length;r++){const i=e.assert_type(t[r],e.Dynamic);s[r]=i.get_value(),i.set_value(n[r])}try{return r()}finally{for(let e=0;e<t.length;e++)t[e].set_value(s[e])}},e.Nonlocal_exit=class Nonlocal_exit{constructor(e,t){this.tag=e,this.value=t}};const t=e.sym("root-prompt");e.eval_form=(n,r=e.get_environment())=>e.push_subcont_barrier((()=>e.push_prompt(t,(()=>e.eval(n,r)),r)),r),e.define_class("continuation",e.Continuation),e.define_class("dynamic",e.Dynamic,e.Standard_object,e.Standard_class),e.define_condition("prompt-not-found-error",e.Prompt_not_found_error,e.Error),e.define_built_in_function("%take-subcont",(function TAKE_SUBCONT(t,n){var r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Function);return new e.Suspension(r,s).suspend((t=>e.operate(t.handler,e.nil(),n)))})),e.define_built_in_function("%push-prompt",(function PUSH_PROMPT(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Function);return e.push_prompt(r,(()=>e.operate(s,e.nil(),n)),n)})),e.define_built_in_function("%push-delim-subcont",(function PUSH_DELIM_SUBCONT(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Continuation),i=e.assert_type(e.elt(t,2),e.Function);return e.push_prompt(r,(()=>new e.Resumption(s,i).resume()),n)})),e.define_built_in_function("%push-subcont-barrier",(function PUSH_SUBCONT_BARRIER(t,n){const r=e.assert_type(e.elt(t,0),e.Function);return e.push_subcont_barrier((()=>e.operate(r,e.nil(),n)),n)})),e.define_built_in_function("%progv",(function PROGV(t,n){return do_progv(e.list_to_array(e.elt(t,0)),e.list_to_array(e.elt(t,1)),e.assert_type(e.elt(t,2),e.Function),n)})),e.define_built_in_operator("%loop",(function LOOP(t,n){return do_loop(e.assert_type(e.elt(t,0),e.TYPE_ANY),n)})),e.define_built_in_function("%catch",(function CATCH(t,n){return do_catch(e.assert_type(e.elt(t,0),e.TYPE_ANY),e.assert_type(e.elt(t,1),e.Function),n)})),e.define_built_in_function("%throw",(function THROW(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.TYPE_ANY);throw new e.Nonlocal_exit(r,s)})),e.define_built_in_operator("%unwind-protect",(function UNWIND_PROTECT(t,n){return do_unwind_protect_1(e.assert_type(e.elt(t,0),e.TYPE_ANY),e.assert_type(e.elt(t,1),e.TYPE_ANY),n)})),e.define_constant("+root-prompt+",t),e.define_alien_function("%print-stacktrace",(function print_stacktrace(t){e.assert_type(t,e.Continuation);const n=[];do{t.trace&&n.push(t.trace.expr)}while(t=t.inner);n.reverse();const r=e.STANDARD_OUTPUT.get_value();n.slice(28).forEach((t=>{r.fresh_line(),e.write(t,r),r.force_output()}))}))}n.r(t),n.d(t,{init_control:()=>init_control})},"./src/eval.mjs":(e,t,n)=>{function init_eval(e){e.eval=(t,n=e.get_environment())=>e.trap_exceptions((()=>(e.assert_type(n,e.Environment),t instanceof e.Symbol?function evaluate_symbol(t,n){return t.get_namespace()===e.KEYWORD_NAMESPACE?t:n.lookup(t)}(t,n):t instanceof e.Cons?function evaluate_cons(t,n){return e.bind((()=>function evaluate_operator(t,n){return t instanceof e.Symbol?n.lookup(t.to_function_symbol()):e.eval(t,n)}(t.car(),n)),(r=>e.operate(r,t.cdr(),n)),e.trace(t,n))}(t,n):t))),e.operate=(t,n,r=e.get_environment())=>e.trap_exceptions((()=>(e.assert_type(t,e.Operator),e.assert_type(n,e.TYPE_ANY),e.assert_type(r,e.Environment),t.operate(n,r))));const t=e.type_or(e.Symbol,e.Ignore),n=e.type_or(e.Symbol,e.Ignore,e.List);e.match=(t,r,s)=>{if(t instanceof e.Symbol)if(t.get_namespace()===e.KEYWORD_NAMESPACE){if(t!==r)throw new e.Match_error(t,r)}else s.put(t,r);else if(t instanceof e.Cons){if(!(r instanceof e.Cons))throw new e.Match_error(t,r);e.match(t.car(),r.car(),s),e.match(t.cdr(),r.cdr(),s)}else if(t===e.nil()){if(r!==e.nil())throw new e.Match_error(t,r)}else if(t!==e.ignore())throw e.make_type_error(t,n);return r},e.Match_error=class Lisp_match_error extends e.Error{constructor(t,n){super("Match error: "+e.write_to_js_string(t)+" vs "+e.write_to_js_string(n)),this.lisp_slot_definiend=t,this.lisp_slot_value=n}},e.Operator=class Lisp_operator extends e.Object{operate(t,n){e.abstract_method()}},e.Fexpr=class Lisp_fexpr extends e.Operator{constructor(r,s,i,o){super(),this.param_tree=e.assert_type(r,n),this.env_param=e.assert_type(s,t),this.body_form=e.assert_type(i,e.TYPE_ANY),this.def_env=e.assert_type(o,e.Environment)}operate(t,n){const r=e.make_environment(this.def_env);return e.match(this.param_tree,t,r),e.match(this.env_param,n,r),e.eval(this.body_form,r)}},e.Function=class Lisp_function extends e.Operator{constructor(t){super(),e.assert_type(t,e.Operator),this.wrapped_operator=t}operate(t,n){return e.bind((()=>eval_args(t,e.nil())),(t=>e.operate(this.wrapped_operator,t,n)));function eval_args(t,r){return t===e.nil()?e.reverse(r):e.bind((()=>e.eval(t.car(),n)),(n=>eval_args(t.cdr(),e.cons(n,r))),e.trace(t.car(),n))}}unwrap(){return this.wrapped_operator}},e.wrap=t=>new e.Function(t),e.Built_in_operator=class Lisp_built_in_operator extends e.Operator{constructor(t){super(),e.assert_type(t,"function"),this.operate_function=t}operate(e,t){return this.operate_function(e,t)}},e.built_in_operator=t=>new e.Built_in_operator(t),e.built_in_function=t=>e.wrap(e.built_in_operator(t)),e.alien_operator=t=>(e.assert_type(t,"function"),e.built_in_operator((function operate_function(n,r){return t.apply(null,e.list_to_array(n))}))),e.alien_function=t=>e.wrap(e.alien_operator(t)),e.trap_exceptions=t=>{try{return t()}catch(t){if(t instanceof e.Nonlocal_exit||t instanceof e.Panic)throw t;return e.call_user_error_handler(t)}},e.call_user_error_handler=t=>{const n=e.get_environment(),r=e.fsym("error");if(n.is_bound(r))return e.operate(n.lookup(r),e.list(t),e.make_environment());e.panic(t)},e.Panic=class Panic extends Error{constructor(e){e&&e.message?super("LISP panic: "+e.message):super("LISP panic!"),this.cause=e}},e.panic=t=>{throw new e.Panic(t)},e.define_variable=(t,n)=>{e.get_environment().put(e.sym(t),n)},e.define_constant=(t,n)=>{e.define_variable(t,n)},e.define_operator=(t,n)=>{e.get_environment().put(e.fsym(t),n)},e.define_built_in_operator=(t,n)=>{e.define_operator(t,e.built_in_operator(n))},e.define_built_in_function=(t,n)=>{e.define_operator(t,e.built_in_function(n))},e.define_alien_function=(t,n)=>{e.define_operator(t,e.alien_function(n))},e.define_class("operator",e.Operator),e.define_class("built-in-operator",e.Built_in_operator,e.Operator),e.define_class("fexpr",e.Fexpr,e.Operator),e.define_class("function",e.Function,e.Operator),e.define_condition("match-error",e.Match_error,e.Error),e.define_built_in_operator("%vau",(function VAU(t,n){const r=e.elt(t,0),s=e.elt(t,1),i=e.elt(t,2),o=n;return new e.Fexpr(r,s,i,o)})),e.define_built_in_operator("%def",(function DEF(t,n){const r=e.elt(t,0),s=e.elt(t,1);return e.bind((()=>e.eval(s,n)),(t=>e.match(r,t,n)),e.trace(s,n))})),e.define_built_in_operator("%progn",(function PROGN(t,n){return t===e.nil()?e.void():function progn(t){return e.bind((()=>e.eval(t.car(),n)),(n=>t.cdr()===e.nil()?n:progn(t.cdr())),e.trace(t.car(),n))}(t)})),e.define_built_in_operator("%if",(function IF(t,n){const r=e.elt(t,0),s=e.elt(t,1),i=e.elt(t,2);return e.bind((()=>e.eval(r,n)),(t=>(e.assert_type(t,e.Boolean),t==e.t()?e.eval(s,n):e.eval(i,n))),e.trace(r,n))})),e.define_alien_function("%wrap",(t=>e.wrap(t))),e.define_alien_function("%unwrap",(t=>e.assert_type(t,e.Function).unwrap())),e.define_alien_function("%eval",((t,n)=>e.eval(t,n))),e.define_alien_function("%eq",((t,n)=>e.to_lisp_boolean(t===n))),e.define_alien_function("%=",((t,n)=>e.to_lisp_boolean(e.equal(t,n)))),e.define_alien_function("%<",((t,n)=>e.to_lisp_boolean(e.compare(t,n)<0))),e.define_alien_function("%>",((t,n)=>e.to_lisp_boolean(e.compare(t,n)>0))),e.define_alien_function("%<=",((t,n)=>e.to_lisp_boolean(e.compare(t,n)<=0))),e.define_alien_function("%>=",((t,n)=>e.to_lisp_boolean(e.compare(t,n)>=0))),e.define_alien_function("%+",((t,n)=>e.add(t,n))),e.define_alien_function("%-",((t,n)=>e.subtract(t,n))),e.define_alien_function("%*",((t,n)=>e.multiply(t,n))),e.define_alien_function("%/",((t,n)=>e.divide(t,n))),e.define_alien_function("%cons",((t,n)=>e.cons(t,n))),e.define_alien_function("%car",(t=>e.assert_type(t,e.Cons).car())),e.define_alien_function("%cdr",(t=>e.assert_type(t,e.Cons).cdr())),e.define_alien_function("%intern",(t=>e.intern(t))),e.define_alien_function("%symbol-name",(t=>e.assert_type(t,e.Symbol).get_string())),e.define_alien_function("%variable-symbol",(t=>e.assert_type(t,e.Symbol).to_variable_symbol())),e.define_alien_function("%function-symbol",(t=>e.assert_type(t,e.Symbol).to_function_symbol())),e.define_alien_function("%class-symbol",(t=>e.assert_type(t,e.Symbol).to_class_symbol())),e.define_alien_function("%keyword-symbol",(t=>e.assert_type(t,e.Symbol).to_keyword_symbol())),e.define_alien_function("%make-environment",((t=null)=>e.make_environment(t))),e.define_alien_function("%boundp",((t,n)=>e.to_lisp_boolean(e.assert_type(n,e.Environment).is_bound(t)))),e.define_alien_function("%class-of",(t=>e.class_of(t))),e.define_alien_function("%typep",((t,n)=>e.to_lisp_boolean(e.is_subclass(e.class_of(t),n)))),e.define_alien_function("%make-instance",((t,...n)=>e.make_instance(t,...n))),e.define_alien_function("%slot-value",((t,n)=>e.assert_type(t,e.Standard_object).slot_value(n))),e.define_alien_function("%set-slot-value",((t,n,r)=>e.assert_type(t,e.Standard_object).set_slot_value(n,r))),e.define_alien_function("%slot-bound-p",((t,n)=>e.to_lisp_boolean(e.assert_type(t,e.Standard_object).is_slot_bound(n)))),e.define_alien_function("%add-method",((t,n,r)=>e.assert_type(t,e.Class).add_method(n,r))),e.define_alien_function("%find-method",((t,n)=>e.assert_type(t,e.Class).find_method(n))),e.define_alien_function("%make-standard-class",((t,n)=>e.make_standard_class(t,n))),e.define_alien_function("%reinitialize-standard-class",((t,n)=>e.reinitialize_standard_class(t,n))),e.define_alien_function("%class-name",(t=>e.assert_type(t,e.Class).get_name())),e.define_alien_function("%subclassp",((t,n)=>e.to_lisp_boolean(e.is_subclass(t,n)))),e.define_alien_function("%panic",(t=>e.panic(t)))}n.r(t),n.d(t,{init_eval:()=>init_eval})},"./src/js.mjs":(e,t,n)=>{function init_js(e){e.js_global=t=>(e.assert_type(t,e.String),globalThis[t.to_js_string()]),e.js_new=function(t){e.assert_type(t,"function");const n=t.bind.apply(t,arguments);return new n},e.js_get=(t,n)=>(e.assert_type(n,e.String),t[n.to_js_string()]),e.js_elt=(t,n)=>(e.assert(Array.isArray(t)),e.assert_type(n,e.Number),t[n.to_js_number()]),e.apply_js_method=(t,n,r)=>{e.assert_type(n,e.String),e.assert_type(r,e.List);return e.assert_type(t[n.to_js_string()],"function").apply(t,e.list_to_array(r))},e.to_lisp_boolean=t=>e.assert_type(t,"boolean")?e.t():e.f(),e.to_lisp_function=t=>e.alien_function(t,"anonymous JS function"),e.to_js_function=t=>(e.assert_type(t,e.Operator),function(){var n=e.array_to_list(Array.prototype.slice.call(arguments));return e.operate(t,n,e.make_environment())}),e.JS_console_output_stream=class Lisp_js_console_output_stream extends e.Output_stream{constructor(e=console.log){super(),this.buffer="",this.output_function=e}write_byte(t){return e.assert_type(t,"string"),e.assert(1===t.length),this.buffer+=t,t}fresh_line(){return 0===this.buffer.length||"\n"===this.buffer[this.buffer.length-1]?e.f():(this.write_byte("\n"),e.t())}force_output(){return this.buffer.length>0&&(this.output_function(e.utf8_decode(this.buffer)),this.buffer=""),e.void()}},e.define_constant("+js-true+",!0),e.define_constant("+js-false+",!1),e.define_constant("+js-null+",null),e.define_constant("+js-undefined+",void 0),e.define_alien_function("%js-global",e.js_global),e.define_alien_function("%js-new",e.js_new),e.define_alien_function("%js-get",e.js_get),e.define_alien_function("%js-elt",e.js_elt),e.define_alien_function("%to-lisp-boolean",e.to_lisp_boolean),e.define_alien_function("%to-js-boolean",(t=>e.assert_type(t,e.Boolean).to_js_boolean())),e.define_alien_function("%to-lisp-number",(t=>e.num(e.assert_type(t,"number")))),e.define_alien_function("%to-js-number",(t=>e.assert_type(t,e.Number).to_js_number())),e.define_alien_function("%to-lisp-string",(t=>e.str(e.assert_type(t,"string")))),e.define_alien_function("%to-js-string",(t=>e.assert_type(t,e.String).to_js_string())),e.define_alien_function("%to-lisp-function",e.to_lisp_function),e.define_alien_function("%to-js-function",e.to_js_function),e.define_alien_function("%list-to-js-array",e.list_to_array),e.define_alien_function("%js-array-to-list",e.array_to_list),e.define_alien_function("%apply-js-method",e.apply_js_method),e.define_alien_function("%js-log",((...e)=>console.log(...e))),e.define_alien_function("%sleep",(t=>(e.assert_type(t,e.Number),new Promise((e=>setTimeout(e,t.to_js_number())))))),e.define_class("js-console-output-stream",e.JS_console_output_stream,e.Output_stream),e.STANDARD_OUTPUT.set_value(new e.JS_console_output_stream)}n.r(t),n.d(t,{init_js:()=>init_js})},"./src/print.mjs":(e,t,n)=>{function init_print(e){function write_delimited(e,t,n){t.write_byte(n);const r=e.get_utf8_bytes();for(let e=0;e<r.length;e++){const s=r[e];s===n||"\\"===s?(t.write_byte("\\"),t.write_byte(s)):t.write_byte(s)}t.write_byte(n)}function maybe_abbreviate_object_based_on_current_print_level(t,n){const r=e.PRINT_LEVEL_OPTION.get_value(),s=e.CURRENT_PRINT_LEVEL.get_value();r===e.nil()||e.compare(s,r.car())<0?n():t.write_byte("#")}e.PRINT_ESCAPE=e.make_dynamic(e.t()),e.PRINT_LEVEL_OPTION=e.make_dynamic(e.nil()),e.CURRENT_PRINT_LEVEL=e.make_dynamic(e.num(-1)),e.write=(t,n)=>(e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Output_stream),function call_with_increased_current_print_level(t){const n=e.add(e.CURRENT_PRINT_LEVEL.get_value(),e.num(1));e.progv([e.CURRENT_PRINT_LEVEL],[n],t)}((()=>{e.is_lisp_object(t)?t.write_object(n):e.write_js_object(t,n)})),t),e.write_js_object=(t,n)=>{e.write_unreadable_object(t,n)},e.write_unreadable_object=(t,n,r=null)=>{e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Output_stream),n.write_string(e.str("#<")),n.write_string(e.class_of(t).get_name().get_string()),null!==r&&r(),n.write_byte(">")},e.Object.prototype.write_object=function(t){e.write_unreadable_object(this,t)},e.Boolean.prototype.write_object=function(t){t.write_string(this===e.t()?e.str("#t"):e.str("#f"))},e.Nil.prototype.write_object=function(t){t.write_string(e.str("()"))},e.Void.prototype.write_object=function(t){t.write_string(e.str("#void"))},e.Ignore.prototype.write_object=function(t){t.write_string(e.str("#ignore"))},e.Number.prototype.write_object=function(e){e.write_string(this.to_string())},e.Symbol.prototype.write_object=function(t){e.PRINT_ESCAPE.get_value()===e.t()?(t.write_string(function get_symbol_prefix(t){switch(t.get_namespace()){case e.VARIABLE_NAMESPACE:return e.str("");case e.FUNCTION_NAMESPACE:return e.str("#'");case e.CLASS_NAMESPACE:return e.str("#^");case e.KEYWORD_NAMESPACE:return e.str(":");default:e.panic("Unknown symbol namespace")}}(this)),!function symbol_needs_escaping(t){const n=t.get_string().get_utf8_bytes();if(e.parses_as_number(n))return!0;for(let t=0;t<n.length;t++){const r=n[t];if(e.is_whitespace(r)||e.is_terminating_character(r)||"\\"===r)return!0}return!1}(this)?t.write_string(this.get_string()):write_delimited(this.get_string(),t,"|")):t.write_string(this.get_string())},e.String.prototype.write_object=function(t){e.PRINT_ESCAPE.get_value()===e.t()?write_delimited(this,t,'"'):t.write_string(this)},e.Cons.prototype.write_object=function(t){function write_cons(t,n){t.cdr()===e.nil()?e.write(t.car(),n):t.cdr()instanceof e.Cons?(e.write(t.car(),n),n.write_byte(" "),write_cons(t.cdr(),n)):(e.write(t.car(),n),n.write_string(e.str(" . ")),e.write(t.cdr(),n))}maybe_abbreviate_object_based_on_current_print_level(t,(()=>{t.write_byte("("),write_cons(this,t),t.write_byte(")")}))},e.Standard_object.prototype.write_object=function(t){const n="lisp_slot_";maybe_abbreviate_object_based_on_current_print_level(t,(()=>{e.write_unreadable_object(this,t,(()=>{for(const r of Object.getOwnPropertyNames(this).sort())r.startsWith(n)&&(t.write_byte(" "),e.write(e.kwd(r.slice(n.length)),t),t.write_byte(" "),e.write(this[r],t))}))}))},e.write_to_string=t=>{const n=new e.String_output_stream;return e.write(t,n),n.get_string()},e.write_to_js_string=t=>e.write_to_string(t).to_js_string(),e.define_variable("*print-escape*",e.PRINT_ESCAPE),e.define_variable("*print-level?*",e.PRINT_LEVEL_OPTION),e.define_alien_function("%write",((t,n)=>e.write(t,n)))}n.r(t),n.d(t,{init_print:()=>init_print})},"./src/read.mjs":(e,t,n)=>{function init_read(e){const t=e.sym("."),n=e.sym("quote");function read_allowing_dot(t,s=!0,i=e.void()){const o=e.skip_whitespace(t,!1);if(o===e.void())return e.eof(s,i);switch(o){case"(":return e.read_delimited_list(t,")");case'"':return function read_string(e){return read_delimited(e,'"')}(t);case"'":return function read_quote(t){return e.list(n,e.read(t,!0))}(t);case":":return read_namespaced_symbol(t,e.KEYWORD_NAMESPACE);case"#":return function read_sharpsign(t){const n=t.read_byte(!0);if(function is_alpha(e){return/^[a-z]$/.test(e)}(n))return t.unread_byte(n),function read_constant(t){const n=e.read(t,!0);e.assert_type(n,e.Symbol);const s=r[n.get_string().get_utf8_bytes()];if(s)return s;throw new e.Reader_error("Illegal constant")}(t);switch(n){case"'":return read_namespaced_symbol(t,e.FUNCTION_NAMESPACE);case"^":return read_namespaced_symbol(t,e.CLASS_NAMESPACE);default:throw new e.Reader_error(`Illegal dispatching character ${n}`)}}(t);case"|":return function read_escaped_symbol(t){return e.intern(read_delimited(t,"|"))}(t);case")":throw new e.Reader_error("Unbalanced parenthesis");default:return e.is_macro_character(o)?e.call_reader_macro(t,o):(t.unread_byte(o),function read_token(t){let n="";for(;;){const r=t.read_byte(!1);if(r===e.void()||e.is_whitespace(r))break;if(e.is_terminating_character(r)){t.unread_byte(r);break}n+="\\"===r?read_escape_character(t):r}return e.parses_as_number(n)?e.num(n):e.intern(new e.String(n))}(t))}}function read_escape_character(t){const n=t.read_byte(!0);switch(n){case"n":return"\n";case"t":return"\t";case'"':return'"';case"\\":return"\\";case"|":return"|";default:throw new e.Reader_error(`Invalid escape character ${n}`)}}function read_delimited(t,n){let r="";for(;;){const e=t.read_byte(!0);if(e===n)break;"\\"!==e?r+=e:r+=read_escape_character(t)}return new e.String(r)}e.read=(n,r=!0,s=e.void())=>{e.assert_type(n,e.Input_stream),e.assert_type(r,"boolean"),e.assert_type(s,e.TYPE_ANY);const i={},o=read_allowing_dot(n,!1,i);if(o===i)return e.eof(r,s);if(o===t)throw new e.Reader_error("Consing dot not allowed here");return o},e.Reader_error=class Lisp_reader_error extends e.Error{constructor(e){super(e)}},e.is_terminating_character=t=>{switch(t){case"(":case")":case";":case'"':case"'":case"|":return!0;default:return e.is_terminating_macro_character(t)}},e.parses_as_number=e=>/^-?\d+(\.\d+)?$/.test(e),e.read_delimited_list=(n,r)=>{let s=e.nil(),i=s;for(;;){const o=e.skip_whitespace(n,!0);if(o===r)return s;{n.unread_byte(o);const a=read_allowing_dot(n,!0);if(a===t){if(s===e.nil())throw new e.Reader_error("Consing dot at start of list");i.set_cdr(e.read(n,!0));if(e.skip_whitespace(n,!0)===r)return s;throw new e.Reader_error("Multiple objects after consing dot")}{const t=e.cons(a,e.nil());s===e.nil()?(s=t,i=s):(i.set_cdr(t),i=t)}}}};const r={t:e.t(),f:e.f(),nil:e.nil(),void:e.void(),ignore:e.ignore()};function read_namespaced_symbol(t,n){const r=e.read(t,!0);return e.assert_type(r,e.Symbol),r.to_namespace(n)}function skip_block_comment(e){for(;;){const t=e.read_byte(!0);if("|"!==t)"#"!==t||"|"===e.read_byte(!0)&&skip_block_comment(e);else if("#"===e.read_byte(!0))break}}e.skip_whitespace=(t,n=!0,r=e.void())=>{for(;;){const s=t.read_byte(!1);if(s===e.void())return e.eof(n,r);if(!e.is_whitespace(s)){if(";"!==s){if("#"===s){const n=t.read_byte(!1);if("|"===n){skip_block_comment(t);continue}return n===e.void()||t.unread_byte(n),s}return s}e:for(;;){switch(t.read_byte(!1)){case e.void():return e.eof(n,r);case"\n":break e;default:continue e}}}}},e.is_whitespace=e=>{switch(e){case" ":case"\n":case"\t":return!0;default:return!1}};const s={};e.set_macro_character=(e,t,n=!1)=>{s[e]={fun:t,non_terminating_p:n}},e.unset_macro_character=e=>{delete s[e]},e.is_macro_character=e=>void 0!==s[e],e.is_terminating_macro_character=t=>e.is_macro_character(t)&&!s[t].non_terminating_p,e.call_reader_macro=(e,t)=>s[t].fun(e,t).car(),e.eval_stream=function(t,n=e.get_environment()){e.assert_type(t,e.Input_stream),e.assert_type(n,e.Environment);const r={};let s=e.void();for(;;){const i=e.read(t,!1,r);if(i===r)break;s=e.eval_form(i,n)}return s},e.eval_string=function(t,n=e.get_environment()){return e.eval_stream(new e.String_input_stream(t),n)},e.eval_js_string=function(t,n=e.get_environment()){return e.eval_string(e.str(t),n)},e.define_condition("reader-error",e.Reader_error,e.Error),e.define_alien_function("%read",((t,n,r)=>(e.assert_type(n,e.Boolean),e.read(t,n.to_js_boolean(),r))))}n.r(t),n.d(t,{init_read:()=>init_read})},"./src/seq.mjs":(e,t,n)=>{function init_seq(e){function canonicalize_end(t){return t===e.void()?void 0:e.assert_type(t,e.Number).to_js_number()}e.list_star=(...t)=>{const n=t.length;let r=n>=1?t[n-1]:e.nil();for(let s=n-1;s>0;s--)r=e.cons(t[s-1],r);return r},e.append=(t,n)=>(e.assert_type(t,e.List),t===e.nil()?n:e.cons(t.car(),e.append(t.cdr(),n))),e.list_length=t=>(e.assert_type(t,e.List),t===e.nil()?0:1+e.list_length(t.cdr())),e.nthcdr=(t,n)=>{if(e.assert_type(n,e.List),0===t)return n;if(n===e.nil())throw new e.Out_of_bounds_error;return e.nthcdr(t-1,n.cdr())},e.mapcar=(t,n)=>n===e.nil()?e.nil():e.cons(t(n.car()),e.mapcar(t,n.cdr())),e.mapc=(t,n)=>(n!==e.nil()&&(t(n.car()),e.mapc(t,n.cdr())),n),e.list_subseq=(t,n,r)=>{e.assert_type(t,e.List),e.assert_type(n,"number");const s=e.nthcdr(n,t);return void 0===r?s:function take_n(t,n){if(0===n)return e.nil();if(t===e.nil())throw new e.Out_of_bounds_error;return e.cons(t.car(),take_n(t.cdr(),n-1))}(s,r-n)},e.string_subseq=(t,n,r)=>{e.assert_type(t,e.String);const s=t.get_utf8_bytes();return new e.String(e.slice_subseq(s,n,r))},e.slice_subseq=(t,n,r)=>{if(e.assert_type(n,"number"),n>t.length)throw new e.Out_of_bounds_error;if(void 0===r)return t.slice(n);if(r>t.length)throw new e.Out_of_bounds_error;return t.slice(n,r)},e.some=t=>e.list(t),e.optional=(t,n=(()=>e.void()))=>t===e.nil()?n():e.elt(t,0),e.Out_of_bounds_error=class Lisp_out_of_bounds_error extends e.Error{constructor(){super("Out of bounds")}},e.define_alien_function("%list*",((...t)=>e.list_star(...t))),e.define_alien_function("%append",((t,n)=>e.append(t,n))),e.define_alien_function("%list-length",(t=>e.num(e.list_length(t)))),e.define_alien_function("%nth",((t,n)=>e.elt(n,e.assert_type(t,e.Number).to_js_number()))),e.define_alien_function("%nthcdr",((t,n)=>e.nthcdr(e.assert_type(t,e.Number).to_js_number(),n))),e.define_alien_function("%list-subseq",((t,n,r)=>e.list_subseq(t,e.assert_type(n,e.Number).to_js_number(),canonicalize_end(r)))),e.define_alien_function("%string-subseq",((t,n,r)=>e.string_subseq(t,e.assert_type(n,e.Number).to_js_number(),canonicalize_end(r)))),e.define_alien_function("%reverse",(t=>e.reverse(t))),e.define_condition("out-of-bounds-error",e.Out_of_bounds_error,e.Error)}n.r(t),n.d(t,{init_seq:()=>init_seq})},"./src/stream.mjs":(e,t,n)=>{function init_stream(e){e.Input_stream=class Lisp_input_stream extends e.Object{read_byte(t,n){e.abstract_method()}unread_byte(t){e.abstract_method()}peek_byte(t=!1,n=!0,r=e.void()){const s=t?e.skip_whitespace(this,!1):this.read_byte(!1);return s===e.void()?e.eof(n,r):(this.unread_byte(s),s)}},e.String_input_stream=class Lisp_string_input_stream extends e.Input_stream{constructor(t){super(),e.assert_type(t,e.String),this.bytes=t.get_utf8_bytes(),this.pos=-1}read_byte(t=!0,n=e.void()){return e.assert_type(t,"boolean"),e.assert_type(n,e.TYPE_ANY),this.pos+1<this.bytes.length?(this.pos++,this.byte_at_pos(this.pos)):e.eof(t,n)}unread_byte(t){if(e.assert_type(t,"string"),!(this.pos>=0&&this.byte_at_pos(this.pos)===t))throw new e.Stream_error("Cannot unread byte");this.pos--}byte_at_pos(e){return this.bytes[e]}},e.Output_stream=class Lisp_output_stream extends e.Object{write_byte(t){e.abstract_method()}write_string(t){e.assert_type(t,e.String);const n=t.get_utf8_bytes();for(let e=0;e<n.length;e++)this.write_byte(n[e]);return t}force_output(){return e.void()}fresh_line(){return this.write_byte("\n"),e.t()}},e.String_output_stream=class Lisp_string_output_stream extends e.Output_stream{constructor(){super(),this.bytes=""}write_byte(t){return e.assert_type(t,"string"),e.assert(1===t.length),this.bytes+=t,t}get_string(){return new e.String(this.bytes)}},e.eof=(t,n)=>{if(t)throw new e.End_of_file;return n},e.Stream_error=class Lisp_stream_error extends e.Error{constructor(e){super(e)}},e.End_of_file=class Lisp_end_of_file extends e.Stream_error{constructor(){super("EOF")}},e.STANDARD_INPUT=e.make_dynamic(e.void()),e.STANDARD_OUTPUT=e.make_dynamic(e.void()),e.define_class("input-stream",e.Input_stream),e.define_class("string-input-stream",e.String_input_stream,e.Input_stream),e.define_class("output-stream",e.Output_stream),e.define_class("string-output-stream",e.String_output_stream,e.Output_stream),e.define_condition("stream-error",e.Stream_error,e.Error),e.define_condition("end-of-file",e.End_of_file,e.Stream_error),e.define_variable("*standard-input*",e.STANDARD_INPUT),e.define_variable("*standard-output*",e.STANDARD_OUTPUT),e.define_alien_function("%make-string-input-stream",(t=>new e.String_input_stream(t))),e.define_alien_function("%make-string-output-stream",(()=>new e.String_output_stream)),e.define_alien_function("%get-output-stream-string",(t=>e.assert_type(t,e.String_output_stream).get_string())),e.define_alien_function("%fresh-line",(t=>e.assert_type(t,e.Output_stream).fresh_line())),e.define_alien_function("%force-output",(t=>e.assert_type(t,e.Output_stream).force_output()))}n.r(t),n.d(t,{init_stream:()=>init_stream})}},t={};function __webpack_require__(n){var r=t[n];if(void 0!==r)return r.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,__webpack_require__),s.exports}__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{__webpack_require__.r(n),__webpack_require__.d(n,{VM:()=>VM});var e=__webpack_require__("./node_modules/big.js/big.mjs"),t=__webpack_require__("./src/eval.mjs"),r=__webpack_require__("./src/control.mjs"),s=__webpack_require__("./src/seq.mjs"),i=__webpack_require__("./src/stream.mjs"),o=__webpack_require__("./src/read.mjs"),a=__webpack_require__("./src/print.mjs"),l=__webpack_require__("./src/js.mjs"),c=__webpack_require__("./src/boot.lispx"),u=__webpack_require__("./src/cond-sys.lispx"),_=__webpack_require__("./src/stream.lispx"),d=__webpack_require__("./src/read.lispx"),p=__webpack_require__("./src/print.lispx"),f=__webpack_require__("./src/js.lispx");class VM{constructor(){!function init_vm(t){t.Object=class Lisp_object{equal_same_type(e){return this===e}compare_same_type(e){t.abstract_method()}},t.String=class Lisp_string extends t.Object{constructor(e){super(),t.assert_type(e,"string"),this.utf8_bytes=e}equal_same_type(e){return this.get_utf8_bytes()===e.get_utf8_bytes()}to_js_string(){return t.utf8_decode(this.get_utf8_bytes())}get_utf8_bytes(){return this.utf8_bytes}},t.utf8_encode=e=>(t.assert_type(e,"string"),unescape(encodeURIComponent(e))),t.utf8_decode=e=>(t.assert_type(e,"string"),decodeURIComponent(escape(e))),t.Symbol=class Lisp_symbol extends t.Object{constructor(e,n){super(),this.string=t.assert_type(e,t.String),this.namespace=t.assert_type(n,"string")}get_string(){return this.string}get_namespace(){return this.namespace}to_namespace(e){return t.assert_type(e,"string"),t.intern(this.get_string(),e)}to_variable_symbol(){return this.to_namespace(t.VARIABLE_NAMESPACE)}to_function_symbol(){return this.to_namespace(t.FUNCTION_NAMESPACE)}to_class_symbol(){return this.to_namespace(t.CLASS_NAMESPACE)}to_keyword_symbol(){return this.to_namespace(t.KEYWORD_NAMESPACE)}get_key(){return t.Symbol.make_key(this.get_string(),this.get_namespace())}static make_key(e,t){return e.get_utf8_bytes()+"_"+t}},t.VARIABLE_NAMESPACE="variable",t.FUNCTION_NAMESPACE="function",t.CLASS_NAMESPACE="class",t.KEYWORD_NAMESPACE="keyword",t.Number=class Lisp_number extends t.Object{constructor(n){super(),t.assert_type(n,e.default),this.big=n}equal_same_type(e){return this.get_big().eq(e.get_big())}compare_same_type(e){return this.get_big().cmp(e.get_big())}to_js_number(){return this.get_big().toNumber()}to_string(){return t.str(this.get_big().toFixed())}get_big(){return this.big}},t.add=(e,n)=>(t.assert_type(e,t.Number),t.assert_type(n,t.Number),new t.Number(e.get_big().add(n.get_big()))),t.subtract=(e,n)=>(t.assert_type(e,t.Number),t.assert_type(n,t.Number),new t.Number(e.get_big().minus(n.get_big()))),t.multiply=(e,n)=>(t.assert_type(e,t.Number),t.assert_type(n,t.Number),new t.Number(e.get_big().times(n.get_big()))),t.divide=(e,n)=>(t.assert_type(e,t.Number),t.assert_type(n,t.Number),new t.Number(e.get_big().div(n.get_big()))),t.Boolean=class Lisp_boolean extends t.Object{constructor(e){super(),this.bool=t.assert_type(e,"boolean")}to_js_boolean(){return this.bool}},t.List=class Lisp_list extends t.Object{},t.Cons=class Lisp_cons extends t.List{constructor(e,t){super(),this._car=e,this._cdr=t}equal_same_type(e){return t.equal(this.car(),e.car())&&t.equal(this.cdr(),e.cdr())}car(){return this._car}set_car(e){this._car=e}cdr(){return this._cdr}set_cdr(e){this._cdr=e}},t.Nil=class Lisp_nil extends t.List{constructor(){super()}},t.Void=class Lisp_void extends t.Object{constructor(){super()}},t.Ignore=class Lisp_ignore extends t.Object{constructor(){super()}},t.Environment=class Lisp_environment extends t.Object{constructor(e=null){super(),null!==e&&t.assert_type(e,t.Environment),this.parent=e,this.bindings=Object.create(null===e?null:e.get_bindings())}put(e,n){t.assert_type(e,t.Symbol),this.bindings[e.get_key()]=n}lookup(e){t.assert_type(e,t.Symbol);const n=e.get_key(),r=this.bindings[n];if(void 0!==r)return r;if(!(n in this.bindings))throw new t.Unbound_symbol_error(e,this)}is_bound(e){t.assert_type(e,t.Symbol);return e.get_key()in this.bindings}get_bindings(){return this.bindings}},t.Class=class Lisp_class extends t.Object{constructor(e,n,r){super(),this.name=t.assert_type(e,t.Symbol),this.js_class=t.assert_type(n,"function"),this.superclass=t.assert_type(r,t.type_or(t.TYPE_NULL,t.Class))}add_method(e,n){t.assert_type(n,t.Operator);const r=this.method_key(e);this.get_js_class().prototype[r]=n}find_method(e){const n=this.method_key(e),r=this.get_js_class().prototype[n];if(void 0!==r)return r;throw new t.Unbound_method_error(this,e)}method_key(e){t.assert_type(e,t.Symbol);return"lisp_method_"+e.get_string().get_utf8_bytes()}get_name(){return this.name}get_js_class(){return this.js_class}get_superclass(){return this.superclass}},t.Built_in_class=class Lisp_built_in_class extends t.Class{constructor(e,t,n){super(e,t,n)}},t.Standard_class=class Lisp_standard_class extends t.Class{constructor(e,t,n){super(e,t,n)}},t.Standard_object=class Lisp_standard_object extends t.Object{slot_value(e){const n=this.slot_key(e);if(this.hasOwnProperty(n))return this[n];throw new t.Unbound_slot_error(this,e)}set_slot_value(e,t){return this[this.slot_key(e)]=t}is_slot_bound(e){return this.slot_key(e)in this}slot_key(e){t.assert_type(e,t.Symbol);return"lisp_slot_"+e.get_string().get_utf8_bytes()}},t.make_instance=(e,...n)=>{t.assert_type(e,t.Standard_class),t.assert(n.length%2==0);const r=new(e.get_js_class());for(let e=0;e<n.length;e+=2){const t=n[e],s=n[e+1];r.set_slot_value(t,s)}return r},t.is_subclass=(e,n)=>{if(t.assert_type(e,t.Class),t.assert_type(n,t.Class),e===n)return!0;{const t=e.get_js_class(),r=n.get_js_class();return t.prototype instanceof r}},t.make_standard_class=(e,n)=>{t.assert_type(e,t.Symbol),t.assert_type(n,t.Standard_class);const r=n.get_js_class(),s=class extends r{constructor(){super()}},i=e.get_string().to_js_string();Object.defineProperty(s,"name",{value:i});return t.bless_class(e,s,r,t.Standard_class)},t.reinitialize_standard_class=(e,n)=>{t.assert_type(e,t.Standard_class),t.assert_type(n,t.Standard_class);const r=e.get_js_class(),s=n.get_js_class();return Object.setPrototypeOf(r.prototype,s.prototype),e},t.Condition=class Lisp_condition extends t.Standard_object{},t.Error=class Lisp_error extends t.Condition{constructor(e){super();const t=new Error(e);Object.getOwnPropertyNames(t).forEach((e=>{const n=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(this,e,n)}))}},t.Type_error=class Lisp_type_error extends t.Error{constructor(e,n){super("Type assertion failed: expected "+t.write_to_js_string(n)+" got "+t.write_to_js_string(e)),this.lisp_slot_datum=e,this["lisp_slot_expected-type"]=n}},t.make_type_error=(e,n)=>new t.Type_error(e,t.to_lisp_type_spec(n)),t.Unbound_symbol_error=class Lisp_unbound_symbol_error extends t.Error{constructor(e,n){t.assert_type(e,t.Symbol),t.assert_type(n,t.Environment);const r=e.get_string().to_js_string();super(`Unbound ${e.get_namespace()}: ${r}`),this.lisp_slot_symbol=e,this.lisp_slot_environment=n}},t.Unbound_slot_error=class Lisp_unbound_slot_error extends t.Error{constructor(e,n){t.assert_type(e,t.Standard_object),t.assert_type(n,t.Symbol);super(`Unbound slot: ${n.get_string().to_js_string()}`),this.lisp_slot_object=e,this["lisp_slot_slot-name"]=n}},t.Unbound_method_error=class Lisp_unbound_method_error extends t.Error{constructor(e,n){t.assert_type(e,t.Class),t.assert_type(n,t.Symbol);super(`Unbound method: ${n.get_string().to_js_string()}`),this.lisp_slot_class=e,this["lisp_slot_method-name"]=n}},t.Assertion_error=class Lisp_assertion_error extends t.Error{constructor(e){super(e||"Assertion failed")}},t.assert=(e,n="Assertion failed")=>{if(!e)throw new t.Assertion_error(n)},t.abstract_method=()=>{throw new t.Error("You called an abstract method. Congratulations!")},t.has_type=(e,n)=>{if("string"==typeof n)return typeof e===n;if("function"==typeof n)return e instanceof n;if(n&&n.custom_check)return n.custom_check(e);throw new t.Error("Unknown type spec")},t.TYPE_ANY={custom_check:e=>!0,to_lisp_type_spec:()=>t.sym("object")},t.TYPE_NULL={custom_check:e=>null===e,to_lisp_type_spec:()=>t.str("null")},t.type_or=(...e)=>({custom_check(n){for(let r=0;r<e.length;r++)if(t.has_type(n,e[r]))return!0;return!1},to_lisp_type_spec:()=>t.cons(t.sym("or"),t.array_to_list(e.map(t.to_lisp_type_spec)))}),t.assert_type=(e,n)=>{if(t.has_type(e,n))return e;throw t.make_type_error(e,n)},t.to_lisp_type_spec=e=>{if("string"==typeof e)return t.str(e);if("function"==typeof e)return t.has_lisp_class(e)?t.lisp_class(e).get_name():e;if(e&&e.to_lisp_type_spec)return e.to_lisp_type_spec();throw new t.Error("Unknown type spec")},t.elt=(e,n)=>(t.assert_type(e,t.Cons),t.assert_type(n,"number"),0===n?e.car():t.elt(e.cdr(),n-1)),t.list_to_array=e=>{t.assert_type(e,t.List);const n=[];for(;e!==t.nil();)n.push(e.car()),e=e.cdr();return n},t.array_to_list=e=>{t.assert(Array.isArray(e),"Not an array");let n=t.nil();for(let r=e.length;r>0;r--)n=t.cons(e[r-1],n);return n},t.reverse=e=>{t.assert_type(e,t.List);let n=t.nil();for(;e!==t.nil();)n=t.cons(e.car(),n),e=e.cdr();return n},t.environment=t.make_environment(),t.symbols=Object.create(null);const n=new t.Boolean(!0),r=new t.Boolean(!1),s=new t.Nil,i=new t.Void,o=new t.Ignore,a=t.num(0),l=t.num(1);t.t=()=>n,t.f=()=>r,t.nil=()=>s,t.void=()=>i,t.ignore=()=>o,t.zero=()=>a,t.one=()=>l,t.define_class=(e,n,r=t.Object,s=t.Built_in_class)=>{const i=t.sym(e),o=t.bless_class(i,n,r,s);t.get_environment().put(i.to_class_symbol(),o)},t.bless_class=(e,n,r=t.Object,s=t.Built_in_class)=>{t.assert_type(e,t.Symbol),t.assert_type(n,"function"),t.assert_type(r,t.type_or(t.TYPE_NULL,"function")),t.assert_type(s,"function");const i=new s(e,n,r?t.lisp_class(r):null);return n.prototype.lisp_class=i,i},t.define_condition=(e,n,r)=>{t.define_class(e,n,r,t.Standard_class)},t.define_class("object",t.Object,null),t.define_class("string",t.String),t.define_class("symbol",t.Symbol),t.define_class("number",t.Number),t.define_class("boolean",t.Boolean),t.define_class("list",t.List),t.define_class("cons",t.Cons,t.List),t.define_class("nil",t.Nil,t.List),t.define_class("void",t.Void),t.define_class("ignore",t.Ignore),t.define_class("environment",t.Environment),t.define_class("class",t.Class),t.define_class("built-in-class",t.Built_in_class,t.Class),t.define_class("standard-class",t.Standard_class,t.Class),t.define_class("standard-object",t.Standard_object,t.Object,t.Standard_class),t.define_condition("condition",t.Condition,t.Standard_object),t.define_condition("error",t.Error,t.Condition),t.define_condition("type-error",t.Type_error,t.Error),t.define_condition("unbound-symbol-error",t.Unbound_symbol_error,t.Error),t.define_condition("unbound-slot-error",t.Unbound_slot_error,t.Error),t.define_condition("unbound-method-error",t.Unbound_method_error,t.Error),t.define_condition("assertion-error",t.Assertion_error,t.Error)}(this),(0,t.init_eval)(this),(0,r.init_control)(this),(0,s.init_seq)(this),(0,i.init_stream)(this),(0,o.init_read)(this),(0,a.init_print)(this),(0,l.init_js)(this),this.eval_js_string(c.default),this.eval_js_string(u.default),this.eval_js_string(_.default),this.eval_js_string(d.default),this.eval_js_string(p.default),this.eval_js_string(f.default)}str(e){return new this.String(this.utf8_encode(e))}sym(e,t=this.VARIABLE_NAMESPACE){return this.intern(this.str(e),t)}fsym(e){return this.sym(e,this.FUNCTION_NAMESPACE)}csym(e){return this.sym(e,this.CLASS_NAMESPACE)}kwd(e){return this.sym(e,this.KEYWORD_NAMESPACE)}intern(e,t=this.VARIABLE_NAMESPACE){this.assert_type(e,this.String),this.assert_type(t,"string");const n=this.Symbol.make_key(e,t),r=this.symbols[n];return void 0!==r?r:this.symbols[n]=new this.Symbol(e,t)}num(t){return this.assert_type(t,this.type_or("string","number")),new this.Number(new e.default(t))}cons(e,t){return new this.Cons(e,t)}list(...e){return this.array_to_list(e)}make_environment(e=null){return new this.Environment(e)}equal(e,t){return this.is_lisp_object(e)&&this.is_lisp_object(t)&&this.class_of(e)===this.class_of(t)?e.equal_same_type(t):e===t}compare(e,t){if(this.is_lisp_object(e)&&this.is_lisp_object(t)&&this.class_of(e)===this.class_of(t))return e.compare_same_type(t);throw this.make_type_error(t,this.class_of(e).get_js_class())}is_lisp_object(e){return e instanceof this.Object}class_of(e){return this.is_lisp_object(e)?e.lisp_class:this.lisp_class(this.Object)}lisp_class(e){return this.assert_type(e,"function"),this.assert(this.has_lisp_class(e)),e.prototype.lisp_class}has_lisp_class(e){return this.has_type(e.prototype.lisp_class,this.Class)}get_environment(){return this.environment}}})();var r=n.VM;export{r as VM};