!function webpackUniversalModuleDefinition(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["lispx-vm"]=t():e["lispx-vm"]=t()}(this,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{VM:()=>VM});var n=1e6,r=1e6,s="[big.js] ",i=s+"Invalid ",o=i+"decimal places",a=s+"Division by zero",l={},c=void 0,u=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function round(e,t,n,r){var s=e.c;if(n===c&&(n=e.constructor.RM),0!==n&&1!==n&&2!==n&&3!==n)throw Error("[big.js] Invalid rounding mode");if(t<1)r=3===n&&(r||!!s[0])||0===t&&(1===n&&s[0]>=5||2===n&&(s[0]>5||5===s[0]&&(r||s[1]!==c))),s.length=1,r?(e.e=e.e-t+1,s[0]=1):s[0]=e.e=0;else if(t<s.length){if(r=1===n&&s[t]>=5||2===n&&(s[t]>5||5===s[t]&&(r||s[t+1]!==c||1&s[t-1]))||3===n&&(r||!!s[0]),s.length=t,r)for(;++s[--t]>9;)if(s[t]=0,0===t){++e.e,s.unshift(1);break}for(t=s.length;!s[--t];)s.pop()}return e}function stringify(e,t,n){var r=e.e,s=e.c.join(""),i=s.length;if(t)s=s.charAt(0)+(i>1?"."+s.slice(1):"")+(r<0?"e":"e+")+r;else if(r<0){for(;++r;)s="0"+s;s="0."+s}else if(r>0)if(++r>i)for(r-=i;r--;)s+="0";else r<i&&(s=s.slice(0,r)+"."+s.slice(r));else i>1&&(s=s.charAt(0)+"."+s.slice(1));return e.s<0&&n?"-"+s:s}l.abs=function(){var e=new this.constructor(this);return e.s=1,e},l.cmp=function(e){var t,n=this,r=n.c,s=(e=new n.constructor(e)).c,i=n.s,o=e.s,a=n.e,l=e.e;if(!r[0]||!s[0])return r[0]?i:s[0]?-o:0;if(i!=o)return i;if(t=i<0,a!=l)return a>l^t?1:-1;for(o=(a=r.length)<(l=s.length)?a:l,i=-1;++i<o;)if(r[i]!=s[i])return r[i]>s[i]^t?1:-1;return a==l?0:a>l^t?1:-1},l.div=function(e){var t=this,r=t.constructor,s=t.c,i=(e=new r(e)).c,l=t.s==e.s?1:-1,u=r.DP;if(u!==~~u||u<0||u>n)throw Error(o);if(!i[0])throw Error(a);if(!s[0])return e.s=l,e.c=[e.e=0],e;var _,d,p,f,m,b=i.slice(),h=_=i.length,y=s.length,g=s.slice(0,_),v=g.length,w=e,j=w.c=[],k=0,E=u+(w.e=t.e-e.e)+1;for(w.s=l,l=E<0?0:E,b.unshift(0);v++<_;)g.push(0);do{for(p=0;p<10;p++){if(_!=(v=g.length))f=_>v?1:-1;else for(m=-1,f=0;++m<_;)if(i[m]!=g[m]){f=i[m]>g[m]?1:-1;break}if(!(f<0))break;for(d=v==_?i:b;v;){if(g[--v]<d[v]){for(m=v;m&&!g[--m];)g[m]=9;--g[m],g[v]+=10}g[v]-=d[v]}for(;!g[0];)g.shift()}j[k++]=f?p:++p,g[0]&&f?g[v]=s[h]||0:g=[s[h]]}while((h++<y||g[0]!==c)&&l--);return j[0]||1==k||(j.shift(),w.e--,E--),k>E&&round(w,E,r.RM,g[0]!==c),w},l.eq=function(e){return 0===this.cmp(e)},l.gt=function(e){return this.cmp(e)>0},l.gte=function(e){return this.cmp(e)>-1},l.lt=function(e){return this.cmp(e)<0},l.lte=function(e){return this.cmp(e)<1},l.minus=l.sub=function(e){var t,n,r,s,i=this,o=i.constructor,a=i.s,l=(e=new o(e)).s;if(a!=l)return e.s=-l,i.plus(e);var c=i.c.slice(),u=i.e,_=e.c,d=e.e;if(!c[0]||!_[0])return _[0]?e.s=-l:c[0]?e=new o(i):e.s=1,e;if(a=u-d){for((s=a<0)?(a=-a,r=c):(d=u,r=_),r.reverse(),l=a;l--;)r.push(0);r.reverse()}else for(n=((s=c.length<_.length)?c:_).length,a=l=0;l<n;l++)if(c[l]!=_[l]){s=c[l]<_[l];break}if(s&&(r=c,c=_,_=r,e.s=-e.s),(l=(n=_.length)-(t=c.length))>0)for(;l--;)c[t++]=0;for(l=t;n>a;){if(c[--n]<_[n]){for(t=n;t&&!c[--t];)c[t]=9;--c[t],c[n]+=10}c[n]-=_[n]}for(;0===c[--l];)c.pop();for(;0===c[0];)c.shift(),--d;return c[0]||(e.s=1,c=[d=0]),e.c=c,e.e=d,e},l.mod=function(e){var t,n=this,r=n.constructor,s=n.s,i=(e=new r(e)).s;if(!e.c[0])throw Error(a);return n.s=e.s=1,t=1==e.cmp(n),n.s=s,e.s=i,t?new r(n):(s=r.DP,i=r.RM,r.DP=r.RM=0,n=n.div(e),r.DP=s,r.RM=i,this.minus(n.times(e)))},l.neg=function(){var e=new this.constructor(this);return e.s=-e.s,e},l.plus=l.add=function(e){var t,n,r,s=this,i=s.constructor;if(e=new i(e),s.s!=e.s)return e.s=-e.s,s.minus(e);var o=s.e,a=s.c,l=e.e,c=e.c;if(!a[0]||!c[0])return c[0]||(a[0]?e=new i(s):e.s=s.s),e;if(a=a.slice(),t=o-l){for(t>0?(l=o,r=c):(t=-t,r=a),r.reverse();t--;)r.push(0);r.reverse()}for(a.length-c.length<0&&(r=c,c=a,a=r),t=c.length,n=0;t;a[t]%=10)n=(a[--t]=a[t]+c[t]+n)/10|0;for(n&&(a.unshift(n),++l),t=a.length;0===a[--t];)a.pop();return e.c=a,e.e=l,e},l.pow=function(e){var t=this,n=new t.constructor("1"),s=n,o=e<0;if(e!==~~e||e<-1e6||e>r)throw Error(i+"exponent");for(o&&(e=-e);1&e&&(s=s.times(t)),e>>=1;)t=t.times(t);return o?n.div(s):s},l.prec=function(e,t){if(e!==~~e||e<1||e>n)throw Error(i+"precision");return round(new this.constructor(this),e,t)},l.round=function(e,t){if(e===c)e=0;else if(e!==~~e||e<-n||e>n)throw Error(o);return round(new this.constructor(this),e+this.e+1,t)},l.sqrt=function(){var e,t,n,r=this,i=r.constructor,o=r.s,a=r.e,l=new i("0.5");if(!r.c[0])return new i(r);if(o<0)throw Error(s+"No square root");0===(o=Math.sqrt(r+""))||o===1/0?((t=r.c.join("")).length+a&1||(t+="0"),a=((a+1)/2|0)-(a<0||1&a),e=new i(((o=Math.sqrt(t))==1/0?"5e":(o=o.toExponential()).slice(0,o.indexOf("e")+1))+a)):e=new i(o+""),a=e.e+(i.DP+=4);do{n=e,e=l.times(n.plus(r.div(n)))}while(n.c.slice(0,a).join("")!==e.c.slice(0,a).join(""));return round(e,(i.DP-=4)+e.e+1,i.RM)},l.times=l.mul=function(e){var t,n=this,r=n.constructor,s=n.c,i=(e=new r(e)).c,o=s.length,a=i.length,l=n.e,c=e.e;if(e.s=n.s==e.s?1:-1,!s[0]||!i[0])return e.c=[e.e=0],e;for(e.e=l+c,o<a&&(t=s,s=i,i=t,c=o,o=a,a=c),t=new Array(c=o+a);c--;)t[c]=0;for(l=a;l--;){for(a=0,c=o+l;c>l;)a=t[c]+i[l]*s[c-l-1]+a,t[c--]=a%10,a=a/10|0;t[c]=a}for(a?++e.e:t.shift(),l=t.length;!t[--l];)t.pop();return e.c=t,e},l.toExponential=function(e,t){var r=this,s=r.c[0];if(e!==c){if(e!==~~e||e<0||e>n)throw Error(o);for(r=round(new r.constructor(r),++e,t);r.c.length<e;)r.c.push(0)}return stringify(r,!0,!!s)},l.toFixed=function(e,t){var r=this,s=r.c[0];if(e!==c){if(e!==~~e||e<0||e>n)throw Error(o);for(e=e+(r=round(new r.constructor(r),e+r.e+1,t)).e+1;r.c.length<e;)r.c.push(0)}return stringify(r,!1,!!s)},l[Symbol.for("nodejs.util.inspect.custom")]=l.toJSON=l.toString=function(){var e=this,t=e.constructor;return stringify(e,e.e<=t.NE||e.e>=t.PE,!!e.c[0])},l.toNumber=function(){var e=Number(stringify(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(e.toString()))throw Error(s+"Imprecise conversion");return e},l.toPrecision=function(e,t){var r=this,s=r.constructor,o=r.c[0];if(e!==c){if(e!==~~e||e<1||e>n)throw Error(i+"precision");for(r=round(new s(r),e,t);r.c.length<e;)r.c.push(0)}return stringify(r,e<=r.e||r.e<=s.NE||r.e>=s.PE,!!o)},l.valueOf=function(){var e=this,t=e.constructor;if(!0===t.strict)throw Error(s+"valueOf disallowed");return stringify(e,e.e<=t.NE||e.e>=t.PE,!0)};var _=function _Big_(){function Big(e){var t=this;if(!(t instanceof Big))return e===c?_Big_():new Big(e);if(e instanceof Big)t.s=e.s,t.e=e.e,t.c=e.c.slice();else{if("string"!=typeof e){if(!0===Big.strict&&"bigint"!=typeof e)throw TypeError(i+"value");e=0===e&&1/e<0?"-0":String(e)}!function parse(e,t){var n,r,s;if(!u.test(t))throw Error(i+"number");e.s="-"==t.charAt(0)?(t=t.slice(1),-1):1,(n=t.indexOf("."))>-1&&(t=t.replace(".",""));(r=t.search(/e/i))>0?(n<0&&(n=r),n+=+t.slice(r+1),t=t.substring(0,r)):n<0&&(n=t.length);for(s=t.length,r=0;r<s&&"0"==t.charAt(r);)++r;if(r==s)e.c=[e.e=0];else{for(;s>0&&"0"==t.charAt(--s););for(e.e=n-r-1,e.c=[],n=0;r<=s;)e.c[n++]=+t.charAt(r++)}return e}(t,e)}t.constructor=Big}return Big.prototype=l,Big.DP=20,Big.RM=1,Big.NE=-7,Big.PE=21,Big.strict=false,Big.roundDown=0,Big.roundHalfUp=1,Big.roundHalfEven=2,Big.roundUp=3,Big}();const d=_;function init_eval(e){e.eval=(t,n=e.get_environment())=>e.trap_exceptions((()=>(e.assert_type(n,e.Environment),t instanceof e.Symbol?function evaluate_symbol(t,n){return t.get_namespace()===e.KEYWORD_NAMESPACE?t:n.lookup(t)}(t,n):t instanceof e.Cons?function evaluate_cons(t,n){return e.bind((()=>function evaluate_operator(t,n){return t instanceof e.Symbol?e.trap_exceptions((()=>n.lookup(t.to_function_symbol()))):e.eval(t,n)}(t.car(),n)),(r=>e.operate(r,t.cdr(),n)),e.trace(t,n))}(t,n):t))),e.operate=(t,n,r=e.get_environment())=>e.trap_exceptions((()=>(e.assert_type(t,e.Operator),e.assert_type(n,e.TYPE_ANY),e.assert_type(r,e.Environment),t.operate(n,r))));const t=e.type_or(e.Symbol,e.Ignore),n=e.type_or(e.Symbol,e.Ignore,e.List);e.match=(t,r,s)=>{if(t instanceof e.Symbol)if(t.get_namespace()===e.KEYWORD_NAMESPACE){if(t!==r)throw new e.Match_error(t,r)}else s.put(t,r);else if(t instanceof e.Cons){if(!(r instanceof e.Cons))throw new e.Match_error(t,r);e.match(t.car(),r.car(),s),e.match(t.cdr(),r.cdr(),s)}else if(t===e.nil()){if(r!==e.nil())throw new e.Match_error(t,r)}else if(t!==e.ignore())throw e.make_type_error(t,n);return r},e.Match_error=class Lisp_match_error extends e.Error{constructor(t,n){super("Match error: "+e.write_to_js_string(t)+" vs "+e.write_to_js_string(n)),this.lisp_slot_definiend=t,this.lisp_slot_value=n}},e.Operator=class Lisp_operator extends e.Object{operate(t,n){e.abstract_method()}},e.Fexpr=class Lisp_fexpr extends e.Operator{constructor(r,s,i,o){super(),this.param_tree=e.assert_type(r,n),this.env_param=e.assert_type(s,t),this.body_form=e.assert_type(i,e.TYPE_ANY),this.def_env=e.assert_type(o,e.Environment)}operate(t,n){const r=e.make_environment(this.def_env);return e.match(this.param_tree,t,r),e.match(this.env_param,n,r),e.eval(this.body_form,r)}},e.Function=class Lisp_function extends e.Operator{constructor(t){super(),e.assert_type(t,e.Operator),this.wrapped_operator=t}operate(t,n){return e.bind((()=>eval_args(t,e.nil())),(t=>e.operate(this.wrapped_operator,t,n)));function eval_args(t,r){return t===e.nil()?e.reverse(r):e.bind((()=>e.eval(t.car(),n)),(n=>eval_args(t.cdr(),e.cons(n,r))),e.trace(t.car(),n))}}unwrap(){return this.wrapped_operator}},e.wrap=t=>new e.Function(t),e.Built_in_operator=class Lisp_built_in_operator extends e.Operator{constructor(t){super(),e.assert_type(t,"function"),this.operate_function=t}operate(e,t){return this.operate_function(e,t)}},e.built_in_operator=t=>new e.Built_in_operator(t),e.built_in_function=t=>e.wrap(e.built_in_operator(t)),e.alien_operator=t=>(e.assert_type(t,"function"),e.built_in_operator((function operate_function(n,r){return t.apply(null,e.list_to_array(n))}))),e.alien_function=t=>e.wrap(e.alien_operator(t)),e.trap_exceptions=t=>{try{return t()}catch(t){if(t instanceof e.Nonlocal_exit||t instanceof e.Panic)throw t;return e.call_user_error_handler(t)}},e.call_user_error_handler=t=>{const n=e.get_environment(),r=e.fsym("error");if(n.is_bound(r))return e.operate(n.lookup(r),e.list(t),e.make_environment());e.panic(t)},e.Panic=class Panic extends Error{constructor(e){e&&e.message?super("LISP panic: "+e.message):super("LISP panic!"),this.cause=e}},e.panic=t=>{throw new e.Panic(t)},e.define_variable=(t,n)=>{e.get_environment().put(e.sym(t),n)},e.define_constant=(t,n)=>{e.define_variable(t,n)},e.define_operator=(t,n)=>{e.get_environment().put(e.fsym(t),n)},e.define_built_in_operator=(t,n)=>{e.define_operator(t,e.built_in_operator(n))},e.define_built_in_function=(t,n)=>{e.define_operator(t,e.built_in_function(n))},e.define_alien_function=(t,n)=>{e.define_operator(t,e.alien_function(n))},e.define_class("operator",e.Operator),e.define_class("built-in-operator",e.Built_in_operator,e.Operator),e.define_class("fexpr",e.Fexpr,e.Operator),e.define_class("function",e.Function,e.Operator),e.define_condition("match-error",e.Match_error,e.Error),e.define_built_in_operator("%vau",(function VAU(t,n){const r=e.elt(t,0),s=e.elt(t,1),i=e.elt(t,2),o=n;return new e.Fexpr(r,s,i,o)})),e.define_built_in_operator("%def",(function DEF(t,n){const r=e.elt(t,0),s=e.elt(t,1);return e.bind((()=>e.eval(s,n)),(t=>e.match(r,t,n)),e.trace(s,n))})),e.define_built_in_operator("%progn",(function PROGN(t,n){return t===e.nil()?e.void():function progn(t){return e.bind((()=>e.eval(t.car(),n)),(n=>t.cdr()===e.nil()?n:progn(t.cdr())),e.trace(t.car(),n))}(t)})),e.define_built_in_operator("%if",(function IF(t,n){const r=e.elt(t,0),s=e.elt(t,1),i=e.elt(t,2);return e.bind((()=>e.eval(r,n)),(t=>(e.assert_type(t,e.Boolean),t==e.t()?e.eval(s,n):e.eval(i,n))),e.trace(r,n))})),e.define_alien_function("%wrap",(t=>e.wrap(t))),e.define_alien_function("%unwrap",(t=>e.assert_type(t,e.Function).unwrap())),e.define_alien_function("%eval",((t,n)=>e.eval(t,n))),e.define_alien_function("%eq",((t,n)=>e.to_lisp_boolean(t===n))),e.define_alien_function("%=",((t,n)=>e.to_lisp_boolean(e.equal(t,n)))),e.define_alien_function("%<",((t,n)=>e.to_lisp_boolean(e.compare(t,n)<0))),e.define_alien_function("%>",((t,n)=>e.to_lisp_boolean(e.compare(t,n)>0))),e.define_alien_function("%<=",((t,n)=>e.to_lisp_boolean(e.compare(t,n)<=0))),e.define_alien_function("%>=",((t,n)=>e.to_lisp_boolean(e.compare(t,n)>=0))),e.define_alien_function("%+",((t,n)=>e.add(t,n))),e.define_alien_function("%-",((t,n)=>e.subtract(t,n))),e.define_alien_function("%*",((t,n)=>e.multiply(t,n))),e.define_alien_function("%/",((t,n)=>e.divide(t,n))),e.define_alien_function("%cons",((t,n)=>e.cons(t,n))),e.define_alien_function("%car",(t=>e.assert_type(t,e.Cons).car())),e.define_alien_function("%cdr",(t=>e.assert_type(t,e.Cons).cdr())),e.define_alien_function("%intern",(t=>e.intern(t))),e.define_alien_function("%symbol-name",(t=>e.assert_type(t,e.Symbol).get_string())),e.define_alien_function("%variable-symbol",(t=>e.assert_type(t,e.Symbol).to_variable_symbol())),e.define_alien_function("%function-symbol",(t=>e.assert_type(t,e.Symbol).to_function_symbol())),e.define_alien_function("%class-symbol",(t=>e.assert_type(t,e.Symbol).to_class_symbol())),e.define_alien_function("%keyword-symbol",(t=>e.assert_type(t,e.Symbol).to_keyword_symbol())),e.define_alien_function("%make-environment",((t=null)=>e.make_environment(t))),e.define_alien_function("%boundp",((t,n)=>e.to_lisp_boolean(e.assert_type(n,e.Environment).is_bound(t)))),e.define_alien_function("%class-of",(t=>e.class_of(t))),e.define_alien_function("%typep",((t,n)=>e.to_lisp_boolean(e.is_subclass(e.class_of(t),n)))),e.define_alien_function("%make-instance",((t,...n)=>e.make_instance(t,...n))),e.define_alien_function("%slot-value",((t,n)=>e.assert_type(t,e.Standard_object).slot_value(n))),e.define_alien_function("%set-slot-value",((t,n,r)=>e.assert_type(t,e.Standard_object).set_slot_value(n,r))),e.define_alien_function("%slot-bound-p",((t,n)=>e.to_lisp_boolean(e.assert_type(t,e.Standard_object).is_slot_bound(n)))),e.define_alien_function("%add-method",((t,n,r)=>e.assert_type(t,e.Class).add_method(n,r))),e.define_alien_function("%find-method",((t,n)=>e.assert_type(t,e.Class).find_method(n))),e.define_alien_function("%make-standard-class",((t,n)=>e.make_standard_class(t,n))),e.define_alien_function("%reinitialize-standard-class",((t,n)=>e.reinitialize_standard_class(t,n))),e.define_alien_function("%class-name",(t=>e.assert_type(t,e.Class).get_name())),e.define_alien_function("%subclassp",((t,n)=>e.to_lisp_boolean(e.is_subclass(t,n)))),e.define_alien_function("%panic",(t=>e.panic(t)))}function init_control(e){e.Continuation=class Lisp_continuation extends e.Object{constructor(t,n,r){super(),e.assert_type(t,"function"),e.assert_type(n,e.type_or(e.TYPE_NULL,e.Continuation)),this.work_fun=t,this.inner=n,this.trace=r}},e.Suspension=class Suspension{constructor(t,n){e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Function),this.prompt=t,this.handler=n,this.continuation=null}suspend(t,n){return e.assert_type(t,"function"),this.continuation=new e.Continuation(t,this.continuation,n),this}},e.Resumption=class Resumption{constructor(t,n){e.assert_type(t,e.Continuation),e.assert_type(n,e.Function),this.continuation=t,this.handler=n}resume(){const e=this.continuation;return this.continuation=e.inner,e.work_fun(this)}};class Trace{constructor(e,t){this.expr=e,this.env=t}}function do_bind(t,n,r,s=null){let i;return i=s instanceof e.Resumption?s.resume():t(),i instanceof e.Suspension?i.suspend((e=>do_bind(t,n,r,e)),r):n(i)}function do_progv(t,n,r,s,i=null){return e.progv(t,n,(()=>{let o;return o=i instanceof e.Resumption?i.resume():e.operate(r,e.nil(),s),o instanceof e.Suspension?o.suspend((e=>do_progv(t,n,r,s,e))):o}))}function do_loop(t,n,r=null){let s=!0;for(;;){let i;if(s&&r instanceof e.Resumption?(s=!1,i=r.resume()):i=e.eval(t,n),i instanceof e.Suspension)return i.suspend((e=>do_loop(t,n,e)))}}function do_catch(t,n,r,s=null){try{let i;return i=s instanceof e.Resumption?s.resume():e.operate(n,e.nil(),r),i instanceof e.Suspension?i.suspend((e=>do_catch(t,n,r,e))):i}catch(n){if(n instanceof e.Nonlocal_exit&&n.tag===t)return n.value;throw n}}function do_unwind_protect_1(t,n,r,s=null){try{let i;return i=s instanceof e.Resumption?s.resume():e.eval(t,r),i instanceof e.Suspension?i.suspend((e=>do_unwind_protect_1(t,n,r,e))):do_unwind_protect_2(n,i,!0,r)}catch(e){return do_unwind_protect_2(n,e,!1,r)}}function do_unwind_protect_2(t,n,r,s,i=null){let o;if(o=i instanceof e.Resumption?i.resume():e.eval(t,s),o instanceof e.Suspension)return o.suspend((e=>do_unwind_protect_2(t,n,r,s,e)));if(r)return n;throw n}e.trace=(e,t)=>new Trace(e,t),e.bind=(t,n,r)=>(e.assert_type(t,"function"),e.assert_type(n,"function"),do_bind(t,n,r)),e.push_prompt=(t,n,r,s=null)=>{let i;return i=s instanceof e.Resumption?s.resume():n(),i instanceof e.Suspension?e.equal(t,i.prompt)?e.operate(i.handler,e.list(i.continuation),r):i.suspend((s=>e.push_prompt(t,n,r,s))):i},e.push_subcont_barrier=(t,n,r=null)=>{let s;if(s=r instanceof e.Resumption?r.resume():t(),s instanceof e.Suspension){s.suspend((r=>e.push_subcont_barrier(t,n,r)));const r=e.alien_function((()=>{throw new e.Prompt_not_found_error(s.prompt)}));return new e.Resumption(s.continuation,r).resume()}return s},e.Prompt_not_found_error=class Lisp_prompt_not_found_error extends e.Error{constructor(t){super("Prompt not found: "+e.write_to_js_string(t)),this.lisp_slot_prompt=t}},e.Dynamic=class Lisp_dynamic extends e.Standard_object{constructor(t=e.void()){super(),this.lisp_slot_value=t}get_value(){return this.lisp_slot_value}set_value(e){this.lisp_slot_value=e}},e.make_dynamic=(t=e.void())=>new e.Dynamic(t),e.progv=(t,n,r)=>{e.assert(t.length===n.length);const s=[];for(let r=0;r<t.length;r++){const i=e.assert_type(t[r],e.Dynamic);s[r]=i.get_value(),i.set_value(n[r])}try{return r()}finally{for(let e=0;e<t.length;e++)t[e].set_value(s[e])}},e.Nonlocal_exit=class Nonlocal_exit{constructor(e,t){this.tag=e,this.value=t}};const t=e.sym("root-prompt");e.eval_form=(n,r=e.get_environment())=>e.push_subcont_barrier((()=>e.push_prompt(t,(()=>e.eval(n,r)),r)),r),e.define_class("continuation",e.Continuation),e.define_class("dynamic",e.Dynamic,e.Standard_object,e.Standard_class),e.define_condition("prompt-not-found-error",e.Prompt_not_found_error,e.Error),e.define_built_in_function("%take-subcont",(function TAKE_SUBCONT(t,n){var r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Function);return new e.Suspension(r,s).suspend((t=>e.operate(t.handler,e.nil(),n)))})),e.define_built_in_function("%push-prompt",(function PUSH_PROMPT(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Function);return e.push_prompt(r,(()=>e.operate(s,e.nil(),n)),n)})),e.define_built_in_function("%push-delim-subcont",(function PUSH_DELIM_SUBCONT(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.Continuation),i=e.assert_type(e.elt(t,2),e.Function);return e.push_prompt(r,(()=>new e.Resumption(s,i).resume()),n)})),e.define_built_in_function("%push-subcont-barrier",(function PUSH_SUBCONT_BARRIER(t,n){const r=e.assert_type(e.elt(t,0),e.Function);return e.push_subcont_barrier((()=>e.operate(r,e.nil(),n)),n)})),e.define_built_in_function("%progv",(function PROGV(t,n){return do_progv(e.list_to_array(e.elt(t,0)),e.list_to_array(e.elt(t,1)),e.assert_type(e.elt(t,2),e.Function),n)})),e.define_built_in_operator("%loop",(function LOOP(t,n){return do_loop(e.assert_type(e.elt(t,0),e.TYPE_ANY),n)})),e.define_built_in_function("%catch",(function CATCH(t,n){return do_catch(e.assert_type(e.elt(t,0),e.TYPE_ANY),e.assert_type(e.elt(t,1),e.Function),n)})),e.define_built_in_function("%throw",(function THROW(t,n){const r=e.assert_type(e.elt(t,0),e.TYPE_ANY),s=e.assert_type(e.elt(t,1),e.TYPE_ANY);throw new e.Nonlocal_exit(r,s)})),e.define_built_in_operator("%unwind-protect",(function UNWIND_PROTECT(t,n){return do_unwind_protect_1(e.assert_type(e.elt(t,0),e.TYPE_ANY),e.assert_type(e.elt(t,1),e.TYPE_ANY),n)})),e.define_constant("+root-prompt+",t),e.define_alien_function("%print-stacktrace",(function print_stacktrace(t){e.assert_type(t,e.Continuation);const n=[];do{t.trace&&n.push(t.trace.expr)}while(t=t.inner);n.reverse();const r=e.STANDARD_OUTPUT.get_value();n.slice(28,37).forEach((t=>{r.fresh_line(),e.write(t,r),r.force_output()}))}))}function init_read(e){const t=e.sym("."),n=e.sym("quote");function read_allowing_dot(t,s=!0,i=e.void()){const o=e.skip_whitespace(t,!1);if(o===e.void())return e.eof(s,i);switch(o){case"(":return e.read_delimited_list(t,")");case'"':return function read_string(e){return read_delimited(e,'"')}(t);case"'":return function read_quote(t){return e.list(n,e.read(t,!0))}(t);case":":return read_namespaced_symbol(t,e.KEYWORD_NAMESPACE);case"#":return function read_sharpsign(t){const n=t.read_byte(!0);if(function is_alpha(e){return/^[a-z]$/.test(e)}(n))return t.unread_byte(n),function read_constant(t){const n=e.read(t,!0);e.assert_type(n,e.Symbol);const s=r[n.get_string().get_utf8_bytes()];if(s)return s;throw new e.Reader_error("Illegal constant")}(t);switch(n){case"'":return read_namespaced_symbol(t,e.FUNCTION_NAMESPACE);case"^":return read_namespaced_symbol(t,e.CLASS_NAMESPACE);default:throw new e.Reader_error(`Illegal dispatching character ${n}`)}}(t);case"|":return function read_escaped_symbol(t){return e.intern(read_delimited(t,"|"))}(t);case")":throw new e.Reader_error("Unbalanced parenthesis");default:return e.is_macro_character(o)?e.call_reader_macro(t,o):(t.unread_byte(o),function read_token(t){let n="";for(;;){const r=t.read_byte(!1);if(r===e.void()||e.is_whitespace(r))break;if(e.is_terminating_character(r)){t.unread_byte(r);break}n+="\\"===r?read_escape_character(t):r}return e.parses_as_number(n)?e.num(n):e.intern(new e.String(n))}(t))}}function read_escape_character(t){const n=t.read_byte(!0);switch(n){case"n":return"\n";case"t":return"\t";case'"':return'"';case"\\":return"\\";case"|":return"|";default:throw new e.Reader_error(`Invalid escape character ${n}`)}}function read_delimited(t,n){let r="";for(;;){const e=t.read_byte(!0);if(e===n)break;"\\"!==e?r+=e:r+=read_escape_character(t)}return new e.String(r)}e.read=(n,r=!0,s=e.void())=>{e.assert_type(n,e.Input_stream),e.assert_type(r,"boolean"),e.assert_type(s,e.TYPE_ANY);const i={},o=read_allowing_dot(n,!1,i);if(o===i)return e.eof(r,s);if(o===t)throw new e.Reader_error("Consing dot not allowed here");return o},e.Reader_error=class Lisp_reader_error extends e.Error{constructor(e){super(e)}},e.is_terminating_character=t=>{switch(t){case"(":case")":case";":case'"':case"'":case"|":return!0;default:return e.is_terminating_macro_character(t)}},e.parses_as_number=e=>/^-?\d+(\.\d+)?$/.test(e),e.read_delimited_list=(n,r)=>{let s=e.nil(),i=s;for(;;){const o=e.skip_whitespace(n,!0);if(o===r)return s;{n.unread_byte(o);const a=read_allowing_dot(n,!0);if(a===t){if(s===e.nil())throw new e.Reader_error("Consing dot at start of list");i.set_cdr(e.read(n,!0));if(e.skip_whitespace(n,!0)===r)return s;throw new e.Reader_error("Multiple objects after consing dot")}{const t=e.cons(a,e.nil());s===e.nil()?(s=t,i=s):(i.set_cdr(t),i=t)}}}};const r={t:e.t(),f:e.f(),nil:e.nil(),void:e.void(),ignore:e.ignore()};function read_namespaced_symbol(t,n){const r=e.read(t,!0);return e.assert_type(r,e.Symbol),r.to_namespace(n)}function skip_block_comment(e){for(;;){const t=e.read_byte(!0);if("|"!==t)"#"!==t||"|"===e.read_byte(!0)&&skip_block_comment(e);else if("#"===e.read_byte(!0))break}}e.skip_whitespace=(t,n=!0,r=e.void())=>{for(;;){const s=t.read_byte(!1);if(s===e.void())return e.eof(n,r);if(!e.is_whitespace(s)){if(";"!==s){if("#"===s){const n=t.read_byte(!1);if("|"===n){skip_block_comment(t);continue}return n===e.void()||t.unread_byte(n),s}return s}e:for(;;){switch(t.read_byte(!1)){case e.void():return e.eof(n,r);case"\n":break e;default:continue e}}}}},e.is_whitespace=e=>{switch(e){case" ":case"\n":case"\t":return!0;default:return!1}};const s={};e.set_macro_character=(e,t,n=!1)=>{s[e]={fun:t,non_terminating_p:n}},e.unset_macro_character=e=>{delete s[e]},e.is_macro_character=e=>void 0!==s[e],e.is_terminating_macro_character=t=>e.is_macro_character(t)&&!s[t].non_terminating_p,e.call_reader_macro=(e,t)=>s[t].fun(e,t).car(),e.eval_stream=function(t,n=e.get_environment()){e.assert_type(t,e.Input_stream),e.assert_type(n,e.Environment);const r={};let s=e.void();for(;;){const i=e.read(t,!1,r);if(i===r)break;s=e.eval_form(i,n)}return s},e.eval_string=function(t,n=e.get_environment()){return e.eval_stream(new e.String_input_stream(t),n)},e.eval_js_string=function(t,n=e.get_environment()){return e.eval_string(e.str(t),n)},e.define_condition("reader-error",e.Reader_error,e.Error),e.define_alien_function("%read",((t,n,r)=>(e.assert_type(n,e.Boolean),e.read(t,n.to_js_boolean(),r))))}function init_print(e){function write_delimited(e,t,n){t.write_byte(n);const r=e.get_utf8_bytes();for(let e=0;e<r.length;e++){const s=r[e];s===n||"\\"===s?(t.write_byte("\\"),t.write_byte(s)):t.write_byte(s)}t.write_byte(n)}function maybe_abbreviate_object_based_on_current_print_level(t,n){const r=e.PRINT_LEVEL_OPTION.get_value(),s=e.CURRENT_PRINT_LEVEL.get_value();r===e.nil()||e.compare(s,r.car())<0?n():t.write_byte("#")}e.PRINT_ESCAPE=e.make_dynamic(e.t()),e.PRINT_LEVEL_OPTION=e.make_dynamic(e.nil()),e.CURRENT_PRINT_LEVEL=e.make_dynamic(e.num(-1)),e.write=(t,n)=>(e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Output_stream),function call_with_increased_current_print_level(t){const n=e.add(e.CURRENT_PRINT_LEVEL.get_value(),e.num(1));e.progv([e.CURRENT_PRINT_LEVEL],[n],t)}((()=>{e.is_lisp_object(t)?t.write_object(n):e.write_js_object(t,n)})),t),e.write_js_object=(t,n)=>{e.write_unreadable_object(t,n)},e.write_unreadable_object=(t,n,r=null)=>{e.assert_type(t,e.TYPE_ANY),e.assert_type(n,e.Output_stream),n.write_string(e.str("#<")),n.write_string(e.class_of(t).get_name().get_string()),null!==r&&r(),n.write_byte(">")},e.Object.prototype.write_object=function(t){e.write_unreadable_object(this,t)},e.Boolean.prototype.write_object=function(t){t.write_string(this===e.t()?e.str("#t"):e.str("#f"))},e.Nil.prototype.write_object=function(t){t.write_string(e.str("()"))},e.Void.prototype.write_object=function(t){t.write_string(e.str("#void"))},e.Ignore.prototype.write_object=function(t){t.write_string(e.str("#ignore"))},e.Number.prototype.write_object=function(e){e.write_string(this.to_string())},e.Symbol.prototype.write_object=function(t){e.PRINT_ESCAPE.get_value()===e.t()?(t.write_string(function get_symbol_prefix(t){switch(t.get_namespace()){case e.VARIABLE_NAMESPACE:return e.str("");case e.FUNCTION_NAMESPACE:return e.str("#'");case e.CLASS_NAMESPACE:return e.str("#^");case e.KEYWORD_NAMESPACE:return e.str(":");default:e.panic("Unknown symbol namespace")}}(this)),!function symbol_needs_escaping(t){const n=t.get_string().get_utf8_bytes();if(e.parses_as_number(n))return!0;for(let t=0;t<n.length;t++){const r=n[t];if(e.is_whitespace(r)||e.is_terminating_character(r)||"\\"===r)return!0}return!1}(this)?t.write_string(this.get_string()):write_delimited(this.get_string(),t,"|")):t.write_string(this.get_string())},e.String.prototype.write_object=function(t){e.PRINT_ESCAPE.get_value()===e.t()?write_delimited(this,t,'"'):t.write_string(this)},e.Cons.prototype.write_object=function(t){function write_cons(t,n){t.cdr()===e.nil()?e.write(t.car(),n):t.cdr()instanceof e.Cons?(e.write(t.car(),n),n.write_byte(" "),write_cons(t.cdr(),n)):(e.write(t.car(),n),n.write_string(e.str(" . ")),e.write(t.cdr(),n))}maybe_abbreviate_object_based_on_current_print_level(t,(()=>{t.write_byte("("),write_cons(this,t),t.write_byte(")")}))},e.Standard_object.prototype.write_object=function(t){const n="lisp_slot_";maybe_abbreviate_object_based_on_current_print_level(t,(()=>{e.write_unreadable_object(this,t,(()=>{for(const r of Object.getOwnPropertyNames(this).sort())r.startsWith(n)&&(t.write_byte(" "),e.write(e.kwd(r.slice(n.length)),t),t.write_byte(" "),e.write(this[r],t))}))}))},e.write_to_string=t=>{const n=new e.String_output_stream;return e.write(t,n),n.get_string()},e.write_to_js_string=t=>e.write_to_string(t).to_js_string(),e.define_variable("*print-escape*",e.PRINT_ESCAPE),e.define_variable("*print-level?*",e.PRINT_LEVEL_OPTION),e.define_alien_function("%write",((t,n)=>e.write(t,n)))}class VM{constructor(){!function init_vm(e){e.Object=class Lisp_object{equal_same_type(e){return this===e}compare_same_type(t){e.abstract_method()}},e.String=class Lisp_string extends e.Object{constructor(t){super(),e.assert_type(t,"string"),this.utf8_bytes=t}equal_same_type(e){return this.get_utf8_bytes()===e.get_utf8_bytes()}to_js_string(){return e.utf8_decode(this.get_utf8_bytes())}get_utf8_bytes(){return this.utf8_bytes}},e.utf8_encode=t=>(e.assert_type(t,"string"),unescape(encodeURIComponent(t))),e.utf8_decode=t=>(e.assert_type(t,"string"),decodeURIComponent(escape(t))),e.Symbol=class Lisp_symbol extends e.Object{constructor(t,n){super(),this.string=e.assert_type(t,e.String),this.namespace=e.assert_type(n,"string")}get_string(){return this.string}get_namespace(){return this.namespace}to_namespace(t){return e.assert_type(t,"string"),e.intern(this.get_string(),t)}to_variable_symbol(){return this.to_namespace(e.VARIABLE_NAMESPACE)}to_function_symbol(){return this.to_namespace(e.FUNCTION_NAMESPACE)}to_class_symbol(){return this.to_namespace(e.CLASS_NAMESPACE)}to_keyword_symbol(){return this.to_namespace(e.KEYWORD_NAMESPACE)}get_key(){return e.Symbol.make_key(this.get_string(),this.get_namespace())}static make_key(e,t){return e.get_utf8_bytes()+"_"+t}},e.VARIABLE_NAMESPACE="variable",e.FUNCTION_NAMESPACE="function",e.CLASS_NAMESPACE="class",e.KEYWORD_NAMESPACE="keyword",e.Number=class Lisp_number extends e.Object{constructor(t){super(),e.assert_type(t,d),this.big=t}equal_same_type(e){return this.get_big().eq(e.get_big())}compare_same_type(e){return this.get_big().cmp(e.get_big())}to_js_number(){return this.get_big().toNumber()}to_string(){return e.str(this.get_big().toFixed())}get_big(){return this.big}},e.add=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().add(n.get_big()))),e.subtract=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().minus(n.get_big()))),e.multiply=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().times(n.get_big()))),e.divide=(t,n)=>(e.assert_type(t,e.Number),e.assert_type(n,e.Number),new e.Number(t.get_big().div(n.get_big()))),e.Boolean=class Lisp_boolean extends e.Object{constructor(t){super(),this.bool=e.assert_type(t,"boolean")}to_js_boolean(){return this.bool}},e.List=class Lisp_list extends e.Object{},e.Cons=class Lisp_cons extends e.List{constructor(e,t){super(),this._car=e,this._cdr=t}equal_same_type(t){return e.equal(this.car(),t.car())&&e.equal(this.cdr(),t.cdr())}car(){return this._car}set_car(e){this._car=e}cdr(){return this._cdr}set_cdr(e){this._cdr=e}},e.Nil=class Lisp_nil extends e.List{constructor(){super()}},e.Void=class Lisp_void extends e.Object{constructor(){super()}},e.Ignore=class Lisp_ignore extends e.Object{constructor(){super()}},e.Environment=class Lisp_environment extends e.Object{constructor(t=null){super(),null!==t&&e.assert_type(t,e.Environment),this.parent=t,this.bindings=Object.create(null===t?null:t.get_bindings())}put(t,n){e.assert_type(t,e.Symbol),this.bindings[t.get_key()]=n}lookup(t){e.assert_type(t,e.Symbol);const n=t.get_key(),r=this.bindings[n];if(void 0!==r)return r;if(!(n in this.bindings))throw new e.Unbound_symbol_error(t,this)}is_bound(t){e.assert_type(t,e.Symbol);return t.get_key()in this.bindings}get_bindings(){return this.bindings}},e.Class=class Lisp_class extends e.Object{constructor(t,n,r){super(),this.name=e.assert_type(t,e.Symbol),this.js_class=e.assert_type(n,"function"),this.superclass=e.assert_type(r,e.type_or(e.TYPE_NULL,e.Class))}add_method(t,n){e.assert_type(n,e.Operator);const r=this.method_key(t);this.get_js_class().prototype[r]=n}find_method(t){const n=this.method_key(t),r=this.get_js_class().prototype[n];if(void 0!==r)return r;throw new e.Unbound_method_error(this,t)}method_key(t){e.assert_type(t,e.Symbol);return"lisp_method_"+t.get_string().get_utf8_bytes()}get_name(){return this.name}get_js_class(){return this.js_class}get_superclass(){return this.superclass}},e.Built_in_class=class Lisp_built_in_class extends e.Class{constructor(e,t,n){super(e,t,n)}},e.Standard_class=class Lisp_standard_class extends e.Class{constructor(e,t,n){super(e,t,n)}},e.Standard_object=class Lisp_standard_object extends e.Object{slot_value(t){const n=this.slot_key(t);if(this.hasOwnProperty(n))return this[n];throw new e.Unbound_slot_error(this,t)}set_slot_value(e,t){return this[this.slot_key(e)]=t}is_slot_bound(e){return this.slot_key(e)in this}slot_key(t){e.assert_type(t,e.Symbol);return"lisp_slot_"+t.get_string().get_utf8_bytes()}},e.make_instance=(t,...n)=>{e.assert_type(t,e.Standard_class),e.assert(n.length%2==0);const r=new(t.get_js_class());for(let e=0;e<n.length;e+=2){const t=n[e],s=n[e+1];r.set_slot_value(t,s)}return r},e.is_subclass=(t,n)=>{if(e.assert_type(t,e.Class),e.assert_type(n,e.Class),t===n)return!0;{const e=t.get_js_class(),r=n.get_js_class();return e.prototype instanceof r}},e.make_standard_class=(t,n)=>{e.assert_type(t,e.Symbol),e.assert_type(n,e.Standard_class);const r=n.get_js_class(),s=class extends r{constructor(){super()}},i=t.get_string().to_js_string();Object.defineProperty(s,"name",{value:i});return e.bless_class(t,s,r,e.Standard_class)},e.reinitialize_standard_class=(t,n)=>{e.assert_type(t,e.Standard_class),e.assert_type(n,e.Standard_class);const r=t.get_js_class(),s=n.get_js_class();return Object.setPrototypeOf(r.prototype,s.prototype),t},e.Condition=class Lisp_condition extends e.Standard_object{},e.Error=class Lisp_error extends e.Condition{constructor(e){super();const t=new Error(e);Object.getOwnPropertyNames(t).forEach((e=>{const n=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(this,e,n)}))}},e.Type_error=class Lisp_type_error extends e.Error{constructor(t,n){super("Type assertion failed: expected "+e.write_to_js_string(n)+" got "+e.write_to_js_string(t)),this.lisp_slot_datum=t,this["lisp_slot_expected-type"]=n}},e.make_type_error=(t,n)=>new e.Type_error(t,e.to_lisp_type_spec(n)),e.Unbound_symbol_error=class Lisp_unbound_symbol_error extends e.Error{constructor(t,n){e.assert_type(t,e.Symbol),e.assert_type(n,e.Environment);const r=t.get_string().to_js_string();super(`Unbound ${t.get_namespace()}: ${r}`),this.lisp_slot_symbol=t,this.lisp_slot_environment=n}},e.Unbound_slot_error=class Lisp_unbound_slot_error extends e.Error{constructor(t,n){e.assert_type(t,e.Standard_object),e.assert_type(n,e.Symbol);super(`Unbound slot: ${n.get_string().to_js_string()}`),this.lisp_slot_object=t,this["lisp_slot_slot-name"]=n}},e.Unbound_method_error=class Lisp_unbound_method_error extends e.Error{constructor(t,n){e.assert_type(t,e.Class),e.assert_type(n,e.Symbol);super(`Unbound method: ${n.get_string().to_js_string()}`),this.lisp_slot_class=t,this["lisp_slot_method-name"]=n}},e.Assertion_error=class Lisp_assertion_error extends e.Error{constructor(e){super(e||"Assertion failed")}},e.assert=(t,n="Assertion failed")=>{if(!t)throw new e.Assertion_error(n)},e.abstract_method=()=>{throw new e.Error("You called an abstract method. Congratulations!")},e.has_type=(t,n)=>{if("string"==typeof n)return typeof t===n;if("function"==typeof n)return t instanceof n;if(n&&n.custom_check)return n.custom_check(t);throw new e.Error("Unknown type spec")},e.TYPE_ANY={custom_check:e=>!0,to_lisp_type_spec:()=>e.sym("object")},e.TYPE_NULL={custom_check:e=>null===e,to_lisp_type_spec:()=>e.str("null")},e.type_or=(...t)=>({custom_check(n){for(let r=0;r<t.length;r++)if(e.has_type(n,t[r]))return!0;return!1},to_lisp_type_spec:()=>e.cons(e.sym("or"),e.array_to_list(t.map(e.to_lisp_type_spec)))}),e.assert_type=(t,n)=>{if(e.has_type(t,n))return t;throw e.make_type_error(t,n)},e.to_lisp_type_spec=t=>{if("string"==typeof t)return e.str(t);if("function"==typeof t)return e.has_lisp_class(t)?e.lisp_class(t).get_name():t;if(t&&t.to_lisp_type_spec)return t.to_lisp_type_spec();throw new e.Error("Unknown type spec")},e.elt=(t,n)=>(e.assert_type(t,e.Cons),e.assert_type(n,"number"),0===n?t.car():e.elt(t.cdr(),n-1)),e.list_to_array=t=>{e.assert_type(t,e.List);const n=[];for(;t!==e.nil();)n.push(t.car()),t=t.cdr();return n},e.array_to_list=t=>{e.assert(Array.isArray(t),"Not an array");let n=e.nil();for(let r=t.length;r>0;r--)n=e.cons(t[r-1],n);return n},e.reverse=t=>{e.assert_type(t,e.List);let n=e.nil();for(;t!==e.nil();)n=e.cons(t.car(),n),t=t.cdr();return n},e.environment=e.make_environment(),e.symbols=Object.create(null);const t=new e.Boolean(!0),n=new e.Boolean(!1),r=new e.Nil,s=new e.Void,i=new e.Ignore,o=e.num(0),a=e.num(1);e.t=()=>t,e.f=()=>n,e.nil=()=>r,e.void=()=>s,e.ignore=()=>i,e.zero=()=>o,e.one=()=>a,e.define_class=(t,n,r=e.Object,s=e.Built_in_class)=>{const i=e.sym(t),o=e.bless_class(i,n,r,s);e.get_environment().put(i.to_class_symbol(),o)},e.bless_class=(t,n,r=e.Object,s=e.Built_in_class)=>{e.assert_type(t,e.Symbol),e.assert_type(n,"function"),e.assert_type(r,e.type_or(e.TYPE_NULL,"function")),e.assert_type(s,"function");const i=new s(t,n,r?e.lisp_class(r):null);return n.prototype.lisp_class=i,i},e.define_condition=(t,n,r)=>{e.define_class(t,n,r,e.Standard_class)},e.define_class("object",e.Object,null),e.define_class("string",e.String),e.define_class("symbol",e.Symbol),e.define_class("number",e.Number),e.define_class("boolean",e.Boolean),e.define_class("list",e.List),e.define_class("cons",e.Cons,e.List),e.define_class("nil",e.Nil,e.List),e.define_class("void",e.Void),e.define_class("ignore",e.Ignore),e.define_class("environment",e.Environment),e.define_class("class",e.Class),e.define_class("built-in-class",e.Built_in_class,e.Class),e.define_class("standard-class",e.Standard_class,e.Class),e.define_class("standard-object",e.Standard_object,e.Object,e.Standard_class),e.define_condition("condition",e.Condition,e.Standard_object),e.define_condition("error",e.Error,e.Condition),e.define_condition("type-error",e.Type_error,e.Error),e.define_condition("unbound-symbol-error",e.Unbound_symbol_error,e.Error),e.define_condition("unbound-slot-error",e.Unbound_slot_error,e.Error),e.define_condition("unbound-method-error",e.Unbound_method_error,e.Error),e.define_condition("assertion-error",e.Assertion_error,e.Error)}(this),init_eval(this),init_control(this),function init_seq(e){function canonicalize_end(t){return t===e.void()?void 0:e.assert_type(t,e.Number).to_js_number()}e.list_star=(...t)=>{const n=t.length;let r=n>=1?t[n-1]:e.nil();for(let s=n-1;s>0;s--)r=e.cons(t[s-1],r);return r},e.append=(t,n)=>(e.assert_type(t,e.List),t===e.nil()?n:e.cons(t.car(),e.append(t.cdr(),n))),e.list_length=t=>(e.assert_type(t,e.List),t===e.nil()?0:1+e.list_length(t.cdr())),e.nthcdr=(t,n)=>{if(e.assert_type(n,e.List),0===t)return n;if(n===e.nil())throw new e.Out_of_bounds_error;return e.nthcdr(t-1,n.cdr())},e.mapcar=(t,n)=>n===e.nil()?e.nil():e.cons(t(n.car()),e.mapcar(t,n.cdr())),e.mapc=(t,n)=>(n!==e.nil()&&(t(n.car()),e.mapc(t,n.cdr())),n),e.list_subseq=(t,n,r)=>{e.assert_type(t,e.List),e.assert_type(n,"number");const s=e.nthcdr(n,t);return void 0===r?s:function take_n(t,n){if(0===n)return e.nil();if(t===e.nil())throw new e.Out_of_bounds_error;return e.cons(t.car(),take_n(t.cdr(),n-1))}(s,r-n)},e.string_subseq=(t,n,r)=>{e.assert_type(t,e.String);const s=t.get_utf8_bytes();return new e.String(e.slice_subseq(s,n,r))},e.slice_subseq=(t,n,r)=>{if(e.assert_type(n,"number"),n>t.length)throw new e.Out_of_bounds_error;if(void 0===r)return t.slice(n);if(r>t.length)throw new e.Out_of_bounds_error;return t.slice(n,r)},e.some=t=>e.list(t),e.optional=(t,n=(()=>e.void()))=>t===e.nil()?n():e.elt(t,0),e.Out_of_bounds_error=class Lisp_out_of_bounds_error extends e.Error{constructor(){super("Out of bounds")}},e.define_alien_function("%list*",((...t)=>e.list_star(...t))),e.define_alien_function("%append",((t,n)=>e.append(t,n))),e.define_alien_function("%list-length",(t=>e.num(e.list_length(t)))),e.define_alien_function("%nth",((t,n)=>e.elt(n,e.assert_type(t,e.Number).to_js_number()))),e.define_alien_function("%nthcdr",((t,n)=>e.nthcdr(e.assert_type(t,e.Number).to_js_number(),n))),e.define_alien_function("%list-subseq",((t,n,r)=>e.list_subseq(t,e.assert_type(n,e.Number).to_js_number(),canonicalize_end(r)))),e.define_alien_function("%string-subseq",((t,n,r)=>e.string_subseq(t,e.assert_type(n,e.Number).to_js_number(),canonicalize_end(r)))),e.define_alien_function("%reverse",(t=>e.reverse(t))),e.define_condition("out-of-bounds-error",e.Out_of_bounds_error,e.Error)}(this),function init_stream(e){e.Input_stream=class Lisp_input_stream extends e.Object{read_byte(t,n){e.abstract_method()}unread_byte(t){e.abstract_method()}peek_byte(t=!1,n=!0,r=e.void()){const s=t?e.skip_whitespace(this,!1):this.read_byte(!1);return s===e.void()?e.eof(n,r):(this.unread_byte(s),s)}},e.String_input_stream=class Lisp_string_input_stream extends e.Input_stream{constructor(t){super(),e.assert_type(t,e.String),this.bytes=t.get_utf8_bytes(),this.pos=-1}read_byte(t=!0,n=e.void()){return e.assert_type(t,"boolean"),e.assert_type(n,e.TYPE_ANY),this.pos+1<this.bytes.length?(this.pos++,this.byte_at_pos(this.pos)):e.eof(t,n)}unread_byte(t){if(e.assert_type(t,"string"),!(this.pos>=0&&this.byte_at_pos(this.pos)===t))throw new e.Stream_error("Cannot unread byte");this.pos--}byte_at_pos(e){return this.bytes[e]}},e.Output_stream=class Lisp_output_stream extends e.Object{write_byte(t){e.abstract_method()}write_string(t){e.assert_type(t,e.String);const n=t.get_utf8_bytes();for(let e=0;e<n.length;e++)this.write_byte(n[e]);return t}force_output(){return e.void()}fresh_line(){return this.write_byte("\n"),e.t()}},e.String_output_stream=class Lisp_string_output_stream extends e.Output_stream{constructor(){super(),this.bytes=""}write_byte(t){return e.assert_type(t,"string"),e.assert(1===t.length),this.bytes+=t,t}get_string(){return new e.String(this.bytes)}},e.eof=(t,n)=>{if(t)throw new e.End_of_file;return n},e.Stream_error=class Lisp_stream_error extends e.Error{constructor(e){super(e)}},e.End_of_file=class Lisp_end_of_file extends e.Stream_error{constructor(){super("EOF")}},e.STANDARD_INPUT=e.make_dynamic(e.void()),e.STANDARD_OUTPUT=e.make_dynamic(e.void()),e.define_class("input-stream",e.Input_stream),e.define_class("string-input-stream",e.String_input_stream,e.Input_stream),e.define_class("output-stream",e.Output_stream),e.define_class("string-output-stream",e.String_output_stream,e.Output_stream),e.define_condition("stream-error",e.Stream_error,e.Error),e.define_condition("end-of-file",e.End_of_file,e.Stream_error),e.define_variable("*standard-input*",e.STANDARD_INPUT),e.define_variable("*standard-output*",e.STANDARD_OUTPUT),e.define_alien_function("%make-string-input-stream",(t=>new e.String_input_stream(t))),e.define_alien_function("%make-string-output-stream",(()=>new e.String_output_stream)),e.define_alien_function("%get-output-stream-string",(t=>e.assert_type(t,e.String_output_stream).get_string())),e.define_alien_function("%fresh-line",(t=>e.assert_type(t,e.Output_stream).fresh_line())),e.define_alien_function("%force-output",(t=>e.assert_type(t,e.Output_stream).force_output()))}(this),init_read(this),init_print(this),function init_js(e){e.js_global=t=>(e.assert_type(t,e.String),globalThis[t.to_js_string()]),e.js_new=function(t){e.assert_type(t,"function");return new(t.bind.apply(t,arguments))},e.js_get=(t,n)=>(e.assert_type(n,e.String),t[n.to_js_string()]),e.js_elt=(t,n)=>(e.assert(Array.isArray(t)),e.assert_type(n,e.Number),t[n.to_js_number()]),e.apply_js_method=(t,n,r)=>(e.assert_type(n,e.String),e.assert_type(r,e.List),e.assert_type(t[n.to_js_string()],"function").apply(t,e.list_to_array(r))),e.to_lisp_boolean=t=>e.assert_type(t,"boolean")?e.t():e.f(),e.to_lisp_function=t=>e.alien_function(t,"anonymous JS function"),e.to_js_function=t=>(e.assert_type(t,e.Operator),function(){var n=e.array_to_list(Array.prototype.slice.call(arguments));return e.operate(t,n,e.make_environment())}),e.JS_console_output_stream=class Lisp_js_console_output_stream extends e.Output_stream{constructor(e=console.log){super(),this.buffer="",this.output_function=e}write_byte(t){return e.assert_type(t,"string"),e.assert(1===t.length),this.buffer+=t,t}fresh_line(){return 0===this.buffer.length||"\n"===this.buffer[this.buffer.length-1]?e.f():(this.write_byte("\n"),e.t())}force_output(){return this.buffer.length>0&&(this.output_function(e.utf8_decode(this.buffer)),this.buffer=""),e.void()}},e.define_constant("+js-true+",!0),e.define_constant("+js-false+",!1),e.define_constant("+js-null+",null),e.define_constant("+js-undefined+",void 0),e.define_alien_function("%js-global",e.js_global),e.define_alien_function("%js-new",e.js_new),e.define_alien_function("%js-get",e.js_get),e.define_alien_function("%js-elt",e.js_elt),e.define_alien_function("%to-lisp-boolean",e.to_lisp_boolean),e.define_alien_function("%to-js-boolean",(t=>e.assert_type(t,e.Boolean).to_js_boolean())),e.define_alien_function("%to-lisp-number",(t=>e.num(e.assert_type(t,"number")))),e.define_alien_function("%to-js-number",(t=>e.assert_type(t,e.Number).to_js_number())),e.define_alien_function("%to-lisp-string",(t=>e.str(e.assert_type(t,"string")))),e.define_alien_function("%to-js-string",(t=>e.assert_type(t,e.String).to_js_string())),e.define_alien_function("%to-lisp-function",e.to_lisp_function),e.define_alien_function("%to-js-function",e.to_js_function),e.define_alien_function("%list-to-js-array",e.list_to_array),e.define_alien_function("%js-array-to-list",e.array_to_list),e.define_alien_function("%apply-js-method",e.apply_js_method),e.define_alien_function("%js-log",((...e)=>console.log(...e))),e.define_alien_function("%sleep",(t=>(e.assert_type(t,e.Number),new Promise((e=>setTimeout(e,t.to_js_number())))))),e.define_class("js-console-output-stream",e.JS_console_output_stream,e.Output_stream),e.STANDARD_OUTPUT.set_value(new e.JS_console_output_stream)}(this),this.eval_js_string("(%def #'list (%wrap (%vau arguments #ignore arguments))) (%def #'vau (%vau (parameter-tree environment-parameter . forms) env (%eval (list #'%vau parameter-tree environment-parameter (%list* #'%progn forms)) env))) (%def #'lispx::make-macro (%wrap (%vau (expander) #ignore (%vau operand env (%eval (%eval (%cons expander operand) (%make-environment)) env))))) (%def #'macro (lispx::make-macro (%vau (parameter-tree . forms) #ignore (list #'lispx::make-macro (%list* #'vau parameter-tree #ignore forms))))) (%def #'defmacro (macro (name parameter-tree . forms) (list #'%def (%function-symbol name) (%list* #'macro parameter-tree forms)))) (defmacro defexpr (name parameter-tree environment-parameter . forms) (list #'%def (%function-symbol name) (%list* #'vau parameter-tree environment-parameter forms))) (defmacro def (definiend-tree value . docstring?) (list #'%def definiend-tree value)) (defmacro defconstant (name value . docstring?) (list #'def name value)) (defmacro lambda (parameter-tree . forms) (list #'%wrap (%list* #'vau parameter-tree #ignore forms))) (defmacro defun (name parameter-tree . forms) (list #'def (%function-symbol name) (%list* #'lambda parameter-tree forms))) (defmacro progn forms (list* #'%progn forms)) (defmacro if (test consequent alternative) (list #'%if test consequent alternative)) (defmacro catch (tag . forms) (list #'%catch tag (list* #'lambda () forms))) (defun throw (tag . result?) (%throw tag (optional result?))) (defmacro loop forms (list #'%loop (list* #'progn forms))) (defun eq (a b) (%eq a b)) (defun class-of (object) (%class-of object)) (defun typep (object class) (%typep object class)) (defun intern (string) (%intern string)) (defun symbol-name (symbol) (%symbol-name symbol)) (defun variable-symbol (symbol) (%variable-symbol symbol)) (defun function-symbol (symbol) (%function-symbol symbol)) (defun class-symbol (symbol) (%class-symbol symbol)) (defun keyword-symbol (symbol) (%keyword-symbol symbol)) (defun cons (car cdr) (%cons car cdr)) (defun car (cons) (%car cons)) (defun cdr (cons) (%cdr cons)) (defun list* arguments (apply #'%list* arguments)) (defun reverse (list) (%reverse list)) (defun wrap (operator) (%wrap operator)) (defun unwrap (function) (%unwrap function)) (defun eval (form environment) (%eval form environment)) (defun make-environment parent-environment? (apply #'%make-environment parent-environment?)) (defun boundp (symbol environment) (%boundp symbol environment)) (defun panic (error) (%panic error)) (defun invoke-debugger (condition) (take-subcont +root-prompt+ k (push-delim-subcont +root-prompt+ k (%print-stacktrace k) (panic condition)))) (defmacro let (bindings . forms) (list* (list* #'lambda (mapcar #'car bindings) forms) (mapcar #'cadr bindings))) (defmacro let* (bindings . forms) (if (null bindings) (list* #'let () forms) (list #'let (list (car bindings)) (list* #'let* (cdr bindings) forms)))) (defmacro lispx::letrec (bindings . forms) (if (null bindings) (list* #'let () forms) (list* #'let () (list #'def (mapcar #'car bindings) (list* #'list (mapcar #'cadr bindings))) forms))) (defun lispx::make-function-binding ((name parameter-tree . forms)) (list (function-symbol name) (list* #'lambda parameter-tree forms))) (defmacro flet (function-bindings . forms) (list* #'let (mapcar #'lispx::make-function-binding function-bindings) forms)) (defmacro labels (function-bindings . forms) (list* #'lispx::letrec (mapcar #'lispx::make-function-binding function-bindings) forms)) (defexpr quote (operand) #ignore operand) (defexpr the-environment () environment environment) (defun apply (function arguments) (eval (cons (unwrap function) arguments) (%make-environment))) (defmacro when (test . forms) (list #'if test (list* #'progn forms) #void)) (defmacro unless (test . forms) (list #'if test #void (list* #'progn forms))) (defexpr cond clauses env (unless (null clauses) (let ((((test . forms) . rest-clauses) clauses)) (if (eval test env) (eval (cons #'progn forms) env) (eval (cons #'cond rest-clauses) env))))) (defun not (boolean) (if boolean #f #t)) (defexpr and operands env (cond ((null operands) #t) ((null (cdr operands)) (the boolean (eval (car operands) env))) ((eval (car operands) env) (eval (cons #'and (cdr operands)) env)) (#t #f))) (defexpr or operands env (cond ((null operands) #f) ((null (cdr operands)) (the boolean (eval (car operands) env))) ((eval (car operands) env) #t) (#t (eval (cons #'or (cdr operands)) env)))) (defexpr while (test-form . forms) env (let ((forms (list* #'progn forms))) (block exit (loop (if (eval test-form env) (eval forms env) (return-from exit)))))) (defmacro until (test-form . forms) (list* #'while (list #'not test-form) forms)) (defmacro dotimes ((var count-form . result-form?) . body-forms) (flet ((_dotimes_ (n #'body #'result) (let ((#'i (box 0))) (while (< (i) n) (body (i)) (i (+ (i) 1))) (result (i))))) (list #'_dotimes_ count-form (list* #'lambda (list var) body-forms) (list* #'lambda (list var) result-form?)))) (defmacro loop-let (name initializers . forms) (list #'labels (list (list* name (mapcar #'car initializers) forms)) (list* name (mapcar #'cadr initializers)))) (defexpr block (block-name . forms) env (let ((tag (list #void))) (flet ((escape (value) (throw tag value))) (catch tag (eval (list (list* #'lambda (list block-name) forms) #'escape) env))))) (defun return-from (#'block-name . value?) (block-name (optional value?))) (defmacro unwind-protect (protected-form . cleanup-forms) (list #'%unwind-protect protected-form (list* #'progn cleanup-forms))) (defexpr prog1 (form . forms) env (let ((result (eval form env))) (eval (list* #'progn forms) env) result)) (defun lispx::make-typecase-with-default-function (#'default) (vau (keyform . clauses) env (let ((key (eval keyform env))) (loop-let -typecase- ((clauses clauses)) (if (null clauses) (default key) (let ((((class-name . forms) . rest-clauses) clauses)) (if (typep key (find-class class-name env)) (eval (list* #'progn forms) env) (-typecase- rest-clauses)))))))) (def #'typecase (lispx::make-typecase-with-default-function (lambda (#ignore) #void))) (def #'etypecase (lispx::make-typecase-with-default-function (lambda (key) (error (make-type-error key #^object))))) (defexpr set (environment definiend-tree value) dynamic-environment (eval (list #'def definiend-tree (list (unwrap #'eval) value dynamic-environment)) (eval environment dynamic-environment))) (defun box initial-value? (def value (optional initial-value?)) (def env (the-environment)) (lambda new-value? (if-option (new-value new-value?) (set env value new-value) value))) (defun assert (boolean) (unless boolean (error (make-instance #^assertion-error)))) (defun compose (#'f #'g) (lambda args (g (apply #'f args)))) (defun identity (x) x) (defun null (object) (eq object ())) (defun consp (object) (typep object #^cons)) (defun caar (cons) (car (car cons))) (defun cadr (cons) (car (cdr cons))) (defun cdar (cons) (cdr (car cons))) (defun cddr (cons) (cdr (cdr cons))) (defun append (list1 list2) (%append list1 list2)) (defun nth (n list) (%nth n list)) (defun nthcdr (n list) (%nthcdr n list)) (defun mapcar (#'function list) (if (null list) () (cons (function (car list)) (mapcar #'function (cdr list))))) (defun mapc (#'function list) (unless (null list) (function (car list)) (mapc #'function (cdr list))) list) (defun mapcan (#'function list) (if (null list) () (append (function (car list)) (mapcan #'function (cdr list))))) (defmacro dolist ((var list-form . result-form?) . body-forms) (labels ((_dolist_ (list #'body #'result) (if (null list) (result list) (progn (body (car list)) (_dolist_ (cdr list) #'body #'result))))) (list #'_dolist_ list-form (list* #'lambda (list var) body-forms) (list* #'lambda (list var) result-form?)))) (defun reduce (#'function list :initial-value initial-value) (if (null list) initial-value (reduce #'function (cdr list) :initial-value (function initial-value (car list))))) (defun member (item list . keywords) (let ((#'test (optional (get? keywords :test) #'eq)) (#'key (optional (get? keywords :key) #'identity))) (loop-let -member- ((items list)) (if (null items) () (if (test item (key (car items))) items (-member- (cdr items))))))) (defun remove-if (#'test list) (if (null list) () (if (test (car list)) (remove-if #'test (cdr list)) (cons (car list) (remove-if #'test (cdr list)))))) (defun get? (plist indicator) (if (null plist) () (let (((i v . plist) plist)) (if (eq i indicator) (some v) (get? plist indicator))))) (defun lispx::make-relational-operator (#'binary-operator) (labels ((operator (arg1 arg2 . rest) (if (binary-operator arg1 arg2) (if (null rest) #t (apply #'operator (list* arg2 rest))) #f))) #'operator)) (def #'= (lispx::make-relational-operator #'%=)) (def #'< (lispx::make-relational-operator #'%<)) (def #'> (lispx::make-relational-operator #'%>)) (def #'<= (lispx::make-relational-operator #'%<=)) (def #'>= (lispx::make-relational-operator #'%>=)) (defun /= (arg . args) (if (null args) #t (if (consp (member arg args :test #'=)) #f (apply #'/= args)))) (defun lispx::make-thetic-operator (#'binary-operator initial-value) (lambda args (reduce #'binary-operator args :initial-value initial-value))) (def #'+ (lispx::make-thetic-operator #'%+ 0)) (def #'* (lispx::make-thetic-operator #'%* 1)) (defun lispx::make-lytic-operator (#'binary-operator initial-value) (lambda (arg1 . rest) (if (null rest) (binary-operator initial-value arg1) (reduce #'binary-operator rest :initial-value arg1)))) (def #'- (lispx::make-lytic-operator #'%- 0)) (def #'/ (lispx::make-lytic-operator #'%/ 1)) (defun find-class (name environment) (eval (class-symbol name) environment)) (defun class-name (class) (%class-name class)) (defun subclassp (class superclass) (%subclassp class superclass)) (defexpr defclass (name superclass? slot-specs . properties) env (dolist (slot-spec slot-specs) (the symbol slot-spec)) (let ((class-name (class-symbol name)) (superclass (find-class (optional superclass? (quote standard-object)) env))) (if (boundp class-name env) (%reinitialize-standard-class (eval class-name env) superclass) (eval (list #'def class-name (%make-standard-class name superclass)) env)))) (defexpr defgeneric (name (receiver . parameters) . properties) env (flet ((generic args (apply (%find-method (class-of (car args)) name) args))) (eval (list #'def (function-symbol name) #'generic) env))) (defexpr defmethod (name ((receiver class-name) . parameters) . forms) env (let ((#'method (eval (list* #'lambda (list* receiver parameters) forms) env))) (%add-method (find-class class-name env) name #'method))) (defun make-instance (class . slot-inits) (apply #'%make-instance (cons class slot-inits))) (defun slot-value (object slot-name) (%slot-value object slot-name)) (defun set-slot-value (object slot-name value) (%set-slot-value object slot-name value)) (defun slot-bound-p (object slot-name) (%slot-bound-p object slot-name)) (defun make-type-error (datum expected-type) (make-instance #^type-error :datum datum :expected-type expected-type)) (defun assert-type (object class) (if (typep object class) object (error (make-type-error object (class-name class))))) (defexpr the (class-name object) env (assert-type (eval object env) (find-class class-name env))) (defgeneric length (sequence)) (defmethod length ((seq list)) (%list-length seq)) (defgeneric elt (sequence index)) (defmethod elt ((seq list) index) (nth index seq)) (defgeneric subseq (sequence start . end?)) (defmethod subseq ((seq list) start . end?) (%list-subseq seq start (optional end?))) (defmethod subseq ((seq string) start . end?) (%string-subseq seq start (optional end?))) (defun some (value) (list value)) (defexpr if-option ((name option?) then else) env (let ((o? (eval option? env))) (if (null o?) (eval else env) (eval (list (list #'vau (list name) #ignore then) (car o?)) env)))) (defmacro when-option ((name option?) . forms) (list #'if-option (list name option?) (list* #'progn forms) ())) (defmacro unless-option (option? . forms) (list #'if-option (list #ignore option?) () (list* #'progn forms))) (defexpr optional (option? . default?) env (if-option (value (eval option? env)) value (if-option (default default?) (eval default env) #void))) (defexpr optionals (list . defaults) env (loop-let -optionals- ((list (eval list env)) (defaults defaults)) (if (null list) (if (null defaults) () (cons (eval (car defaults) env) (-optionals- () (cdr defaults)))) (if (null defaults) (cons (car list) (-optionals- (cdr list) ())) (cons (car list) (-optionals- (cdr list) (cdr defaults))))))) (defun get-option (option?) (optional option? (simple-error \"Option is nil\"))) (defexpr defdynamic (name . value-and-docstring?) env (def value (eval (optional value-and-docstring?) env)) (if (boundp name env) (set-dynamic (eval name env) value) (eval (list #'def name (make-instance #^dynamic :value value)) env))) (defun dynamic (dynamic-variable) (slot-value dynamic-variable (quote value))) (defun set-dynamic (dynamic-variable value) (set-slot-value dynamic-variable (quote value) value)) (defexpr dynamic-let (bindings . forms) env (let ((dynamics (mapcar (lambda ((name #ignore)) (eval name env)) bindings)) (values (mapcar (lambda ((#ignore value)) (eval value env)) bindings)) (thunk (eval (list* #'lambda () forms) env))) (%progv dynamics values thunk))) (defmacro dynamic-let* (bindings . forms) (if (null bindings) (list* #'progn forms) (list #'dynamic-let (list (car bindings)) (list* #'dynamic-let* (cdr bindings) forms)))) (defmacro progv (dynamic-variables values . forms) (list #'%progv dynamic-variables values (list* #'lambda () forms))) (defmacro push-prompt (prompt . forms) (list #'%push-prompt prompt (list* #'lambda () forms))) (defmacro take-subcont (prompt name . forms) (list #'%take-subcont prompt (list* #'lambda (list name) forms))) (defmacro push-delim-subcont (prompt continuation . forms) (list #'%push-delim-subcont prompt continuation (list* #'lambda () forms))) (defmacro push-subcont-barrier forms (list #'%push-subcont-barrier (list* #'lambda () forms))) (defconstant +default-prompt+ (quote default-prompt) \"This prompt is used for general coroutine-like use of\ncontinuations.\") (defmacro coroutine forms (list* #'push-prompt (quote +default-prompt+) forms)) (defmacro yield (name . forms) (list* #'take-subcont (quote +default-prompt+) name forms)) (defmacro resume (k . forms) (list* #'push-delim-subcont (quote +default-prompt+) k forms))"),this.eval_js_string("(defclass handler-frame () (handlers parent-frame?)) (defclass condition-handler () (condition-class handler-function)) (defclass restart-handler () (restart-name handler-function interactive-function? associated-conditions)) (defdynamic *condition-handler-frame?* ()) (defdynamic *restart-handler-frame?* ()) (defun lispx::make-handler-bind-operator (#'handler-spec-parser handler-frame-dynamic) (vau (handler-specs . forms) env (let ((handler-frame (make-instance #^handler-frame :handlers (mapcar (lambda (spec) (handler-spec-parser spec env)) handler-specs) :parent-frame? (dynamic handler-frame-dynamic)))) (progv (list handler-frame-dynamic) (list (some handler-frame)) (eval (list* #'progn forms) env))))) (def #'handler-bind (lispx::make-handler-bind-operator (lambda ((class-name function-form) env) (make-instance #^condition-handler :condition-class (the class (find-class class-name env)) :handler-function (the function (eval function-form env)))) *condition-handler-frame?*)) (def #'restart-bind (lispx::make-handler-bind-operator (lambda ((restart-name function-form . properties) env) (make-instance #^restart-handler :restart-name (the symbol restart-name) :handler-function (the function (eval function-form env)) :interactive-function? (when-option (i-f-form (get? properties :interactive-function)) (some (the function (eval i-f-form env)))) :associated-conditions (when-option (a-cs-form (get? properties :associated-conditions)) (the list (eval a-cs-form env))))) *restart-handler-frame?*)) (defun lispx::make-handler-case-operator (#'handler-bind-operator) (vau (handler-specs . forms) env (block exit ((block trampoline (eval (list #'handler-bind-operator (mapcar (lambda ((name function-form . properties)) (list* name (lambda args (return-from trampoline (lambda () (apply (eval function-form env) args)))) properties)) handler-specs) (list #'return-from exit (list* #'progn forms))) env)))))) (def #'handler-case (lispx::make-handler-case-operator #'handler-bind)) (def #'restart-case (lispx::make-handler-case-operator #'restart-bind)) (defun _signal_ (condition) (loop-let -signal- ((handler-frame? (dynamic *condition-handler-frame?*))) (if-option ((handler frame) (lispx::find-handler? condition handler-frame? ())) (progn (lispx::call-condition-handler handler frame condition) (-signal- (slot-value frame (quote parent-frame?)))) #void))) (defun lispx::call-condition-handler (handler handler-frame condition) (dynamic-let ((*condition-handler-frame?* (slot-value handler-frame (quote parent-frame?)))) (lispx::apply-handler-function handler (list condition)))) (defun lispx::apply-handler-function (handler arguments) (apply (slot-value handler (quote handler-function)) arguments)) (defun _error_ (condition) (signal condition) (invoke-debugger condition)) (defun lispx::make-signal-with-restarts-operator (#'signal-operator) (vau (condition . handler-specs) env (let ((c (eval condition env))) (flet ((append-associated-condition (handler-spec) (append handler-spec (list :associated-conditions (list #'list c))))) (eval (list #'restart-case (mapcar #'append-associated-condition handler-specs) (list #'signal-operator c)) env))))) (def #'signal (lispx::make-signal-with-restarts-operator #'_signal_)) (def #'error (lispx::make-signal-with-restarts-operator #'_error_)) (defun invoke-restart (restart-designator . arguments) (lispx::invoke-restart-with-arguments-producing-function restart-designator (lambda (#ignore) arguments))) (defun invoke-restart-interactively (restart-designator) (lispx::invoke-restart-with-arguments-producing-function restart-designator (lambda (restart-handler) (when-option (#'i-f (slot-value restart-handler (quote interactive-function?))) (i-f))))) (defun lispx::invoke-restart-with-arguments-producing-function (restart-designator #'function) (etypecase restart-designator (symbol (if-option (restart-handler (find-restart? restart-designator)) (lispx::apply-handler-function restart-handler (function restart-handler)) (error (make-restart-error restart-designator)))) (restart-handler (lispx::apply-handler-function restart-designator (function restart-designator))))) (defun lispx::find-handler? (object handler-frame? payload?) (when-option (handler-frame handler-frame?) (block found (dolist (handler (slot-value handler-frame (quote handlers))) (when (lispx::handler-applicable-p handler object payload?) (return-from found (some (list handler handler-frame))))) (lispx::find-handler? object (slot-value handler-frame (quote parent-frame?)) payload?)))) (defun find-restart? (name . condition?) (when-option ((handler #ignore) (lispx::find-handler? name (dynamic *restart-handler-frame?*) condition?)) (some handler))) (defgeneric lispx::handler-applicable-p (handler object payload?)) (defmethod lispx::handler-applicable-p ((handler condition-handler) condition ()) (typep condition (slot-value handler (quote condition-class)))) (defmethod lispx::handler-applicable-p ((handler restart-handler) restart-name condition?) (and (eq restart-name (slot-value handler (quote restart-name))) (lispx::restart-handler-applicable-to-condition-p handler condition?))) (defun lispx::restart-handler-applicable-to-condition-p (handler condition?) (if-option (condition condition?) (let ((a-cs (slot-value handler (quote associated-conditions)))) (if (null a-cs) #t (consp (member condition a-cs)))) #t)) (defun compute-restarts condition? (loop-let -compute-restarts- ((restarts (quote ())) (handler-frame? (dynamic *restart-handler-frame?*))) (if-option (handler-frame handler-frame?) (-compute-restarts- (append restarts (remove-if (lambda (restart) (not (lispx::restart-handler-applicable-to-condition-p restart condition?))) (slot-value handler-frame (quote handlers)))) (slot-value handler-frame (quote parent-frame?))) restarts))) (defclass restart-error (error) (restart-name)) (defun make-restart-error (restart-name) (make-instance #^restart-error :restart-name restart-name)) (defclass simple-error (error) (message)) (defun make-simple-error (message) (make-instance #^simple-error :message message)) (defun simple-error (message) (error (make-simple-error message)))"),this.eval_js_string("(defun make-string-input-stream (string) (%make-string-input-stream string)) (defexpr with-standard-input-from-string (string . forms) env (let ((s (eval string env))) (dynamic-let ((*standard-input* (make-string-input-stream s))) (eval (list* #'progn forms) env)))) (defun make-string-output-stream () (%make-string-output-stream)) (defun get-output-stream-string (stream) (%get-output-stream-string stream)) (defexpr with-standard-output-to-string forms env (dynamic-let ((*standard-output* (make-string-output-stream))) (eval (list* #'progn forms) env) (get-output-stream-string (dynamic *standard-output*)))) (defun fresh-line stream? (%fresh-line (optional stream? (dynamic *standard-output*)))) (defun force-output stream? (%force-output (optional stream? (dynamic *standard-output*))))"),this.eval_js_string("(defun read arguments (apply #'stream-read (optionals arguments (dynamic *standard-input*) #t #void))) (defgeneric stream-read (stream eof-error-p eof-value)) (defmethod stream-read ((stream input-stream) eof-error-p eof-value) (%read stream eof-error-p eof-value))"),this.eval_js_string("(defun write (object . keywords) (%write object (optional (get? keywords :stream) (dynamic *standard-output*)))) (defun write-to-string (object) (with-standard-output-to-string (write object))) (defun print1 (object) (dynamic-let ((*print-escape* #t)) (write object))) (defun uprint1 (object) (dynamic-let ((*print-escape* #f)) (write object))) (defun print (object) (fresh-line) (prog1 (print1 object) (force-output))) (defun uprint (object) (fresh-line) (prog1 (uprint1 object) (force-output)))"),this.eval_js_string("(defun js-eq (a b) (eq a b)) (defun apply-js-function (js-function arguments) (apply (to-lisp-function js-function) arguments)) (defun call-js-function (js-function . arguments) (apply-js-function js-function arguments)) (defmacro js-lambda (parameter-tree . forms) (list #'to-js-function (list #'lambda parameter-tree (list #'push-subcont-barrier (list* #'push-prompt (quote +root-prompt+) forms))))) (defun js-global (name) (%js-global name)) (defun js-new (constructor . arguments) (apply #'%js-new (cons constructor arguments))) (defun js-get (object name) (%js-get object name)) (defun to-lisp-boolean (js-boolean) (%to-lisp-boolean js-boolean)) (defun to-js-boolean (lisp-boolean) (%to-js-boolean lisp-boolean)) (defun to-lisp-number (js-number) (%to-lisp-number js-number)) (defun to-js-number (lisp-number) (%to-js-number lisp-number)) (defun to-lisp-string (js-string) (%to-lisp-string js-string)) (defun to-js-string (lisp-string) (%to-js-string lisp-string)) (defun to-lisp-function (js-function) (%to-lisp-function js-function)) (defun to-js-function (lisp-operator) (%to-js-function lisp-operator)) (defun list-to-js-array (list) (%list-to-js-array list)) (defun js-array-to-list (array) (%js-array-to-list array)) (defun js-array elements (list-to-js-array elements)) (defmethod elt ((seq object) index) (if (or (< index 0) (>= index (length seq))) (error (make-instance #^out-of-bounds-error)) (%js-elt seq index))) (defmethod length ((seq object)) (to-lisp-number (js-get seq \"length\"))) (defun apply-js-method (receiver name arguments) (%apply-js-method receiver name arguments)) (defun call-js-method (receiver name . arguments) (apply #'apply-js-method (list receiver name arguments))) (defun js-method (method-name) (lambda (receiver . arguments) (apply-js-method receiver method-name arguments))) (defmacro define-js-method (name method-name) (list #'def (function-symbol name) (js-method method-name))) (defun js-undefined-option (value) (if (eq value +js-undefined+) () (some value))) (defun js-null-option (value) (if (eq value +js-null+) () (some value))) (defun await (promise) (yield k (call-js-method promise \"then\" (js-lambda (value) (resume k value)) (js-lambda (error) (resume k (error error)))))) (defun sync (#'fun) (lambda args (await (apply #'fun args)))) (defmacro define-js-method/sync (name method-name) (list #'def (function-symbol name) (sync (js-method method-name)))) (defun sleep (ms) (await (%sleep ms))) (defun js-log arguments (apply #'%js-log arguments))")}str(e){return new this.String(this.utf8_encode(e))}sym(e,t=this.VARIABLE_NAMESPACE){return this.intern(this.str(e),t)}fsym(e){return this.sym(e,this.FUNCTION_NAMESPACE)}csym(e){return this.sym(e,this.CLASS_NAMESPACE)}kwd(e){return this.sym(e,this.KEYWORD_NAMESPACE)}intern(e,t=this.VARIABLE_NAMESPACE){this.assert_type(e,this.String),this.assert_type(t,"string");const n=this.Symbol.make_key(e,t),r=this.symbols[n];return void 0!==r?r:this.symbols[n]=new this.Symbol(e,t)}num(e){return this.assert_type(e,this.type_or("string","number")),new this.Number(new d(e))}cons(e,t){return new this.Cons(e,t)}list(...e){return this.array_to_list(e)}make_environment(e=null){return new this.Environment(e)}equal(e,t){return this.is_lisp_object(e)&&this.is_lisp_object(t)&&this.class_of(e)===this.class_of(t)?e.equal_same_type(t):e===t}compare(e,t){if(this.is_lisp_object(e)&&this.is_lisp_object(t)&&this.class_of(e)===this.class_of(t))return e.compare_same_type(t);throw this.make_type_error(t,this.class_of(e).get_js_class())}is_lisp_object(e){return e instanceof this.Object}class_of(e){return this.is_lisp_object(e)?e.lisp_class:this.lisp_class(this.Object)}lisp_class(e){return this.assert_type(e,"function"),this.assert(this.has_lisp_class(e)),e.prototype.lisp_class}has_lisp_class(e){return this.has_type(e.prototype.lisp_class,this.Class)}get_environment(){return this.environment}}return t})()));